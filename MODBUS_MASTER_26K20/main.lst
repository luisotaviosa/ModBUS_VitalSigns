CCS PCH C Compiler, Version 5.007, 61971               15-ago-16 14:55

               Filename:   \\192.168.25.2\storage\Repositório\LuisOtávio\RS485\MODBUS_MASTER_26K20\main.lst

               ROM used:   8596 bytes (13%)
                           Largest free fragment is 55400
               RAM used:   184 (5%) at main() level
                           268 (7%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 31

*
00600:  GOTO   2726
*
00608:  MOVWF  04
0060A:  MOVFF  FD8,05
0060E:  MOVFF  FE0,06
00612:  MOVLB  0
00614:  MOVFF  FE9,0C
00618:  MOVFF  FEA,07
0061C:  MOVFF  FE1,08
00620:  MOVFF  FE2,09
00624:  MOVFF  FD9,0A
00628:  MOVFF  FDA,0B
0062C:  MOVFF  FF3,12
00630:  MOVFF  FF4,13
00634:  MOVFF  FFA,14
00638:  MOVFF  00,0E
0063C:  MOVFF  01,0F
00640:  MOVFF  02,10
00644:  MOVFF  03,11
00648:  BTFSS  F9D.0
0064A:  GOTO   0654
0064E:  BTFSC  F9E.0
00650:  GOTO   09E4
00654:  BTFSS  FF2.4
00656:  GOTO   0660
0065A:  BTFSC  FF2.1
0065C:  GOTO   0AC8
00660:  MOVFF  0E,00
00664:  MOVFF  0F,01
00668:  MOVFF  10,02
0066C:  MOVFF  11,03
00670:  MOVFF  0C,FE9
00674:  MOVFF  07,FEA
00678:  BSF    07.7
0067A:  MOVFF  08,FE1
0067E:  MOVFF  09,FE2
00682:  MOVFF  0A,FD9
00686:  MOVFF  0B,FDA
0068A:  MOVFF  12,FF3
0068E:  MOVFF  13,FF4
00692:  MOVFF  14,FFA
00696:  MOVF   04,W
00698:  MOVFF  06,FE0
0069C:  MOVFF  05,FD8
006A0:  RETFIE 0
.................... #include <main.h> 
.................... #include <hardware.h> 
.................... #include <18F26K20.h> 
.................... //////// Standard Header file for the PIC18F26K20 device //////////////// 
*
009EA:  BCF    F9E.0
009EC:  GOTO   0660
.................... #device PIC18F26K20 
*
006A2:  BTFSS  07.7
006A4:  BRA    06AC
006A6:  MOVFF  FF2,0D
006AA:  BCF    FF2.7
006AC:  CLRF   FF7
006AE:  ADDLW  C4
006B0:  MOVWF  FF6
006B2:  MOVLW  06
006B4:  ADDWFC FF7,F
006B6:  TBLRD*+
006B8:  MOVF   FF5,W
006BA:  BTFSS  07.7
006BC:  BRA    06C2
006BE:  BTFSC  0D.7
006C0:  BSF    FF2.7
006C2:  RETURN 0
006C4:  DATA 00,C1
006C6:  DATA 81,40
006C8:  DATA 01,C0
006CA:  DATA 80,41
006CC:  DATA 01,C0
006CE:  DATA 80,41
006D0:  DATA 00,C1
006D2:  DATA 81,40
006D4:  DATA 01,C0
006D6:  DATA 80,41
006D8:  DATA 00,C1
006DA:  DATA 81,40
006DC:  DATA 00,C1
006DE:  DATA 81,40
006E0:  DATA 01,C0
006E2:  DATA 80,41
006E4:  DATA 01,C0
006E6:  DATA 80,41
006E8:  DATA 00,C1
006EA:  DATA 81,40
006EC:  DATA 00,C1
006EE:  DATA 81,40
006F0:  DATA 01,C0
006F2:  DATA 80,41
006F4:  DATA 00,C1
006F6:  DATA 81,40
006F8:  DATA 01,C0
006FA:  DATA 80,41
006FC:  DATA 01,C0
006FE:  DATA 80,41
00700:  DATA 00,C1
00702:  DATA 81,40
00704:  DATA 01,C0
00706:  DATA 80,41
00708:  DATA 00,C1
0070A:  DATA 81,40
0070C:  DATA 00,C1
0070E:  DATA 81,40
00710:  DATA 01,C0
00712:  DATA 80,41
00714:  DATA 00,C1
00716:  DATA 81,40
00718:  DATA 01,C0
0071A:  DATA 80,41
0071C:  DATA 01,C0
0071E:  DATA 80,41
00720:  DATA 00,C1
00722:  DATA 81,40
00724:  DATA 00,C1
00726:  DATA 81,40
00728:  DATA 01,C0
0072A:  DATA 80,41
0072C:  DATA 01,C0
0072E:  DATA 80,41
00730:  DATA 00,C1
00732:  DATA 81,40
00734:  DATA 01,C0
00736:  DATA 80,41
00738:  DATA 00,C1
0073A:  DATA 81,40
0073C:  DATA 00,C1
0073E:  DATA 81,40
00740:  DATA 01,C0
00742:  DATA 80,41
00744:  DATA 01,C0
00746:  DATA 80,41
00748:  DATA 00,C1
0074A:  DATA 81,40
0074C:  DATA 00,C1
0074E:  DATA 81,40
00750:  DATA 01,C0
00752:  DATA 80,41
00754:  DATA 00,C1
00756:  DATA 81,40
00758:  DATA 01,C0
0075A:  DATA 80,41
0075C:  DATA 01,C0
0075E:  DATA 80,41
00760:  DATA 00,C1
00762:  DATA 81,40
00764:  DATA 00,C1
00766:  DATA 81,40
00768:  DATA 01,C0
0076A:  DATA 80,41
0076C:  DATA 01,C0
0076E:  DATA 80,41
00770:  DATA 00,C1
00772:  DATA 81,40
00774:  DATA 01,C0
00776:  DATA 80,41
00778:  DATA 00,C1
0077A:  DATA 81,40
0077C:  DATA 00,C1
0077E:  DATA 81,40
00780:  DATA 01,C0
00782:  DATA 80,41
00784:  DATA 00,C1
00786:  DATA 81,40
00788:  DATA 01,C0
0078A:  DATA 80,41
0078C:  DATA 01,C0
0078E:  DATA 80,41
00790:  DATA 00,C1
00792:  DATA 81,40
00794:  DATA 01,C0
00796:  DATA 80,41
00798:  DATA 00,C1
0079A:  DATA 81,40
0079C:  DATA 00,C1
0079E:  DATA 81,40
007A0:  DATA 01,C0
007A2:  DATA 80,41
007A4:  DATA 01,C0
007A6:  DATA 80,41
007A8:  DATA 00,C1
007AA:  DATA 81,40
007AC:  DATA 00,C1
007AE:  DATA 81,40
007B0:  DATA 01,C0
007B2:  DATA 80,41
007B4:  DATA 00,C1
007B6:  DATA 81,40
007B8:  DATA 01,C0
007BA:  DATA 80,41
007BC:  DATA 01,C0
007BE:  DATA 80,41
007C0:  DATA 00,C1
007C2:  DATA 81,40
007C4:  BTFSS  07.7
007C6:  BRA    07CE
007C8:  MOVFF  FF2,0D
007CC:  BCF    FF2.7
007CE:  CLRF   FF7
007D0:  ADDLW  E6
007D2:  MOVWF  FF6
007D4:  MOVLW  07
007D6:  ADDWFC FF7,F
007D8:  TBLRD*+
007DA:  MOVF   FF5,W
007DC:  BTFSS  07.7
007DE:  BRA    07E4
007E0:  BTFSC  0D.7
007E2:  BSF    FF2.7
007E4:  RETURN 0
007E6:  DATA 00,C0
007E8:  DATA C1,01
007EA:  DATA C3,03
007EC:  DATA 02,C2
007EE:  DATA C6,06
007F0:  DATA 07,C7
007F2:  DATA 05,C5
007F4:  DATA C4,04
007F6:  DATA CC,0C
007F8:  DATA 0D,CD
007FA:  DATA 0F,CF
007FC:  DATA CE,0E
007FE:  DATA 0A,CA
00800:  DATA CB,0B
00802:  DATA C9,09
00804:  DATA 08,C8
00806:  DATA D8,18
00808:  DATA 19,D9
0080A:  DATA 1B,DB
0080C:  DATA DA,1A
0080E:  DATA 1E,DE
00810:  DATA DF,1F
00812:  DATA DD,1D
00814:  DATA 1C,DC
00816:  DATA 14,D4
00818:  DATA D5,15
0081A:  DATA D7,17
0081C:  DATA 16,D6
0081E:  DATA D2,12
00820:  DATA 13,D3
00822:  DATA 11,D1
00824:  DATA D0,10
00826:  DATA F0,30
00828:  DATA 31,F1
0082A:  DATA 33,F3
0082C:  DATA F2,32
0082E:  DATA 36,F6
00830:  DATA F7,37
00832:  DATA F5,35
00834:  DATA 34,F4
00836:  DATA 3C,FC
00838:  DATA FD,3D
0083A:  DATA FF,3F
0083C:  DATA 3E,FE
0083E:  DATA FA,3A
00840:  DATA 3B,FB
00842:  DATA 39,F9
00844:  DATA F8,38
00846:  DATA 28,E8
00848:  DATA E9,29
0084A:  DATA EB,2B
0084C:  DATA 2A,EA
0084E:  DATA EE,2E
00850:  DATA 2F,EF
00852:  DATA 2D,ED
00854:  DATA EC,2C
00856:  DATA E4,24
00858:  DATA 25,E5
0085A:  DATA 27,E7
0085C:  DATA E6,26
0085E:  DATA 22,E2
00860:  DATA E3,23
00862:  DATA E1,21
00864:  DATA 20,E0
00866:  DATA A0,60
00868:  DATA 61,A1
0086A:  DATA 63,A3
0086C:  DATA A2,62
0086E:  DATA 66,A6
00870:  DATA A7,67
00872:  DATA A5,65
00874:  DATA 64,A4
00876:  DATA 6C,AC
00878:  DATA AD,6D
0087A:  DATA AF,6F
0087C:  DATA 6E,AE
0087E:  DATA AA,6A
00880:  DATA 6B,AB
00882:  DATA 69,A9
00884:  DATA A8,68
00886:  DATA 78,B8
00888:  DATA B9,79
0088A:  DATA BB,7B
0088C:  DATA 7A,BA
0088E:  DATA BE,7E
00890:  DATA 7F,BF
00892:  DATA 7D,BD
00894:  DATA BC,7C
00896:  DATA B4,74
00898:  DATA 75,B5
0089A:  DATA 77,B7
0089C:  DATA B6,76
0089E:  DATA 72,B2
008A0:  DATA B3,73
008A2:  DATA B1,71
008A4:  DATA 70,B0
008A6:  DATA 50,90
008A8:  DATA 91,51
008AA:  DATA 93,53
008AC:  DATA 52,92
008AE:  DATA 96,56
008B0:  DATA 57,97
008B2:  DATA 55,95
008B4:  DATA 94,54
008B6:  DATA 9C,5C
008B8:  DATA 5D,9D
008BA:  DATA 5F,9F
008BC:  DATA 9E,5E
008BE:  DATA 5A,9A
008C0:  DATA 9B,5B
008C2:  DATA 99,59
008C4:  DATA 58,98
008C6:  DATA 88,48
008C8:  DATA 49,89
008CA:  DATA 4B,8B
008CC:  DATA 8A,4A
008CE:  DATA 4E,8E
008D0:  DATA 8F,4F
008D2:  DATA 8D,4D
008D4:  DATA 4C,8C
008D6:  DATA 44,84
008D8:  DATA 85,45
008DA:  DATA 87,47
008DC:  DATA 46,86
008DE:  DATA 82,42
008E0:  DATA 43,83
008E2:  DATA 41,81
008E4:  DATA 80,40
008E6:  MOVFF  FF2,0D
008EA:  BCF    FF2.7
008EC:  CLRF   FF7
008EE:  ADDLW  00
008F0:  MOVWF  FF6
008F2:  MOVLW  09
008F4:  ADDWFC FF7,F
008F6:  TBLRD*+
008F8:  MOVF   FF5,W
008FA:  BTFSC  0D.7
008FC:  BSF    FF2.7
008FE:  RETURN 0
00900:  DATA 52,45
00902:  DATA 53,45
00904:  DATA 54,00
00906:  MOVFF  FF2,0D
0090A:  BCF    FF2.7
0090C:  CLRF   FF7
0090E:  ADDLW  20
00910:  MOVWF  FF6
00912:  MOVLW  09
00914:  ADDWFC FF7,F
00916:  TBLRD*+
00918:  MOVF   FF5,W
0091A:  BTFSC  0D.7
0091C:  BSF    FF2.7
0091E:  RETURN 0
00920:  DATA 41,4C
00922:  DATA 4C,5F
00924:  DATA 43,4F
00926:  DATA 49,4C
00928:  DATA 53,00
0092A:  MOVFF  FF2,0D
0092E:  BCF    FF2.7
00930:  CLRF   FF7
00932:  ADDLW  44
00934:  MOVWF  FF6
00936:  MOVLW  09
00938:  ADDWFC FF7,F
0093A:  TBLRD*+
0093C:  MOVF   FF5,W
0093E:  BTFSC  0D.7
00940:  BSF    FF2.7
00942:  RETURN 0
00944:  DATA 54,45
00946:  DATA 4D,50
00948:  DATA 00,00
0094A:  MOVFF  FF2,0D
0094E:  BCF    FF2.7
00950:  CLRF   FF7
00952:  ADDLW  64
00954:  MOVWF  FF6
00956:  MOVLW  09
00958:  ADDWFC FF7,F
0095A:  TBLRD*+
0095C:  MOVF   FF5,W
0095E:  BTFSC  0D.7
00960:  BSF    FF2.7
00962:  RETURN 0
00964:  DATA 42,50
00966:  DATA 4D,00
00968:  MOVFF  FF2,0D
0096C:  BCF    FF2.7
0096E:  CLRF   FF7
00970:  ADDLW  82
00972:  MOVWF  FF6
00974:  MOVLW  09
00976:  ADDWFC FF7,F
00978:  TBLRD*+
0097A:  MOVF   FF5,W
0097C:  BTFSC  0D.7
0097E:  BSF    FF2.7
00980:  RETURN 0
00982:  DATA 41,4C
00984:  DATA 4C,00
00986:  MOVFF  FF2,0D
0098A:  BCF    FF2.7
0098C:  CLRF   FF7
0098E:  ADDLW  A0
00990:  MOVWF  FF6
00992:  MOVLW  09
00994:  ADDWFC FF7,F
00996:  TBLRD*+
00998:  MOVF   FF5,W
0099A:  BTFSC  0D.7
0099C:  BSF    FF2.7
0099E:  RETURN 0
009A0:  DATA 49,4E
009A2:  DATA 50,55
009A4:  DATA 54,53
009A6:  DATA 00,00
009A8:  MOVFF  FF2,0D
009AC:  BCF    FF2.7
009AE:  CLRF   FF7
009B0:  ADDLW  C2
009B2:  MOVWF  FF6
009B4:  MOVLW  09
009B6:  ADDWFC FF7,F
009B8:  TBLRD*+
009BA:  MOVF   FF5,W
009BC:  BTFSC  0D.7
009BE:  BSF    FF2.7
009C0:  RETURN 0
009C2:  DATA 53,45
009C4:  DATA 54,00
009C6:  MOVFF  FF2,0D
009CA:  BCF    FF2.7
009CC:  CLRF   FF7
009CE:  ADDLW  E0
009D0:  MOVWF  FF6
009D2:  MOVLW  09
009D4:  ADDWFC FF7,F
009D6:  TBLRD*+
009D8:  MOVF   FF5,W
009DA:  BTFSC  0D.7
009DC:  BSF    FF2.7
009DE:  RETURN 0
009E0:  DATA 47,45
009E2:  DATA 54,00
009E4:  INCF   x63,F
009E6:  BTFSC  FD8.2
009E8:  INCF   x64,F
*
00B38:  DATA 43,6F
00B3A:  DATA 69,6C
00B3C:  DATA 73,3A
00B3E:  DATA 0D,0A
00B40:  DATA 00,00
00B42:  DATA 44,61
00B44:  DATA 74,61
00B46:  DATA 3A,20
00B48:  DATA 00,00
00B4A:  DATA 47,45
00B4C:  DATA 54,5F
00B4E:  DATA 41,4C
00B50:  DATA 4C,5F
00B52:  DATA 43,4F
00B54:  DATA 49,4C
00B56:  DATA 53,3D
00B58:  DATA 25,75
00B5A:  DATA 3A,25
00B5C:  DATA 58,2A
00B5E:  DATA 00,00
00B60:  DATA 0D,0A
00B62:  DATA 0D,0A
00B64:  DATA 00,00
00B66:  DATA 45,52
00B68:  DATA 52,5F
00B6A:  DATA 41,4C
00B6C:  DATA 4C,5F
00B6E:  DATA 43,4F
00B70:  DATA 49,4C
00B72:  DATA 53,3D
00B74:  DATA 25,75
00B76:  DATA 3A,25
00B78:  DATA 58,2A
00B7A:  DATA 00,00
00B7C:  DATA 49,6E
00B7E:  DATA 70,75
00B80:  DATA 74,73
00B82:  DATA 3A,0D
00B84:  DATA 0A,00
00B86:  DATA 44,61
00B88:  DATA 74,61
00B8A:  DATA 3A,20
00B8C:  DATA 00,00
00B8E:  DATA 0D,0A
00B90:  DATA 0D,0A
00B92:  DATA 00,00
00B94:  DATA 47,45
00B96:  DATA 54,5F
00B98:  DATA 54,45
00B9A:  DATA 4D,50
00B9C:  DATA 3D,25
00B9E:  DATA 75,3A
00BA0:  DATA 25,66
00BA2:  DATA 2A,0D
00BA4:  DATA 0A,00
00BA6:  DATA 47,45
00BA8:  DATA 54,5F
00BAA:  DATA 54,45
00BAC:  DATA 4D,50
00BAE:  DATA 3D,25
00BB0:  DATA 75,3A
00BB2:  DATA 45,52
00BB4:  DATA 52,4F
00BB6:  DATA 5F,25
00BB8:  DATA 58,2A
00BBA:  DATA 0D,0A
00BBC:  DATA 00,00
00BBE:  DATA 47,45
00BC0:  DATA 54,5F
00BC2:  DATA 42,50
00BC4:  DATA 4D,3D
00BC6:  DATA 25,75
00BC8:  DATA 3A,25
00BCA:  DATA 6C,75
00BCC:  DATA 2A,0D
00BCE:  DATA 0A,00
00BD0:  DATA 47,45
00BD2:  DATA 54,5F
00BD4:  DATA 42,50
00BD6:  DATA 4D,3D
00BD8:  DATA 25,75
00BDA:  DATA 3A,45
00BDC:  DATA 52,52
00BDE:  DATA 4F,5F
00BE0:  DATA 25,58
00BE2:  DATA 2A,0D
00BE4:  DATA 0A,00
00BE6:  DATA 48,6F
00BE8:  DATA 6C,64
00BEA:  DATA 69,6E
00BEC:  DATA 67,20
00BEE:  DATA 52,65
00BF0:  DATA 67,69
00BF2:  DATA 73,74
00BF4:  DATA 65,72
00BF6:  DATA 73,3A
00BF8:  DATA 0D,0A
00BFA:  DATA 00,00
00BFC:  DATA 44,61
00BFE:  DATA 74,61
00C00:  DATA 3A,20
00C02:  DATA 00,00
00C04:  DATA 0D,0A
00C06:  DATA 0D,0A
00C08:  DATA 00,00
00C0A:  DATA 3C,2D
00C0C:  DATA 2A,2A
00C0E:  DATA 45,78
00C10:  DATA 63,65
00C12:  DATA 70,74
00C14:  DATA 69,6F
00C16:  DATA 6E,20
00C18:  DATA 25,58
00C1A:  DATA 2A,2A
00C1C:  DATA 2D,3E
00C1E:  DATA 0D,0A
00C20:  DATA 0D,0A
00C22:  DATA 00,00
00C24:  DATA 44,61
00C26:  DATA 74,61
00C28:  DATA 3A,20
00C2A:  DATA 00,00
00C2C:  DATA 0D,0A
00C2E:  DATA 0D,0A
00C30:  DATA 00,00
00C32:  DATA 57,72
00C34:  DATA 69,74
00C36:  DATA 69,6E
00C38:  DATA 67,20
00C3A:  DATA 53,69
00C3C:  DATA 6E,67
00C3E:  DATA 6C,65
00C40:  DATA 20,43
00C42:  DATA 6F,69
00C44:  DATA 6C,3A
00C46:  DATA 0D,0A
00C48:  DATA 00,00
00C4A:  DATA 44,61
00C4C:  DATA 74,61
00C4E:  DATA 3A,20
00C50:  DATA 00,00
00C52:  DATA 0D,0A
00C54:  DATA 0D,0A
00C56:  DATA 00,00
00C58:  DATA 3C,2D
00C5A:  DATA 2A,2A
00C5C:  DATA 45,78
00C5E:  DATA 63,65
00C60:  DATA 70,74
00C62:  DATA 69,6F
00C64:  DATA 6E,20
00C66:  DATA 25,58
00C68:  DATA 2A,2A
00C6A:  DATA 2D,3E
00C6C:  DATA 0D,0A
00C6E:  DATA 0D,0A
00C70:  DATA 00,00
00C72:  DATA 57,72
00C74:  DATA 69,74
00C76:  DATA 69,6E
00C78:  DATA 67,20
00C7A:  DATA 53,69
00C7C:  DATA 6E,67
00C7E:  DATA 6C,65
00C80:  DATA 20,52
00C82:  DATA 65,67
00C84:  DATA 69,73
00C86:  DATA 74,65
00C88:  DATA 72,3A
00C8A:  DATA 0D,0A
00C8C:  DATA 00,00
00C8E:  DATA 44,61
00C90:  DATA 74,61
00C92:  DATA 3A,20
00C94:  DATA 00,00
00C96:  DATA 0D,0A
00C98:  DATA 0D,0A
00C9A:  DATA 00,00
00C9C:  DATA 3C,2D
00C9E:  DATA 2A,2A
00CA0:  DATA 45,78
00CA2:  DATA 63,65
00CA4:  DATA 70,74
00CA6:  DATA 69,6F
00CA8:  DATA 6E,20
00CAA:  DATA 25,58
00CAC:  DATA 2A,2A
00CAE:  DATA 2D,3E
00CB0:  DATA 0D,0A
00CB2:  DATA 0D,0A
00CB4:  DATA 00,00
00CB6:  DATA 57,72
00CB8:  DATA 69,74
00CBA:  DATA 69,6E
00CBC:  DATA 67,20
00CBE:  DATA 4D,75
00CC0:  DATA 6C,74
00CC2:  DATA 69,70
00CC4:  DATA 6C,65
00CC6:  DATA 20,43
00CC8:  DATA 6F,69
00CCA:  DATA 6C,73
00CCC:  DATA 3A,0D
00CCE:  DATA 0A,00
00CD0:  DATA 44,61
00CD2:  DATA 74,61
00CD4:  DATA 3A,20
00CD6:  DATA 00,00
00CD8:  DATA 0D,0A
00CDA:  DATA 0D,0A
00CDC:  DATA 00,00
00CDE:  DATA 3C,2D
00CE0:  DATA 2A,2A
00CE2:  DATA 45,78
00CE4:  DATA 63,65
00CE6:  DATA 70,74
00CE8:  DATA 69,6F
00CEA:  DATA 6E,20
00CEC:  DATA 25,58
00CEE:  DATA 2A,2A
00CF0:  DATA 2D,3E
00CF2:  DATA 0D,0A
00CF4:  DATA 0D,0A
00CF6:  DATA 00,00
00CF8:  DATA 57,72
00CFA:  DATA 69,74
00CFC:  DATA 69,6E
00CFE:  DATA 67,20
00D00:  DATA 4D,75
00D02:  DATA 6C,74
00D04:  DATA 69,70
00D06:  DATA 6C,65
00D08:  DATA 20,52
00D0A:  DATA 65,67
00D0C:  DATA 69,73
00D0E:  DATA 74,65
00D10:  DATA 72,73
00D12:  DATA 3A,0D
00D14:  DATA 0A,00
00D16:  DATA 44,61
00D18:  DATA 74,61
00D1A:  DATA 3A,20
00D1C:  DATA 00,00
00D1E:  DATA 0D,0A
00D20:  DATA 0D,0A
00D22:  DATA 00,00
00D24:  DATA 3C,2D
00D26:  DATA 2A,2A
00D28:  DATA 45,78
00D2A:  DATA 63,65
00D2C:  DATA 70,74
00D2E:  DATA 69,6F
00D30:  DATA 6E,20
00D32:  DATA 25,58
00D34:  DATA 2A,2A
00D36:  DATA 2D,3E
00D38:  DATA 0D,0A
00D3A:  DATA 0D,0A
00D3C:  DATA 00,00
00D3E:  DATA 54,72
00D40:  DATA 79,69
00D42:  DATA 6E,67
00D44:  DATA 20,75
00D46:  DATA 6E,6B
00D48:  DATA 6E,6F
00D4A:  DATA 77,6E
00D4C:  DATA 20,66
00D4E:  DATA 75,6E
00D50:  DATA 63,74
00D52:  DATA 69,6F
00D54:  DATA 6E,0D
00D56:  DATA 0A,00
00D58:  DATA 44,69
00D5A:  DATA 61,67
00D5C:  DATA 6E,6F
00D5E:  DATA 73,74
00D60:  DATA 69,63
00D62:  DATA 3A,0D
00D64:  DATA 0A,00
00D66:  DATA 44,61
00D68:  DATA 74,61
00D6A:  DATA 3A,00
00D6C:  DATA 0D,0A
00D6E:  DATA 0D,0A
00D70:  DATA 00,00
00D72:  DATA 3C,2D
00D74:  DATA 2A,2A
00D76:  DATA 45,78
00D78:  DATA 63,65
00D7A:  DATA 70,74
00D7C:  DATA 69,6F
00D7E:  DATA 6E,20
00D80:  DATA 25,58
00D82:  DATA 2A,2A
00D84:  DATA 2D,3E
00D86:  DATA 0D,0A
00D88:  DATA 0D,0A
00D8A:  DATA 00,00
00D8C:  DATA 53,45
00D8E:  DATA 54,5F
00D90:  DATA 52,45
00D92:  DATA 53,45
00D94:  DATA 54,3D
00D96:  DATA 31,3A
00D98:  DATA 4F,4B
00D9A:  DATA 2A,00
00D9C:  DATA 45,56
00D9E:  DATA 54,5F
00DA0:  DATA 57,44
00DA2:  DATA 54,5F
00DA4:  DATA 54,49
00DA6:  DATA 4D,45
00DA8:  DATA 4F,55
00DAA:  DATA 54,3D
00DAC:  DATA 31,3A
00DAE:  DATA 31,2A
00DB0:  DATA 00,00
00DB2:  DATA 45,56
00DB4:  DATA 54,5F
00DB6:  DATA 57,44
00DB8:  DATA 54,5F
00DBA:  DATA 53,4C
00DBC:  DATA 45,45
00DBE:  DATA 50,3D
00DC0:  DATA 31,3A
00DC2:  DATA 31,2A
00DC4:  DATA 00,00
00DC6:  DATA 45,56
00DC8:  DATA 54,5F
00DCA:  DATA 4D,43
00DCC:  DATA 4C,52
00DCE:  DATA 5F,46
00DD0:  DATA 52,4F
00DD2:  DATA 4D,5F
00DD4:  DATA 52,55
00DD6:  DATA 4E,3D
00DD8:  DATA 31,3A
00DDA:  DATA 31,2A
00DDC:  DATA 00,00
00DDE:  DATA 45,56
00DE0:  DATA 54,5F
00DE2:  DATA 42,52
00DE4:  DATA 4F,57
00DE6:  DATA 4E,4F
00DE8:  DATA 55,54
00DEA:  DATA 5F,52
00DEC:  DATA 45,53
00DEE:  DATA 54,41
00DF0:  DATA 52,54
00DF2:  DATA 3D,31
00DF4:  DATA 3A,31
00DF6:  DATA 2A,00
00DF8:  DATA 45,56
00DFA:  DATA 54,5F
00DFC:  DATA 4D,43
00DFE:  DATA 4C,52
00E00:  DATA 5F,46
00E02:  DATA 52,4F
00E04:  DATA 4D,5F
00E06:  DATA 53,4C
00E08:  DATA 45,45
00E0A:  DATA 50,3D
00E0C:  DATA 31,3A
00E0E:  DATA 31,2A
00E10:  DATA 00,00
00E12:  DATA 45,56
00E14:  DATA 54,5F
00E16:  DATA 52,45
00E18:  DATA 53,45
00E1A:  DATA 54,5F
00E1C:  DATA 49,4E
00E1E:  DATA 53,54
00E20:  DATA 52,55
00E22:  DATA 43,54
00E24:  DATA 49,4F
00E26:  DATA 4E,3D
00E28:  DATA 31,3A
00E2A:  DATA 31,2A
00E2C:  DATA 00,00
00E2E:  DATA 45,56
00E30:  DATA 54,5F
00E32:  DATA 4E,4F
00E34:  DATA 52,4D
00E36:  DATA 41,4C
00E38:  DATA 5F,50
00E3A:  DATA 4F,57
00E3C:  DATA 45,52
00E3E:  DATA 5F,55
00E40:  DATA 50,3D
00E42:  DATA 31,3A
00E44:  DATA 31,2A
00E46:  DATA 00,00
*
00E70:  TBLRD*+
00E72:  MOVF   FF5,F
00E74:  BZ    0E90
00E76:  MOVFF  FF6,DF
00E7A:  MOVFF  FF7,E0
00E7E:  MOVF   FF5,W
00E80:  BTFSS  F9E.4
00E82:  BRA    0E80
00E84:  MOVWF  FAD
00E86:  MOVFF  DF,FF6
00E8A:  MOVFF  E0,FF7
00E8E:  BRA    0E70
00E90:  RETURN 0
*
00F34:  MOVFF  FF2,0D
00F38:  BCF    FF2.7
00F3A:  ADDWF  FE8,W
00F3C:  CLRF   FF7
00F3E:  RLCF   FF7,F
00F40:  ADDLW  59
00F42:  MOVWF  FF6
00F44:  MOVLW  0F
00F46:  ADDWFC FF7,F
00F48:  TBLRD*-
00F4A:  MOVF   FF5,W
00F4C:  MOVWF  FFA
00F4E:  TBLRD*
00F50:  MOVF   FF5,W
00F52:  BTFSC  0D.7
00F54:  BSF    FF2.7
00F56:  MOVWF  FF9
00F58:  DATA 0E,0F
00F5A:  DATA 30,0F
00F5C:  DATA 30,0F
00F5E:  DATA C6,0E
00F60:  DATA 30,0F
00F62:  DATA 30,0F
00F64:  DATA 30,0F
00F66:  DATA B4,0E
00F68:  DATA 30,0F
00F6A:  DATA 30,0F
00F6C:  DATA 30,0F
00F6E:  DATA FC,0E
00F70:  DATA 20,0F
00F72:  DATA 30,0F
00F74:  DATA EA,0E
00F76:  DATA D8,0E
*
00FA8:  MOVFF  EF,F6
00FAC:  MOVF   xF3,W
00FAE:  XORWF  xF6,F
00FB0:  BTFSS  xF6.7
00FB2:  BRA    0FBE
00FB4:  BCF    FD8.2
00FB6:  BCF    FD8.0
00FB8:  BTFSC  xEF.7
00FBA:  BSF    FD8.0
00FBC:  BRA    101C
00FBE:  MOVFF  EF,F6
00FC2:  MOVFF  F2,F7
00FC6:  MOVF   xEE,W
00FC8:  SUBWF  xF7,F
00FCA:  BZ    0FD8
00FCC:  BTFSS  xF6.7
00FCE:  BRA    101C
00FD0:  MOVF   FD8,W
00FD2:  XORLW  01
00FD4:  MOVWF  FD8
00FD6:  BRA    101C
00FD8:  MOVFF  F3,F7
00FDC:  MOVF   xEF,W
00FDE:  SUBWF  xF7,F
00FE0:  BZ    0FEE
00FE2:  BTFSS  xF6.7
00FE4:  BRA    101C
00FE6:  MOVF   FD8,W
00FE8:  XORLW  01
00FEA:  MOVWF  FD8
00FEC:  BRA    101C
00FEE:  MOVFF  F4,F7
00FF2:  MOVF   xF0,W
00FF4:  SUBWF  xF7,F
00FF6:  BZ    1004
00FF8:  BTFSS  xF6.7
00FFA:  BRA    101C
00FFC:  MOVF   FD8,W
00FFE:  XORLW  01
01000:  MOVWF  FD8
01002:  BRA    101C
01004:  MOVFF  F5,F7
01008:  MOVF   xF1,W
0100A:  SUBWF  xF7,F
0100C:  BZ    101A
0100E:  BTFSS  xF6.7
01010:  BRA    101C
01012:  MOVF   FD8,W
01014:  XORLW  01
01016:  MOVWF  FD8
01018:  BRA    101C
0101A:  BCF    FD8.0
0101C:  RETURN 0
*
01036:  MOVLW  80
01038:  BTFSC  FD8.1
0103A:  XORWF  xF3,F
0103C:  CLRF   xF8
0103E:  CLRF   xF9
01040:  MOVFF  EF,F7
01044:  MOVF   xF3,W
01046:  XORWF  xF7,F
01048:  MOVF   xEE,W
0104A:  BTFSC  FD8.2
0104C:  BRA    1206
0104E:  MOVWF  xF6
01050:  MOVWF  00
01052:  MOVF   xF2,W
01054:  BTFSC  FD8.2
01056:  BRA    1218
01058:  SUBWF  xF6,F
0105A:  BTFSC  FD8.2
0105C:  BRA    1160
0105E:  BNC   10DA
01060:  MOVFF  F3,FC
01064:  BSF    xFC.7
01066:  MOVFF  F4,FB
0106A:  MOVFF  F5,FA
0106E:  CLRF   xF9
01070:  BCF    FD8.0
01072:  RRCF   xFC,F
01074:  RRCF   xFB,F
01076:  RRCF   xFA,F
01078:  RRCF   xF9,F
0107A:  DECFSZ xF6,F
0107C:  BRA    106E
0107E:  BTFSS  xF7.7
01080:  BRA    1088
01082:  BSF    xF8.0
01084:  BRA    1240
01086:  BCF    xF8.0
01088:  BCF    xF6.0
0108A:  BSF    xF8.4
0108C:  CLRF   FEA
0108E:  MOVLW  F1
01090:  MOVWF  FE9
01092:  BRA    1266
01094:  BCF    xF8.4
01096:  BTFSC  xF7.7
01098:  BRA    10AE
0109A:  BTFSS  xF6.0
0109C:  BRA    10C4
0109E:  RRCF   xFC,F
010A0:  RRCF   xFB,F
010A2:  RRCF   xFA,F
010A4:  RRCF   xF9,F
010A6:  INCF   00,F
010A8:  BTFSC  FD8.2
010AA:  BRA    1236
010AC:  BRA    10C4
010AE:  BTFSC  xFC.7
010B0:  BRA    10CA
010B2:  BCF    FD8.0
010B4:  RLCF   xF9,F
010B6:  RLCF   xFA,F
010B8:  RLCF   xFB,F
010BA:  RLCF   xFC,F
010BC:  DECF   00,F
010BE:  BTFSC  FD8.2
010C0:  BRA    1236
010C2:  BRA    10AE
010C4:  BSF    xF8.6
010C6:  BRA    119E
010C8:  BCF    xF8.6
010CA:  MOVFF  EF,F7
010CE:  BTFSS  xEF.7
010D0:  BRA    10D6
010D2:  BSF    xFC.7
010D4:  BRA    1228
010D6:  BCF    xFC.7
010D8:  BRA    1228
010DA:  MOVFF  F2,F6
010DE:  MOVFF  F2,00
010E2:  MOVF   xEE,W
010E4:  SUBWF  xF6,F
010E6:  MOVFF  EF,FC
010EA:  BSF    xFC.7
010EC:  MOVFF  F0,FB
010F0:  MOVFF  F1,FA
010F4:  CLRF   xF9
010F6:  BCF    FD8.0
010F8:  RRCF   xFC,F
010FA:  RRCF   xFB,F
010FC:  RRCF   xFA,F
010FE:  RRCF   xF9,F
01100:  DECFSZ xF6,F
01102:  BRA    10F4
01104:  BTFSS  xF7.7
01106:  BRA    110E
01108:  BSF    xF8.1
0110A:  BRA    1240
0110C:  BCF    xF8.1
0110E:  BCF    xF6.0
01110:  BSF    xF8.5
01112:  CLRF   FEA
01114:  MOVLW  F5
01116:  MOVWF  FE9
01118:  BRA    1266
0111A:  BCF    xF8.5
0111C:  BTFSC  xF7.7
0111E:  BRA    1134
01120:  BTFSS  xF6.0
01122:  BRA    114A
01124:  RRCF   xFC,F
01126:  RRCF   xFB,F
01128:  RRCF   xFA,F
0112A:  RRCF   xF9,F
0112C:  INCF   00,F
0112E:  BTFSC  FD8.2
01130:  BRA    1236
01132:  BRA    114A
01134:  BTFSC  xFC.7
01136:  BRA    1150
01138:  BCF    FD8.0
0113A:  RLCF   xF9,F
0113C:  RLCF   xFA,F
0113E:  RLCF   xFB,F
01140:  RLCF   xFC,F
01142:  DECF   00,F
01144:  BTFSC  FD8.2
01146:  BRA    1236
01148:  BRA    1134
0114A:  BSF    xF8.7
0114C:  BRA    119E
0114E:  BCF    xF8.7
01150:  MOVFF  F3,F7
01154:  BTFSS  xF3.7
01156:  BRA    115C
01158:  BSF    xFC.7
0115A:  BRA    1228
0115C:  BCF    xFC.7
0115E:  BRA    1228
01160:  MOVFF  F3,FC
01164:  BSF    xFC.7
01166:  MOVFF  F4,FB
0116A:  MOVFF  F5,FA
0116E:  BTFSS  xF7.7
01170:  BRA    117A
01172:  BCF    xFC.7
01174:  BSF    xF8.2
01176:  BRA    1240
01178:  BCF    xF8.2
0117A:  CLRF   xF9
0117C:  BCF    xF6.0
0117E:  CLRF   FEA
01180:  MOVLW  F1
01182:  MOVWF  FE9
01184:  BRA    1266
01186:  BTFSC  xF7.7
01188:  BRA    11C2
0118A:  MOVFF  EF,F7
0118E:  BTFSS  xF6.0
01190:  BRA    119E
01192:  RRCF   xFC,F
01194:  RRCF   xFB,F
01196:  RRCF   xFA,F
01198:  RRCF   xF9,F
0119A:  INCF   00,F
0119C:  BZ    1236
0119E:  BTFSS  xF9.7
011A0:  BRA    11B8
011A2:  INCF   xFA,F
011A4:  BNZ   11B8
011A6:  INCF   xFB,F
011A8:  BNZ   11B8
011AA:  INCF   xFC,F
011AC:  BNZ   11B8
011AE:  RRCF   xFC,F
011B0:  RRCF   xFB,F
011B2:  RRCF   xFA,F
011B4:  INCF   00,F
011B6:  BZ    1236
011B8:  BTFSC  xF8.6
011BA:  BRA    10C8
011BC:  BTFSC  xF8.7
011BE:  BRA    114E
011C0:  BRA    11FA
011C2:  MOVLW  80
011C4:  XORWF  xFC,F
011C6:  BTFSS  xFC.7
011C8:  BRA    11D2
011CA:  BRA    1240
011CC:  MOVFF  F3,F7
011D0:  BRA    11E6
011D2:  MOVFF  EF,F7
011D6:  MOVF   xFC,F
011D8:  BNZ   11E6
011DA:  MOVF   xFB,F
011DC:  BNZ   11E6
011DE:  MOVF   xFA,F
011E0:  BNZ   11E6
011E2:  CLRF   00
011E4:  BRA    1228
011E6:  BTFSC  xFC.7
011E8:  BRA    11FA
011EA:  BCF    FD8.0
011EC:  RLCF   xF9,F
011EE:  RLCF   xFA,F
011F0:  RLCF   xFB,F
011F2:  RLCF   xFC,F
011F4:  DECFSZ 00,F
011F6:  BRA    11E6
011F8:  BRA    1236
011FA:  BTFSS  xF7.7
011FC:  BRA    1202
011FE:  BSF    xFC.7
01200:  BRA    1228
01202:  BCF    xFC.7
01204:  BRA    1228
01206:  MOVFF  F2,00
0120A:  MOVFF  F3,FC
0120E:  MOVFF  F4,FB
01212:  MOVFF  F5,FA
01216:  BRA    1228
01218:  MOVFF  EE,00
0121C:  MOVFF  EF,FC
01220:  MOVFF  F0,FB
01224:  MOVFF  F1,FA
01228:  MOVFF  FC,01
0122C:  MOVFF  FB,02
01230:  MOVFF  FA,03
01234:  BRA    129E
01236:  CLRF   00
01238:  CLRF   01
0123A:  CLRF   02
0123C:  CLRF   03
0123E:  BRA    129E
01240:  CLRF   xF9
01242:  COMF   xFA,F
01244:  COMF   xFB,F
01246:  COMF   xFC,F
01248:  COMF   xF9,F
0124A:  INCF   xF9,F
0124C:  BNZ   1258
0124E:  INCF   xFA,F
01250:  BNZ   1258
01252:  INCF   xFB,F
01254:  BNZ   1258
01256:  INCF   xFC,F
01258:  BTFSC  xF8.0
0125A:  BRA    1086
0125C:  BTFSC  xF8.1
0125E:  BRA    110C
01260:  BTFSC  xF8.2
01262:  BRA    1178
01264:  BRA    11CC
01266:  MOVF   FEF,W
01268:  ADDWF  xFA,F
0126A:  BNC   1276
0126C:  INCF   xFB,F
0126E:  BNZ   1276
01270:  INCF   xFC,F
01272:  BTFSC  FD8.2
01274:  BSF    xF6.0
01276:  MOVF   FED,F
01278:  MOVF   FEF,W
0127A:  ADDWF  xFB,F
0127C:  BNC   1284
0127E:  INCF   xFC,F
01280:  BTFSC  FD8.2
01282:  BSF    xF6.0
01284:  MOVF   FED,F
01286:  MOVF   FEF,W
01288:  BTFSC  FEF.7
0128A:  BRA    128E
0128C:  XORLW  80
0128E:  ADDWF  xFC,F
01290:  BTFSC  FD8.0
01292:  BSF    xF6.0
01294:  BTFSC  xF8.4
01296:  BRA    1094
01298:  BTFSC  xF8.5
0129A:  BRA    111A
0129C:  BRA    1186
0129E:  RETURN 0
*
0147E:  CLRF   00
01480:  CLRF   01
01482:  MOVF   xE4,W
01484:  BCF    FD8.0
01486:  BTFSC  xE5.0
01488:  ADDWF  00,F
0148A:  RRCF   00,F
0148C:  RRCF   01,F
0148E:  BTFSC  xE5.1
01490:  ADDWF  00,F
01492:  RRCF   00,F
01494:  RRCF   01,F
01496:  BTFSC  xE5.2
01498:  ADDWF  00,F
0149A:  RRCF   00,F
0149C:  RRCF   01,F
0149E:  BTFSC  xE5.3
014A0:  ADDWF  00,F
014A2:  RRCF   00,F
014A4:  RRCF   01,F
014A6:  BTFSC  xE5.4
014A8:  ADDWF  00,F
014AA:  RRCF   00,F
014AC:  RRCF   01,F
014AE:  BTFSC  xE5.5
014B0:  ADDWF  00,F
014B2:  RRCF   00,F
014B4:  RRCF   01,F
014B6:  BTFSC  xE5.6
014B8:  ADDWF  00,F
014BA:  RRCF   00,F
014BC:  RRCF   01,F
014BE:  BTFSC  xE5.7
014C0:  ADDWF  00,F
014C2:  RRCF   00,F
014C4:  RRCF   01,F
014C6:  GOTO   15A2 (RETURN)
*
0189E:  TBLRD*+
018A0:  MOVFF  FF6,EF
018A4:  MOVFF  FF7,F0
018A8:  MOVF   FF5,W
018AA:  BTFSS  F9E.4
018AC:  BRA    18AA
018AE:  MOVWF  FAD
018B0:  MOVFF  EF,FF6
018B4:  MOVFF  F0,FF7
018B8:  DECFSZ xEE,F
018BA:  BRA    189E
018BC:  RETURN 0
018BE:  MOVF   xF1,W
018C0:  CLRF   01
018C2:  SUBWF  xF0,W
018C4:  BC    18CC
018C6:  MOVFF  F0,00
018CA:  BRA    18E4
018CC:  CLRF   00
018CE:  MOVLW  08
018D0:  MOVWF  xF2
018D2:  RLCF   xF0,F
018D4:  RLCF   00,F
018D6:  MOVF   xF1,W
018D8:  SUBWF  00,W
018DA:  BTFSC  FD8.0
018DC:  MOVWF  00
018DE:  RLCF   01,F
018E0:  DECFSZ xF2,F
018E2:  BRA    18D2
018E4:  RETURN 0
018E6:  MOVF   01,W
018E8:  MOVFF  EE,F0
018EC:  MOVLW  64
018EE:  MOVWF  xF1
018F0:  RCALL  18BE
018F2:  MOVFF  00,EE
018F6:  MOVF   01,W
018F8:  MOVLW  30
018FA:  BNZ   190A
018FC:  BTFSS  xEF.1
018FE:  BRA    191A
01900:  BTFSC  xEF.3
01902:  BRA    191A
01904:  BTFSC  xEF.4
01906:  MOVLW  20
01908:  BRA    1910
0190A:  BCF    xEF.3
0190C:  BCF    xEF.4
0190E:  BSF    xEF.0
01910:  ADDWF  01,F
01912:  MOVF   01,W
01914:  BTFSS  F9E.4
01916:  BRA    1914
01918:  MOVWF  FAD
0191A:  MOVFF  EE,F0
0191E:  MOVLW  0A
01920:  MOVWF  xF1
01922:  RCALL  18BE
01924:  MOVFF  00,EE
01928:  MOVF   01,W
0192A:  MOVLW  30
0192C:  BNZ   193A
0192E:  BTFSC  xEF.3
01930:  BRA    1944
01932:  BTFSS  xEF.0
01934:  BRA    1944
01936:  BTFSC  xEF.4
01938:  MOVLW  20
0193A:  ADDWF  01,F
0193C:  MOVF   01,W
0193E:  BTFSS  F9E.4
01940:  BRA    193E
01942:  MOVWF  FAD
01944:  MOVLW  30
01946:  ADDWF  xEE,F
01948:  MOVF   xEE,W
0194A:  BTFSS  F9E.4
0194C:  BRA    194A
0194E:  MOVWF  FAD
01950:  RETURN 0
01952:  BTFSC  xEF.7
01954:  BRA    1976
01956:  MOVLW  0F
01958:  MOVWF  00
0195A:  SWAPF  xEE,W
0195C:  ANDWF  00,F
0195E:  MOVLW  0A
01960:  SUBWF  00,W
01962:  BC    196A
01964:  MOVLW  30
01966:  ADDWF  00,F
01968:  BRA    196E
0196A:  MOVF   xEF,W
0196C:  ADDWF  00,F
0196E:  MOVF   00,W
01970:  BTFSS  F9E.4
01972:  BRA    1970
01974:  MOVWF  FAD
01976:  MOVLW  0F
01978:  ANDWF  xEE,F
0197A:  MOVLW  0A
0197C:  SUBWF  xEE,W
0197E:  BC    1984
01980:  MOVLW  30
01982:  BRA    1988
01984:  BCF    xEF.7
01986:  MOVF   xEF,W
01988:  ADDWF  xEE,F
0198A:  MOVF   xEE,W
0198C:  BTFSS  F9E.4
0198E:  BRA    198C
01990:  MOVWF  FAD
01992:  RETURN 0
*
01AE2:  MOVLW  8E
01AE4:  MOVWF  00
01AE6:  MOVFF  F0,01
01AEA:  MOVFF  EF,02
01AEE:  CLRF   03
01AF0:  MOVF   01,F
01AF2:  BNZ   1B06
01AF4:  MOVFF  02,01
01AF8:  CLRF   02
01AFA:  MOVLW  08
01AFC:  SUBWF  00,F
01AFE:  MOVF   01,F
01B00:  BNZ   1B06
01B02:  CLRF   00
01B04:  BRA    1B16
01B06:  BCF    FD8.0
01B08:  BTFSC  01.7
01B0A:  BRA    1B14
01B0C:  RLCF   02,F
01B0E:  RLCF   01,F
01B10:  DECF   00,F
01B12:  BRA    1B06
01B14:  BCF    01.7
01B16:  RETURN 0
01B18:  MOVF   xFB,W
01B1A:  BTFSC  FD8.2
01B1C:  BRA    1C2E
01B1E:  MOVWF  00
01B20:  MOVF   xFF,W
01B22:  BTFSC  FD8.2
01B24:  BRA    1C2E
01B26:  ADDWF  00,F
01B28:  BNC   1B34
01B2A:  MOVLW  81
01B2C:  ADDWF  00,F
01B2E:  BTFSC  FD8.0
01B30:  BRA    1C2E
01B32:  BRA    1B40
01B34:  MOVLW  7F
01B36:  SUBWF  00,F
01B38:  BTFSS  FD8.0
01B3A:  BRA    1C2E
01B3C:  BTFSC  FD8.2
01B3E:  BRA    1C2E
01B40:  MOVFF  FC,103
01B44:  MOVLB  1
01B46:  MOVF   x00,W
01B48:  XORWF  x03,F
01B4A:  MOVLB  0
01B4C:  BSF    xFC.7
01B4E:  MOVLB  1
01B50:  BSF    x00.7
01B52:  MOVLB  0
01B54:  MOVF   xFE,W
01B56:  MOVLB  1
01B58:  MULWF  x02
01B5A:  MOVFF  FF4,105
01B5E:  MOVLB  0
01B60:  MOVF   xFD,W
01B62:  MOVLB  1
01B64:  MULWF  x01
01B66:  MOVFF  FF4,03
01B6A:  MOVFF  FF3,104
01B6E:  MULWF  x02
01B70:  MOVF   FF3,W
01B72:  ADDWF  x05,F
01B74:  MOVF   FF4,W
01B76:  ADDWFC x04,F
01B78:  MOVLW  00
01B7A:  ADDWFC 03,F
01B7C:  MOVLB  0
01B7E:  MOVF   xFE,W
01B80:  MOVLB  1
01B82:  MULWF  x01
01B84:  MOVF   FF3,W
01B86:  ADDWF  x05,F
01B88:  MOVF   FF4,W
01B8A:  ADDWFC x04,F
01B8C:  MOVLW  00
01B8E:  CLRF   02
01B90:  ADDWFC 03,F
01B92:  ADDWFC 02,F
01B94:  MOVLB  0
01B96:  MOVF   xFC,W
01B98:  MOVLB  1
01B9A:  MULWF  x02
01B9C:  MOVF   FF3,W
01B9E:  ADDWF  x04,F
01BA0:  MOVF   FF4,W
01BA2:  ADDWFC 03,F
01BA4:  MOVLW  00
01BA6:  ADDWFC 02,F
01BA8:  MOVLB  0
01BAA:  MOVF   xFC,W
01BAC:  MOVLB  1
01BAE:  MULWF  x01
01BB0:  MOVF   FF3,W
01BB2:  ADDWF  03,F
01BB4:  MOVF   FF4,W
01BB6:  ADDWFC 02,F
01BB8:  MOVLW  00
01BBA:  CLRF   01
01BBC:  ADDWFC 01,F
01BBE:  MOVLB  0
01BC0:  MOVF   xFE,W
01BC2:  MOVLB  1
01BC4:  MULWF  x00
01BC6:  MOVF   FF3,W
01BC8:  ADDWF  x04,F
01BCA:  MOVF   FF4,W
01BCC:  ADDWFC 03,F
01BCE:  MOVLW  00
01BD0:  ADDWFC 02,F
01BD2:  ADDWFC 01,F
01BD4:  MOVLB  0
01BD6:  MOVF   xFD,W
01BD8:  MOVLB  1
01BDA:  MULWF  x00
01BDC:  MOVF   FF3,W
01BDE:  ADDWF  03,F
01BE0:  MOVF   FF4,W
01BE2:  ADDWFC 02,F
01BE4:  MOVLW  00
01BE6:  ADDWFC 01,F
01BE8:  MOVLB  0
01BEA:  MOVF   xFC,W
01BEC:  MOVLB  1
01BEE:  MULWF  x00
01BF0:  MOVF   FF3,W
01BF2:  ADDWF  02,F
01BF4:  MOVF   FF4,W
01BF6:  ADDWFC 01,F
01BF8:  INCF   00,F
01BFA:  BTFSC  01.7
01BFC:  BRA    1C08
01BFE:  RLCF   x04,F
01C00:  RLCF   03,F
01C02:  RLCF   02,F
01C04:  RLCF   01,F
01C06:  DECF   00,F
01C08:  MOVLW  00
01C0A:  BTFSS  x04.7
01C0C:  BRA    1C22
01C0E:  INCF   03,F
01C10:  ADDWFC 02,F
01C12:  ADDWFC 01,F
01C14:  MOVF   01,W
01C16:  BNZ   1C22
01C18:  MOVF   02,W
01C1A:  BNZ   1C22
01C1C:  MOVF   03,W
01C1E:  BNZ   1C22
01C20:  INCF   00,F
01C22:  BTFSC  x03.7
01C24:  BSF    01.7
01C26:  BTFSS  x03.7
01C28:  BCF    01.7
01C2A:  BRA    1C38
01C2C:  MOVLB  0
01C2E:  CLRF   00
01C30:  CLRF   01
01C32:  CLRF   02
01C34:  CLRF   03
01C36:  MOVLB  1
01C38:  MOVLB  0
01C3A:  RETURN 0
01C3C:  MOVF   xFB,W
01C3E:  SUBLW  B6
01C40:  MOVWF  xFB
01C42:  CLRF   03
01C44:  MOVFF  FC,FF
01C48:  BSF    xFC.7
01C4A:  BCF    FD8.0
01C4C:  RRCF   xFC,F
01C4E:  RRCF   xFD,F
01C50:  RRCF   xFE,F
01C52:  RRCF   03,F
01C54:  RRCF   02,F
01C56:  RRCF   01,F
01C58:  RRCF   00,F
01C5A:  DECFSZ xFB,F
01C5C:  BRA    1C4A
01C5E:  BTFSS  xFF.7
01C60:  BRA    1C78
01C62:  COMF   00,F
01C64:  COMF   01,F
01C66:  COMF   02,F
01C68:  COMF   03,F
01C6A:  INCF   00,F
01C6C:  BTFSC  FD8.2
01C6E:  INCF   01,F
01C70:  BTFSC  FD8.2
01C72:  INCF   02,F
01C74:  BTFSC  FD8.2
01C76:  INCF   03,F
01C78:  GOTO   1D72 (RETURN)
01C7C:  BTFSC  FD8.1
01C7E:  BRA    1C88
01C80:  MOVLW  01
01C82:  MOVWF  FEA
01C84:  MOVLW  03
01C86:  MOVWF  FE9
01C88:  CLRF   00
01C8A:  CLRF   01
01C8C:  CLRF   02
01C8E:  CLRF   03
01C90:  MOVLB  1
01C92:  CLRF   x03
01C94:  CLRF   x04
01C96:  CLRF   x05
01C98:  CLRF   x06
01C9A:  MOVF   x02,W
01C9C:  IORWF  x01,W
01C9E:  IORWF  x00,W
01CA0:  MOVLB  0
01CA2:  IORWF  xFF,W
01CA4:  BZ    1D0E
01CA6:  MOVLW  20
01CA8:  MOVLB  1
01CAA:  MOVWF  x07
01CAC:  BCF    FD8.0
01CAE:  MOVLB  0
01CB0:  RLCF   xFB,F
01CB2:  RLCF   xFC,F
01CB4:  RLCF   xFD,F
01CB6:  RLCF   xFE,F
01CB8:  MOVLB  1
01CBA:  RLCF   x03,F
01CBC:  RLCF   x04,F
01CBE:  RLCF   x05,F
01CC0:  RLCF   x06,F
01CC2:  MOVF   x02,W
01CC4:  SUBWF  x06,W
01CC6:  BNZ   1CDC
01CC8:  MOVF   x01,W
01CCA:  SUBWF  x05,W
01CCC:  BNZ   1CDC
01CCE:  MOVF   x00,W
01CD0:  SUBWF  x04,W
01CD2:  BNZ   1CDC
01CD4:  MOVLB  0
01CD6:  MOVF   xFF,W
01CD8:  MOVLB  1
01CDA:  SUBWF  x03,W
01CDC:  BNC   1D00
01CDE:  MOVLB  0
01CE0:  MOVF   xFF,W
01CE2:  MOVLB  1
01CE4:  SUBWF  x03,F
01CE6:  MOVF   x00,W
01CE8:  BTFSS  FD8.0
01CEA:  INCFSZ x00,W
01CEC:  SUBWF  x04,F
01CEE:  MOVF   x01,W
01CF0:  BTFSS  FD8.0
01CF2:  INCFSZ x01,W
01CF4:  SUBWF  x05,F
01CF6:  MOVF   x02,W
01CF8:  BTFSS  FD8.0
01CFA:  INCFSZ x02,W
01CFC:  SUBWF  x06,F
01CFE:  BSF    FD8.0
01D00:  RLCF   00,F
01D02:  RLCF   01,F
01D04:  RLCF   02,F
01D06:  RLCF   03,F
01D08:  DECFSZ x07,F
01D0A:  BRA    1CAC
01D0C:  MOVLB  0
01D0E:  MOVFF  103,FEF
01D12:  MOVFF  104,FEC
01D16:  MOVFF  105,FEC
01D1A:  MOVFF  106,FEC
01D1E:  RETURN 0
01D20:  MOVF   FE9,W
01D22:  MOVWF  xF3
01D24:  MOVF   xF2,W
01D26:  MOVWF  xF5
01D28:  BZ    1D60
01D2A:  MOVFF  F1,FE
01D2E:  MOVFF  F0,FD
01D32:  MOVFF  EF,FC
01D36:  MOVFF  EE,FB
01D3A:  MOVLB  1
01D3C:  CLRF   x02
01D3E:  CLRF   x01
01D40:  MOVLW  20
01D42:  MOVWF  x00
01D44:  MOVLW  82
01D46:  MOVLB  0
01D48:  MOVWF  xFF
01D4A:  RCALL  1B18
01D4C:  MOVFF  03,F1
01D50:  MOVFF  02,F0
01D54:  MOVFF  01,EF
01D58:  MOVFF  00,EE
01D5C:  DECFSZ xF5,F
01D5E:  BRA    1D2A
01D60:  MOVFF  F1,FE
01D64:  MOVFF  F0,FD
01D68:  MOVFF  EF,FC
01D6C:  MOVFF  EE,FB
01D70:  BRA    1C3C
01D72:  MOVFF  03,F1
01D76:  MOVFF  02,F0
01D7A:  MOVFF  01,EF
01D7E:  MOVFF  00,EE
01D82:  BTFSS  xF1.7
01D84:  BRA    1DA0
01D86:  DECF   xF3,F
01D88:  BSF    xF3.5
01D8A:  COMF   xEE,F
01D8C:  COMF   xEF,F
01D8E:  COMF   xF0,F
01D90:  COMF   xF1,F
01D92:  INCF   xEE,F
01D94:  BTFSC  FD8.2
01D96:  INCF   xEF,F
01D98:  BTFSC  FD8.2
01D9A:  INCF   xF0,F
01D9C:  BTFSC  FD8.2
01D9E:  INCF   xF1,F
01DA0:  MOVLW  3B
01DA2:  MOVWF  xFA
01DA4:  MOVLW  9A
01DA6:  MOVWF  xF9
01DA8:  MOVLW  CA
01DAA:  MOVWF  xF8
01DAC:  CLRF   xF7
01DAE:  MOVLW  0A
01DB0:  MOVWF  xF5
01DB2:  MOVF   xF2,W
01DB4:  BTFSC  FD8.2
01DB6:  INCF   xF3,F
01DB8:  BSF    FD8.1
01DBA:  CLRF   FEA
01DBC:  MOVLW  EE
01DBE:  MOVWF  FE9
01DC0:  MOVFF  F1,FE
01DC4:  MOVFF  F0,FD
01DC8:  MOVFF  EF,FC
01DCC:  MOVFF  EE,FB
01DD0:  MOVFF  FA,102
01DD4:  MOVFF  F9,101
01DD8:  MOVFF  F8,100
01DDC:  MOVFF  F7,FF
01DE0:  RCALL  1C7C
01DE2:  MOVF   01,W
01DE4:  MOVF   00,F
01DE6:  BNZ   1E06
01DE8:  INCF   xF2,W
01DEA:  SUBWF  xF5,W
01DEC:  BZ    1E06
01DEE:  MOVF   xF3,W
01DF0:  BZ    1E0A
01DF2:  ANDLW  0F
01DF4:  SUBWF  xF5,W
01DF6:  BZ    1DFA
01DF8:  BC    1E70
01DFA:  BTFSC  xF3.7
01DFC:  BRA    1E70
01DFE:  BTFSC  xF3.6
01E00:  BRA    1E0A
01E02:  MOVLW  20
01E04:  BRA    1E66
01E06:  MOVLW  20
01E08:  ANDWF  xF3,F
01E0A:  BTFSS  xF3.5
01E0C:  BRA    1E28
01E0E:  BCF    xF3.5
01E10:  MOVF   xF2,W
01E12:  BTFSS  FD8.2
01E14:  DECF   xF3,F
01E16:  MOVF   00,W
01E18:  MOVWF  xF3
01E1A:  MOVLW  2D
01E1C:  BTFSS  F9E.4
01E1E:  BRA    1E1C
01E20:  MOVWF  FAD
01E22:  MOVF   xF3,W
01E24:  MOVWF  00
01E26:  CLRF   xF3
01E28:  MOVF   xF2,W
01E2A:  SUBWF  xF5,W
01E2C:  BNZ   1E44
01E2E:  MOVF   00,W
01E30:  MOVWF  xF3
01E32:  MOVLW  2E
01E34:  BTFSS  F9E.4
01E36:  BRA    1E34
01E38:  MOVWF  FAD
01E3A:  MOVF   xF3,W
01E3C:  MOVWF  00
01E3E:  MOVLW  20
01E40:  ANDWF  xF3,F
01E42:  MOVLW  00
01E44:  MOVLW  30
01E46:  BTFSS  xF3.5
01E48:  BRA    1E66
01E4A:  BCF    xF3.5
01E4C:  MOVF   xF2,W
01E4E:  BTFSS  FD8.2
01E50:  DECF   xF3,F
01E52:  MOVF   00,W
01E54:  MOVWF  xF3
01E56:  MOVLW  2D
01E58:  BTFSS  F9E.4
01E5A:  BRA    1E58
01E5C:  MOVWF  FAD
01E5E:  MOVF   xF3,W
01E60:  MOVWF  00
01E62:  CLRF   xF3
01E64:  MOVLW  30
01E66:  ADDWF  00,F
01E68:  MOVF   00,W
01E6A:  BTFSS  F9E.4
01E6C:  BRA    1E6A
01E6E:  MOVWF  FAD
01E70:  BCF    FD8.1
01E72:  MOVFF  FA,FE
01E76:  MOVFF  F9,FD
01E7A:  MOVFF  F8,FC
01E7E:  MOVFF  F7,FB
01E82:  MOVLB  1
01E84:  CLRF   x02
01E86:  CLRF   x01
01E88:  CLRF   x00
01E8A:  MOVLW  0A
01E8C:  MOVLB  0
01E8E:  MOVWF  xFF
01E90:  RCALL  1C7C
01E92:  MOVFF  03,FA
01E96:  MOVFF  02,F9
01E9A:  MOVFF  01,F8
01E9E:  MOVFF  00,F7
01EA2:  DECFSZ xF5,F
01EA4:  BRA    1DB8
01EA6:  GOTO   2046 (RETURN)
*
020A8:  MOVFF  FEA,E9
020AC:  MOVFF  FE9,E8
020B0:  SWAPF  xE2,W
020B2:  IORLW  F0
020B4:  MOVWF  xE4
020B6:  ADDWF  xE4,F
020B8:  ADDLW  E2
020BA:  MOVWF  xE5
020BC:  ADDLW  32
020BE:  MOVWF  xE7
020C0:  MOVF   xE2,W
020C2:  ANDLW  0F
020C4:  ADDWF  xE5,F
020C6:  ADDWF  xE5,F
020C8:  ADDWF  xE7,F
020CA:  ADDLW  E9
020CC:  MOVWF  xE6
020CE:  ADDWF  xE6,F
020D0:  ADDWF  xE6,F
020D2:  SWAPF  xE1,W
020D4:  ANDLW  0F
020D6:  ADDWF  xE6,F
020D8:  ADDWF  xE7,F
020DA:  RLCF   xE6,F
020DC:  RLCF   xE7,F
020DE:  COMF   xE7,F
020E0:  RLCF   xE7,F
020E2:  MOVF   xE1,W
020E4:  ANDLW  0F
020E6:  ADDWF  xE7,F
020E8:  RLCF   xE4,F
020EA:  MOVLW  07
020EC:  MOVWF  xE3
020EE:  MOVLW  0A
020F0:  DECF   xE6,F
020F2:  ADDWF  xE7,F
020F4:  BNC   20F0
020F6:  DECF   xE5,F
020F8:  ADDWF  xE6,F
020FA:  BNC   20F6
020FC:  DECF   xE4,F
020FE:  ADDWF  xE5,F
02100:  BNC   20FC
02102:  DECF   xE3,F
02104:  ADDWF  xE4,F
02106:  BNC   2102
02108:  CLRF   FEA
0210A:  MOVLW  E3
0210C:  MOVWF  FE9
0210E:  MOVLW  07
02110:  ANDWF  xE8,W
02112:  BCF    xE8.6
02114:  ADDWF  FE9,F
02116:  MOVLW  E7
02118:  SUBWF  FE9,W
0211A:  BTFSC  FD8.2
0211C:  BSF    xE8.6
0211E:  MOVF   FEF,W
02120:  MOVWF  00
02122:  BNZ   2134
02124:  BTFSC  xE8.6
02126:  BRA    2134
02128:  BTFSC  xE8.4
0212A:  BRA    2144
0212C:  BTFSC  xE8.3
0212E:  BRA    2134
02130:  MOVLW  20
02132:  BRA    213A
02134:  BSF    xE8.3
02136:  BCF    xE8.4
02138:  MOVLW  30
0213A:  ADDWF  00,F
0213C:  MOVF   00,W
0213E:  BTFSS  F9E.4
02140:  BRA    213E
02142:  MOVWF  FAD
02144:  MOVF   FEE,W
02146:  BTFSS  xE8.6
02148:  BRA    2116
0214A:  GOTO   21AA (RETURN)
....................  
.................... #list 
....................  
.................... #device ADC=10 
....................  
.................... #FUSES MCLR 
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... //#FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
....................  
.................... #use delay(internal=16MHz) 
*
00E48:  CLRF   FEA
00E4A:  MOVLW  EE
00E4C:  MOVWF  FE9
00E4E:  MOVF   FEF,W
00E50:  BZ    0E6E
00E52:  MOVLW  05
00E54:  MOVWF  01
00E56:  CLRF   00
00E58:  DECFSZ 00,F
00E5A:  BRA    0E58
00E5C:  DECFSZ 01,F
00E5E:  BRA    0E56
00E60:  MOVLW  2E
00E62:  MOVWF  00
00E64:  DECFSZ 00,F
00E66:  BRA    0E64
00E68:  BRA    0E6A
00E6A:  DECFSZ FEF,F
00E6C:  BRA    0E52
00E6E:  RETURN 0
*
01664:  MOVLW  04
01666:  SUBWF  xF6,F
01668:  BNC   167C
0166A:  CLRF   FEA
0166C:  MOVLW  F6
0166E:  MOVWF  FE9
01670:  MOVF   FEF,W
01672:  BZ    167C
01674:  BRA    1678
01676:  NOP   
01678:  DECFSZ FEF,F
0167A:  BRA    1676
0167C:  RETURN 0
....................  
.................... #use rs232 (baud=9600, UART1, stream=PC, errors) 
*
0101E:  BTFSS  F9E.5
01020:  BRA    101E
01022:  MOVFF  FAB,17
01026:  MOVFF  FAE,01
0102A:  BTFSS  17.1
0102C:  BRA    1032
0102E:  BCF    FAB.4
01030:  BSF    FAB.4
01032:  GOTO   26B0 (RETURN)
....................  
.................... #define PC_MSG(msg)        fprintf(PC, msg) 
.................... #define PC_DATA(msg,data)  fprintf(PC, msg, data) 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
012A0:  MOVFF  DD,FE9
012A4:  MOVFF  DE,FEA
012A8:  MOVFF  FEF,E1
012AC:  MOVFF  E0,03
012B0:  MOVFF  DF,FE9
012B4:  MOVFF  E0,FEA
012B8:  MOVF   FEF,W
012BA:  SUBWF  xE1,W
012BC:  BNZ   12E8
....................       if (*s1 == '\0') 
012BE:  MOVFF  DE,03
012C2:  MOVFF  DD,FE9
012C6:  MOVFF  03,FEA
012CA:  MOVF   FEF,F
012CC:  BNZ   12D4
....................          return(0); 
012CE:  MOVLW  00
012D0:  MOVWF  01
012D2:  BRA    1312
012D4:  MOVFF  DE,03
012D8:  MOVF   xDD,W
012DA:  INCF   xDD,F
012DC:  BTFSC  FD8.2
012DE:  INCF   xDE,F
012E0:  INCF   xDF,F
012E2:  BTFSC  FD8.2
012E4:  INCF   xE0,F
012E6:  BRA    12A0
....................    return((*s1 < *s2) ? -1: 1); 
012E8:  MOVFF  DE,03
012EC:  MOVFF  DD,FE9
012F0:  MOVFF  DE,FEA
012F4:  MOVFF  FEF,E1
012F8:  MOVFF  E0,03
012FC:  MOVFF  DF,FE9
01300:  MOVFF  E0,FEA
01304:  MOVF   FEF,W
01306:  SUBWF  xE1,W
01308:  BC    130E
0130A:  MOVLW  FF
0130C:  BRA    1310
0130E:  MOVLW  01
01310:  MOVWF  01
01312:  RETURN 0
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
014CA:  CLRF   xE2
....................    sign = 0; 
014CC:  CLRF   xE0
....................    base = 10; 
014CE:  MOVLW  0A
014D0:  MOVWF  xE1
....................    result = 0; 
014D2:  CLRF   xDF
....................  
....................    if (!s) 
014D4:  MOVF   xDD,W
014D6:  IORWF  xDE,W
014D8:  BNZ   14E0
....................       return 0; 
014DA:  MOVLW  00
014DC:  MOVWF  01
014DE:  BRA    1662
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
014E0:  MOVF   xE2,W
014E2:  INCF   xE2,F
014E4:  CLRF   03
014E6:  ADDWF  xDD,W
014E8:  MOVWF  FE9
014EA:  MOVF   xDE,W
014EC:  ADDWFC 03,W
014EE:  MOVWF  FEA
014F0:  MOVFF  FEF,E3
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
014F4:  MOVF   xE3,W
014F6:  SUBLW  2D
014F8:  BNZ   1514
....................    { 
....................       sign = 1;         // Set the sign to negative 
014FA:  MOVLW  01
014FC:  MOVWF  xE0
....................       c = s[index++]; 
014FE:  MOVF   xE2,W
01500:  INCF   xE2,F
01502:  CLRF   03
01504:  ADDWF  xDD,W
01506:  MOVWF  FE9
01508:  MOVF   xDE,W
0150A:  ADDWFC 03,W
0150C:  MOVWF  FEA
0150E:  MOVFF  FEF,E3
....................    } 
01512:  BRA    152E
....................    else if (c == '+') 
01514:  MOVF   xE3,W
01516:  SUBLW  2B
01518:  BNZ   152E
....................    { 
....................       c = s[index++]; 
0151A:  MOVF   xE2,W
0151C:  INCF   xE2,F
0151E:  CLRF   03
01520:  ADDWF  xDD,W
01522:  MOVWF  FE9
01524:  MOVF   xDE,W
01526:  ADDWFC 03,W
01528:  MOVWF  FEA
0152A:  MOVFF  FEF,E3
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0152E:  MOVF   xE3,W
01530:  SUBLW  2F
01532:  BTFSC  FD8.0
01534:  BRA    1652
01536:  MOVF   xE3,W
01538:  SUBLW  39
0153A:  BTFSS  FD8.0
0153C:  BRA    1652
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0153E:  MOVF   xE3,W
01540:  SUBLW  30
01542:  BNZ   1586
01544:  CLRF   03
01546:  MOVF   xE2,W
01548:  ADDWF  xDD,W
0154A:  MOVWF  FE9
0154C:  MOVF   xDE,W
0154E:  ADDWFC 03,W
01550:  MOVWF  FEA
01552:  MOVF   FEF,W
01554:  SUBLW  78
01556:  BZ    156C
01558:  CLRF   03
0155A:  MOVF   xE2,W
0155C:  ADDWF  xDD,W
0155E:  MOVWF  FE9
01560:  MOVF   xDE,W
01562:  ADDWFC 03,W
01564:  MOVWF  FEA
01566:  MOVF   FEF,W
01568:  SUBLW  58
0156A:  BNZ   1586
....................       { 
....................          base = 16; 
0156C:  MOVLW  10
0156E:  MOVWF  xE1
....................          index++; 
01570:  INCF   xE2,F
....................          c = s[index++]; 
01572:  MOVF   xE2,W
01574:  INCF   xE2,F
01576:  CLRF   03
01578:  ADDWF  xDD,W
0157A:  MOVWF  FE9
0157C:  MOVF   xDE,W
0157E:  ADDWFC 03,W
01580:  MOVWF  FEA
01582:  MOVFF  FEF,E3
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
01586:  MOVF   xE1,W
01588:  SUBLW  0A
0158A:  BNZ   15C2
....................       { 
....................          while (c >= '0' && c <= '9') 
0158C:  MOVF   xE3,W
0158E:  SUBLW  2F
01590:  BC    15C0
01592:  MOVF   xE3,W
01594:  SUBLW  39
01596:  BNC   15C0
....................          { 
....................             result = 10*result + (c - '0'); 
01598:  MOVLW  0A
0159A:  MOVWF  xE4
0159C:  MOVFF  DF,E5
015A0:  BRA    147E
015A2:  MOVLW  30
015A4:  SUBWF  xE3,W
015A6:  ADDWF  01,W
015A8:  MOVWF  xDF
....................             c = s[index++]; 
015AA:  MOVF   xE2,W
015AC:  INCF   xE2,F
015AE:  CLRF   03
015B0:  ADDWF  xDD,W
015B2:  MOVWF  FE9
015B4:  MOVF   xDE,W
015B6:  ADDWFC 03,W
015B8:  MOVWF  FEA
015BA:  MOVFF  FEF,E3
015BE:  BRA    158C
....................          } 
....................       } 
015C0:  BRA    1652
....................       else if (base == 16)    // The number is a hexa number 
015C2:  MOVF   xE1,W
015C4:  SUBLW  10
015C6:  BNZ   1652
....................       { 
....................          c = toupper(c); 
015C8:  MOVF   xE3,W
015CA:  SUBLW  60
015CC:  BC    15DA
015CE:  MOVF   xE3,W
015D0:  SUBLW  7A
015D2:  BNC   15DA
015D4:  MOVF   xE3,W
015D6:  ANDLW  DF
015D8:  BRA    15DC
015DA:  MOVF   xE3,W
015DC:  MOVWF  xE3
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
015DE:  MOVF   xE3,W
015E0:  SUBLW  2F
015E2:  BC    15EA
015E4:  MOVF   xE3,W
015E6:  SUBLW  39
015E8:  BC    15F6
015EA:  MOVF   xE3,W
015EC:  SUBLW  40
015EE:  BC    1652
015F0:  MOVF   xE3,W
015F2:  SUBLW  46
015F4:  BNC   1652
....................          { 
....................             if (c >= '0' && c <= '9') 
015F6:  MOVF   xE3,W
015F8:  SUBLW  2F
015FA:  BC    1614
015FC:  MOVF   xE3,W
015FE:  SUBLW  39
01600:  BNC   1614
....................                result = (result << 4) + (c - '0'); 
01602:  SWAPF  xDF,W
01604:  MOVWF  xE4
01606:  MOVLW  F0
01608:  ANDWF  xE4,F
0160A:  MOVLW  30
0160C:  SUBWF  xE3,W
0160E:  ADDWF  xE4,W
01610:  MOVWF  xDF
01612:  BRA    1626
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
01614:  SWAPF  xDF,W
01616:  MOVWF  xE4
01618:  MOVLW  F0
0161A:  ANDWF  xE4,F
0161C:  MOVLW  41
0161E:  SUBWF  xE3,W
01620:  ADDLW  0A
01622:  ADDWF  xE4,W
01624:  MOVWF  xDF
....................  
....................             c = s[index++]; 
01626:  MOVF   xE2,W
01628:  INCF   xE2,F
0162A:  CLRF   03
0162C:  ADDWF  xDD,W
0162E:  MOVWF  FE9
01630:  MOVF   xDE,W
01632:  ADDWFC 03,W
01634:  MOVWF  FEA
01636:  MOVFF  FEF,E3
....................             c = toupper(c); 
0163A:  MOVF   xE3,W
0163C:  SUBLW  60
0163E:  BC    164C
01640:  MOVF   xE3,W
01642:  SUBLW  7A
01644:  BNC   164C
01646:  MOVF   xE3,W
01648:  ANDLW  DF
0164A:  BRA    164E
0164C:  MOVF   xE3,W
0164E:  MOVWF  xE3
01650:  BRA    15DE
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
01652:  DECFSZ xE0,W
01654:  BRA    165E
01656:  MOVF   xE1,W
01658:  SUBLW  0A
0165A:  BNZ   165E
....................        result = -result; 
0165C:  NEGF   xDF
....................  
....................    return(result); 
0165E:  MOVFF  DF,01
01662:  RETURN 0
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <variaveis.c> 
.................... #define RS485_USE_EXT_INT                 TRUE 
....................  
.................... #define MODBUS_TYPE                       MODBUS_TYPE_MASTER 
.................... #define MODBUS_SERIAL_TYPE                MODBUS_RTU     //use MODBUS_ASCII for ASCII mode 
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE      64 
.................... #define MODBUS_SERIAL_BAUD                9600 
....................  
.................... #define MODBUS_SERIAL_INT_SOURCE          MODBUS_INT_EXT 
....................  
.................... #define MODBUS_SERIAL_RX_PIN              PIN_B0   // Data receive pin 
.................... #define MODBUS_SERIAL_TX_PIN              PIN_B3   // Data transmit pin 
....................  
.................... #define MODBUS_SERIAL_ENABLE_PIN          PIN_B4   // Controls DE pin for RS485 
.................... #define MODBUS_SERIAL_RX_ENABLE           PIN_B5   // Controls RE pin for RS485 
....................  
....................  
.................... #include <modbus_local.c> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                     modbus.c                                     //// 
.................... ////                                                                                  //// 
.................... ////           MODBUS protocol driver for serial and TCP/IP communications.           //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... ////  How to Use:                                                                     //// 
.................... ////                                                                                  //// 
.................... ////  Include just this file, modbus.c, in your main program. Before including this   //// 
.................... ////  file define the constants below for your needs.                                 //// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////  MODBUS_PROTOCOL               MODBUS_PROTOCOL_SERIAL or MODBUS_PROTOCOL_TCPIP   //// 
.................... ////                                                                                  //// 
.................... //// SERIAL DEFINES:                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2,   //// 
.................... ////                                   MODBUS_INT_RDA3,MODBUS_INT_RDA4)               //// 
.................... ////  MODBUS_SERIAL_TYPE            MODBUS_RTU or MODBUS_ASCII                        //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... //// TCP/IP DEFINES:                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBYS_TYPE_CLIENT or MODBUS_TYPE_SERVER          //// 
.................... ////  MODBUS_SERVER_LISTEN_PORT     Port server/client listens/sends messages to      //// 
.................... ////                                   (default 502)                                  //// 
.................... ////  MODBUS_LISTEN_SOCKETS         Number of sockets server listens to (default 1)   //// 
.................... ////  MODBUS_BUFFER_SIZE            Size of receive and transmit buffers (default 64) //// 
.................... ////  MODBUS_SERVER_TIMEOUT         Time is seconds client will wait for response     //// 
.................... ////                                   from server before setting TIMEOUT exception   //// 
.................... ////                                   (default 5)                                    //// 
.................... ////  MODBUS_SERVER_ADDR_0          TCP/IP address client connects to MSB             //// 
.................... ////  MODBUS_SERVER_ADDR_1          TCP/IP address client connects to                 //// 
.................... ////  MODBUS_SERVER_ADDR_2          TCP/IP address client connects to                 //// 
.................... ////  MODBUS_SERVER_ADDR_3          TCP/IP address client connects to LSB             //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  May 8, 2009       Made PCD Compatible                                           //// 
.................... ////  August 21, 2009   Added Modbus ASCII protocol                                   //// 
.................... ////  May 20, 2010      Changed variables to unsigned for PCD and if #device ANSI is  //// 
.................... ////                    used for PCM or PCH. Fixed bug when multiple UARTS are used   //// 
.................... ////                    on PIC.                                                       //// 
.................... ////  July 20, 2011     Seperated modbus.c into 7 files, including this one. The code //// 
.................... ////                    was seperated into header and c files for the Physical and    //// 
.................... ////                    Application layers, and RTU code and ASCII code.              //// 
.................... ////  November 1, 2011  Added Modbus TCP/IP protocol.                                 //// 
.................... ////  Janurary 9, 2013  Added support for Even and Odd Parity for RTU and ASCII       //// 
.................... ////                    modes.                                                        //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #include <modbus_local.h> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                     modbus.h                                     //// 
.................... ////                                                                                  //// 
.................... ////           MODBUS protocol driver for serial and TCP/IP communications.           //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////  MODBUS_PROTOCOL               MODBUS_PROTOCOL_SERIAL or MODBUS_PROTOCOL_TCPIP   //// 
.................... ////                                                                                  //// 
.................... //// SERIAL DEFINES:                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2,   //// 
.................... ////                                   MODBUS_INT_RDA3,MODBUS_INT_RDA4)               //// 
.................... ////  MODBUS_SERIAL_TYPE            MODBUS_RTU or MODBUS_ASCII                        //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... //// TCP/IP DEFINES:                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBYS_TYPE_CLIENT or MODBUS_TYPE_SERVER          //// 
.................... ////  MODBUS_SERVER_LISTEN_PORT     Port server/client listens/sends messages to      //// 
.................... ////                                   (default 502)                                  //// 
.................... ////  MODBUS_LISTEN_SOCKETS         Number of sockets server listens to (default 1)   //// 
.................... ////  MODBUS_BUFFER_SIZE            Size of receive and transmit buffers (default 64) //// 
.................... ////  MODBUS_SERVER_TIMEOUT         Time is seconds client will wait for response     //// 
.................... ////                                   from server before setting TIMEOUT exception   //// 
.................... ////                                   (default 5)                                    //// 
.................... ////  MODBUS_SERVER_ADDR_0          TCP/IP address client connects to MSB             //// 
.................... ////  MODBUS_SERVER_ADDR_1          TCP/IP address client connects to                 //// 
.................... ////  MODBUS_SERVER_ADDR_2          TCP/IP address client connects to                 //// 
.................... ////  MODBUS_SERVER_ADDR_3          TCP/IP address client connects to LSB             //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  May 8, 2009       Made PCD Compatible                                           //// 
.................... ////  August 21, 2009   Added Modbus ASCII protocol                                   //// 
.................... ////  May 20, 2010      Changed variables to unsigned for PCD and if #device ANSI is  //// 
.................... ////                    used for PCM or PCH. Fixed bug when multiple UARTS are used   //// 
.................... ////                    on PIC.                                                       //// 
.................... ////  July 20, 2011     Seperated modbus.c into 7 files, including this one. The code //// 
.................... ////                    was seperated into header and c files for the Physical and    //// 
.................... ////                    Application layers, and RTU code and ASCII code.              //// 
.................... ////  November 1, 2011  Added Modbus TCP/IP protocol.                                 //// 
.................... ////  Janurary 9, 2013  Added support for Even and Odd Parity for RTU and ASCII       //// 
.................... ////                    modes.                                                        //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2010 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MODBUS_H 
.................... #define MODBUS_H 
....................  
.................... /*Some defines so we can use identifiers to set things up*/ 
.................... #define MODBUS_PROTOCOL_SERIAL 0 
.................... #define MODBUS_PROTOCOL_TCPIP  100 
.................... #define MODBUS_TYPE_MASTER 99999 
.................... #define MODBUS_TYPE_SLAVE  88888 
.................... #define MODBUS_TYPE_CLIENT 20 
.................... #define MODBUS_TYPE_SERVER 21 
.................... #define MODBUS_INT_RDA     77777 
.................... #define MODBUS_INT_RDA2    66666 
.................... #define MODBUS_INT_RDA3    44444 
.................... #define MODBUS_INT_RDA4    33333 
.................... #define MODBUS_INT_EXT     55555 
.................... #define MODBUS_RTU         1 
.................... #define MODBUS_ASCII       2 
.................... #define MODBUS_TIMER_NOISR 13 
.................... #define MODBUS_TIMER_ISR   12 
.................... #define MODBUS_TIMER_T1    14 
.................... #define MODBUS_TIMER_T2    15 
....................  
.................... #ifndef MODBUS_PROTOCOL 
....................  #define MODBUS_PROTOCOL MODBUS_PROTOCOL_SERIAL 
.................... #endif 
....................  
.................... #if (MODBUS_PROTOCOL == MODBUS_PROTOCOL_SERIAL) 
....................  #ifndef MODBUS_TYPE 
....................   #define MODBUS_TYPE MODBUS_TYPE_MASTER 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERIAL_TYPE 
....................   #define MODBUS_SERIAL_TYPE MODBUS_RTU 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERIAL_INT_SOURCE 
....................   #define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_RDA   // Select between external interrupt 
....................  #endif                                             // or asynchronous serial interrupt 
....................  
....................  #ifndef MODBUS_SERIAL_BAUD 
....................   #define MODBUS_SERIAL_BAUD 9600 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERIAL_RX_PIN 
....................   #define MODBUS_SERIAL_RX_PIN       PIN_C7   // Data receive pin 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERIAL_TX_PIN 
....................   #define MODBUS_SERIAL_TX_PIN       PIN_C6   // Data transmit pin 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERIAL_ENABLE_PIN 
....................   #define MODBUS_SERIAL_ENABLE_PIN   0   // Controls DE pin.  RX low, TX high. 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERIAL_RX_ENABLE 
....................   #define MODBUS_SERIAL_RX_ENABLE    0   // Controls RE pin.  Should keep low. 
....................  #endif 
....................  
....................  #ifndef MODBUS_PARITY 
....................   #define MODBUS_PARITY "EVEN" 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERIAL_TIMEOUT 
....................   #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................    #define MODBUS_SERIAL_TIMEOUT    1000000 
....................   #else 
....................    #define MODBUS_SERIAL_TIMEOUT      10000     //in us 
....................   #endif 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERIAL_RX_BUFFER_SIZE 
....................   #define MODBUS_SERIAL_RX_BUFFER_SIZE  64      //size of send/rcv buffer 
....................  #endif 
....................  
....................  #ifndef MODBUS_TIMER_UPDATE 
....................   #define MODBUS_TIMER_UPDATE MODBUS_TIMER_ISR 
....................  #endif 
....................  
....................  #ifndef MODBUS_TIMER_USED 
....................   #define MODBUS_TIMER_USED MODBUS_TIMER_T1 
....................  #endif 
....................  
.................... #else ///////////////////////// MODBUS TCP/IP PROTOCOL ///////////////////////// 
....................  #ifndef MODBUS_TYPE 
....................   #define MODBUS_TYPE   MODBUS_TYPE_CLIENT 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERVER_LISTEN_PORT 
....................   #define MODBUS_SERVER_LISTEN_PORT    502   //this is the default listen port for MODBUS TCP/IP protocol 
....................  #endif 
....................  
....................  #if (MODBUS_TYPE == MODBUS_TYPE_SERVER) 
....................   #ifndef MODBUS_LISTEN_SOCKETS 
....................    #define MODBUS_LISTEN_SOCKETS     1 
....................   #endif 
....................  #endif 
....................  
....................  #ifndef MODBUS_BUFFER_SIZE 
....................   #define MODBUS_BUFFER_SIZE   64 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERVER_TIMEOUT 
....................   #define MODBUS_SERVER_TIMEOUT  5  //time in seconds that client will wait for server response before timeout 
....................  #endif 
....................  
....................  #if (MODBUS_TYPE == MODBUS_TYPE_CLIENT) 
....................   #ifndef MODBUS_SERVER_ADDR_0 
....................    #define MODBUS_SERVER_ADDR_0  192 
....................    #define MODBUS_SERVER_ADDR_1  168 
....................    #define MODBUS_SERVER_ADDR_2  100 
....................    #define MODBUS_SERVER_ADDR_3  140 
....................   #endif 
....................  #endif 
....................  
....................  #ifndef debug_printf 
....................   #define debug_printf(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u) 
....................  #endif 
....................  
.................... #endif 
....................  
.................... #if (MODBUS_PROTOCOL == MODBUS_PROTOCOL_TCPIP) 
....................  #include <modbus_phy_layer_tcpip.h> 
.................... #else 
....................  #include <modbus_phy_layer_local.h> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                modbus_phy_layer.h                                //// 
.................... ////                                                                                  //// 
.................... ////      Physical layer of the MODBUS protocol driver for serial communications.     //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  July 20, 2011       Seperated Physical Layer functions definitions into this    //// 
.................... ////                      file from modbus.c                                          //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MODBUS_PHY_LAYER_H 
.................... #define MODBUS_PHY_LAYER_H 
....................  
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER) 
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\ 
.................... {\ 
....................    modbus_timeout_enabled = 0;\ 
....................    if(address)\ 
....................    {\ 
....................       while(!modbus_kbhit() && --modbus_serial_wait)\ 
....................          delay_us(1);\ 
....................       if(!modbus_serial_wait)\ 
....................          modbus_rx.error=TIMEOUT;\ 
....................    }\ 
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\ 
.................... } 
.................... #else 
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\ 
.................... {\ 
....................    if(address)\ 
....................    {\ 
....................       while(!modbus_kbhit() && --modbus_serial_wait)\ 
....................          delay_us(1);\ 
....................       if(!modbus_serial_wait)\ 
....................          modbus_rx.error=TIMEOUT;\ 
....................    }\ 
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\ 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT) 
....................    #if defined(__PCD__) 
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA) 
....................          #word TXSTA=getenv("SFR:U1STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2) 
....................          #word TXSTA=getenv("SFR:U2STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3) 
....................          #word TXSTA=getenv("SFR:U3STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4) 
....................          #word TXSTA=getenv("SFR:U4STA") 
....................          #bit TRMT=TXSTA.8 
....................       #endif 
....................    #else 
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA) 
....................          #if getenv("sfr_valid:TXSTA") 
....................             #byte TXSTA=getenv("sfr:TXSTA") 
....................          #elif getenv("sf_valid:TXSTA1") 
....................             #byte TXSTA=getenv("sfr:TXSTA1") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX1STA") 
....................          #endif 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2) 
....................          #if getenv("sfr_valid:TXSTA2") 
....................             #byte TXSTA=getenv("sfr:TXSTA2") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX2STA") 
....................          #endif 
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3) 
....................          #if getenv("sfr_valid:TXSTA3") 
....................             #byte TXSTA=getenv("sfr:TXSTA3") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX3STA") 
....................          #endif 
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4) 
....................          #if getenv("sfr_valid:TXSTA4") 
....................             #byte TXSTA=getenv("sfr:TXSTA4") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX4STA") 
....................          #endif 
....................       #endif 
....................       #bit TRMT=TXSTA.1 
....................    #endif 
.................... #endif 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT) 
.................... #define WAIT_FOR_HW_BUFFER()\ 
.................... {\ 
....................    while(!TRMT);\ 
.................... } 
.................... #endif 
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions. 
.................... The first exception is the only one that is not part of the protocol 
.................... specification.  The TIMEOUT exception is returned when no slave 
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2, 
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6, 
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See 
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see 
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    unsigned int8 address; 
....................    unsigned int8 len;                       //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    unsigned int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////  For Custom Commands                                                             //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_putc(unsigned int8 c)                                             //// 
.................... ////    - Sends a character onto the serial line                                      //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(unsigned int8 to, unsigned int8 func); 
....................  
.................... // Purpose:    Sends a message stop 
.................... // Inputs:     none 
.................... // Outputs:    None 
.................... void modbus_serial_send_stop(); 
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(unsigned int8 c); 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////  For Init                                                                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void); 
....................  
.................... #endif //MODBUS_PHY_LAYER_H 
....................  
.................... #endif 
....................  
.................... #if (MODBUS_PROTOCOL == MODBUS_PROTOCOL_TCPIP) 
....................  #include <modbus_app_layer_tcpip.h> 
.................... #else 
....................  #include <modbus_app_layer_local.h> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                modbus_app_layer.h                                //// 
.................... ////                                                                                  //// 
.................... ////    Application layer of the MODBUS protocol driver for serial communications.    //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  July 20, 2011       Seperated App Layer functions into this file from modbus.c  //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MODBUS_APP_LAYER_H 
.................... #define MODBUS_APP_LAYER_H 
....................  
.................... #include <modbus_phy_layer_local.h> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                modbus_phy_layer.h                                //// 
.................... ////                                                                                  //// 
.................... ////      Physical layer of the MODBUS protocol driver for serial communications.     //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  July 20, 2011       Seperated Physical Layer functions definitions into this    //// 
.................... ////                      file from modbus.c                                          //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MODBUS_PHY_LAYER_H 
.................... #define MODBUS_PHY_LAYER_H 
....................  
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER) 
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\ 
.................... {\ 
....................    modbus_timeout_enabled = 0;\ 
....................    if(address)\ 
....................    {\ 
....................       while(!modbus_kbhit() && --modbus_serial_wait)\ 
....................          delay_us(1);\ 
....................       if(!modbus_serial_wait)\ 
....................          modbus_rx.error=TIMEOUT;\ 
....................    }\ 
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\ 
.................... } 
.................... #else 
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\ 
.................... {\ 
....................    if(address)\ 
....................    {\ 
....................       while(!modbus_kbhit() && --modbus_serial_wait)\ 
....................          delay_us(1);\ 
....................       if(!modbus_serial_wait)\ 
....................          modbus_rx.error=TIMEOUT;\ 
....................    }\ 
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\ 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT) 
....................    #if defined(__PCD__) 
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA) 
....................          #word TXSTA=getenv("SFR:U1STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2) 
....................          #word TXSTA=getenv("SFR:U2STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3) 
....................          #word TXSTA=getenv("SFR:U3STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4) 
....................          #word TXSTA=getenv("SFR:U4STA") 
....................          #bit TRMT=TXSTA.8 
....................       #endif 
....................    #else 
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA) 
....................          #if getenv("sfr_valid:TXSTA") 
....................             #byte TXSTA=getenv("sfr:TXSTA") 
....................          #elif getenv("sf_valid:TXSTA1") 
....................             #byte TXSTA=getenv("sfr:TXSTA1") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX1STA") 
....................          #endif 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2) 
....................          #if getenv("sfr_valid:TXSTA2") 
....................             #byte TXSTA=getenv("sfr:TXSTA2") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX2STA") 
....................          #endif 
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3) 
....................          #if getenv("sfr_valid:TXSTA3") 
....................             #byte TXSTA=getenv("sfr:TXSTA3") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX3STA") 
....................          #endif 
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4) 
....................          #if getenv("sfr_valid:TXSTA4") 
....................             #byte TXSTA=getenv("sfr:TXSTA4") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX4STA") 
....................          #endif 
....................       #endif 
....................       #bit TRMT=TXSTA.1 
....................    #endif 
.................... #endif 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT) 
.................... #define WAIT_FOR_HW_BUFFER()\ 
.................... {\ 
....................    while(!TRMT);\ 
.................... } 
.................... #endif 
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions. 
.................... The first exception is the only one that is not part of the protocol 
.................... specification.  The TIMEOUT exception is returned when no slave 
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2, 
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6, 
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See 
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see 
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    unsigned int8 address; 
....................    unsigned int8 len;                       //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    unsigned int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////  For Custom Commands                                                             //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_putc(unsigned int8 c)                                             //// 
.................... ////    - Sends a character onto the serial line                                      //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(unsigned int8 to, unsigned int8 func); 
....................  
.................... // Purpose:    Sends a message stop 
.................... // Inputs:     none 
.................... // Outputs:    None 
.................... void modbus_serial_send_stop(); 
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(unsigned int8 c); 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////  For Init                                                                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void); 
....................  
.................... #endif //MODBUS_PHY_LAYER_H 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Shared API                                                                       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init(); 
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit(); 
....................  
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER) 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Master Api                                                                       //// 
.................... ////                                                                                  //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request.  These 
.................... functions take in one of these structs. 
.................... Please refer to the MODBUS protocol specification if you do not 
.................... understand the members of the structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request 
.................... { 
....................    unsigned int8 reference_type; 
....................    unsigned int16 file_number; 
....................    unsigned int16 record_number; 
....................    unsigned int16 record_length; 
.................... } modbus_read_sub_request; 
....................  
.................... typedef struct _modbus_write_sub_request 
.................... { 
....................    unsigned int8 reference_type; 
....................    unsigned int16 file_number; 
....................    unsigned int16 record_number; 
....................    unsigned int16 record_length; 
....................    unsigned int16 data[MODBUS_SERIAL_RX_BUFFER_SIZE-8]; 
.................... } modbus_write_sub_request; 
....................  
.................... /******************************************************************** 
.................... The following functions are defined in the MODBUS protocol.  Please 
.................... refer to http://www.modbus.org for the purpose of each of these. 
.................... All functions take the slaves address as their first parameter. 
.................... Each function returns the exception code received from the response. 
.................... The function will return 0 if there were no errors in transmission. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity); 
....................  
.................... /* 
.................... read_discrete_input 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_discrete_input(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity); 
.................... /* 
.................... read_holding_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_holding_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity); 
....................  
.................... /* 
.................... read_input_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_input_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity); 
....................  
.................... /* 
.................... write_single_coil 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Address to write into 
....................            int1       on                 true for on, false for off 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_coil(unsigned int8 address, unsigned int16 output_address, int1 on); 
....................  
.................... /* 
.................... write_single_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Address to write into 
....................            int16      reg_value          Value to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_register(unsigned int8 address, unsigned int16 reg_address, unsigned int16 reg_value); 
....................  
.................... /* 
.................... read_exception_status 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_exception_status(unsigned int8 address); 
....................  
.................... /* 
.................... diagnostics 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Subfunction to send 
....................            int16      data               Data to send, changes based on subfunction 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_diagnostics(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data); 
....................  
.................... /* 
.................... get_comm_event_couter 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_counter(unsigned int8 address); 
....................  
.................... /* 
.................... get_comm_event_log 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_log(unsigned int8 address); 
....................  
.................... /* 
.................... write_multiple_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int1*      values             A pointer to an array holding the values to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity, 
....................                            unsigned int8 *values); 
....................  
.................... /* 
.................... write_multiple_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int16*     values             A pointer to an array holding the data to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity, 
....................                            unsigned int16 *values); 
....................  
.................... /* 
.................... report_slave_id 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_report_slave_id(unsigned int8 address); 
....................  
.................... /* 
.................... read_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_file_record(unsigned int8 address, unsigned int8 byte_count, 
....................                             modbus_read_sub_request *request); 
....................  
.................... /* 
.................... write_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record/data information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_file_record(unsigned int8 address, unsigned int8 byte_count, 
....................                             modbus_write_sub_request *request); 
....................  
.................... /* 
.................... mask_write_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reference_address  Address to mask 
....................            int16      AND_mask           A mask to AND with the data at reference_address 
....................            int16      OR_mask            A mask to OR with the data at reference_address 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_mask_write_register(unsigned int8 address, unsigned int16 reference_address, 
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask); 
....................  
.................... /* 
.................... read_write_multiple_registers 
.................... Input:     int8       address                Slave Address 
....................            int16      read_start             Address to start reading 
....................            int16      read_quantity          Amount of registers to read 
....................            int16      write_start            Address to start writing 
....................            int16      write_quantity         Amount of registers to write 
....................            int16*     write_registers_value  Pointer to an aray us to write 
.................... Output:    exception                         0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_write_multiple_registers(unsigned int8 address, unsigned int16 read_start, 
....................                                     unsigned int16 read_quantity, unsigned int16 write_start, 
....................                                     unsigned int16 write_quantity, 
....................                                     unsigned int16 *write_registers_value); 
....................  
.................... /* 
.................... read_FIFO_queue 
.................... Input:     int8       address           Slave Address 
....................            int16      FIFO_address      FIFO address 
.................... Output:    exception                    0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_FIFO_queue(unsigned int8 address, unsigned int16 FIFO_address); 
....................  
.................... #else 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Slave API                                                                        //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_coils_rsp(address,byte_count,*coil_data)                       //// 
.................... ////    - Wrapper to respond to 0x01(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_discrete_input_rsp(address,byte_count,*input_data)             //// 
.................... ////    - Wrapper to respond to 0x02(read discret input) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_holding_registers_rsp(address,byte_count,*reg_data)            //// 
.................... ////    - Wrapper to respond to 0x03(read holding regs) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_input_registers_rsp(address,byte_count,*input_data)            //// 
.................... ////    - Wrapper to respond to 0x04(read input regs) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_coil_rsp(address,output_address,output_value)          //// 
.................... ////    - Wrapper to respond to 0x05(write single coil) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_register_rsp(address,reg_address,reg_value)            //// 
.................... ////    - Wrapper to respond to 0x06(write single reg) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_exception_status_rsp(address, data)                            //// 
.................... ////    - Wrapper to respond to 0x07(read void status) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_diagnostics_rsp(address,sub_func,data)                              //// 
.................... ////    - Wrapper to respond to 0x08(diagnostics) in the MODBUS specification.        //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_counter_rsp(address,status,event_count)              //// 
.................... ////    - Wrapper to respond to 0x0B(get comm event count) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_log_rsp(address,status,event_count,message_count,    //// 
.................... ////                                   *events, events_len)                           //// 
.................... ////    - Wrapper to respond to 0x0C(get comm event log) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_coils_rsp(address,start_address,quantity)            //// 
.................... ////    - Wrapper to respond to 0x0F(write multiple coils) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_registers_rsp(address,start_address,quantity)        //// 
.................... ////    - Wrapper to respond to 0x10(write multiple regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_report_slave_id_rsp(address,slave_id,run_status,*data,data_len)     //// 
.................... ////    - Wrapper to respond to 0x11(report slave id) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_file_record_rsp(address,byte_count,*request)                   //// 
.................... ////    - Wrapper to respond to 0x14(read file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_file_record_rsp(address,byte_count,*request)                  //// 
.................... ////    - Wrapper to respond to 0x15(write file record) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_mask_write_register_rsp(address,reference_address,AND_mask,OR_mask) //// 
.................... ////    - Wrapper to respond to 0x16(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_write_multiple_registers_rsp(address,*data,data_len)           //// 
.................... ////    - Wrapper to respond to 0x17(read write mult regs) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_FIFO_queue_rsp(address,FIFO_len,*data)                         //// 
.................... ////    - Wrapper to respond to 0x18(read FIFO queue) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_exception_rsp(int8 address, int16 func, exception error)            //// 
.................... ////    - Wrapper to send an exception response.  See exception list below.           //// 
.................... ////                                                                                  //// 
.................... //// Exception List:                                                                  //// 
.................... ////  ILLEGAL_FUNCTION, ILLEGAL_DATA_ADDRESS, ILLEGAL_DATA_VALUE,                     //// 
.................... ////  SLAVE_DEVICE_FAILURE, ACKNOWLEDGE, SLAVE_DEVICE_BUSY, MEMORY_PARITY_ERROR,      //// 
.................... ////  GATEWAY_PATH_UNAVAILABLE, GATEWAY_TARGET_NO_RESPONSE                            //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    unsigned int8 record_length; 
....................    unsigned int8 reference_type; 
....................    unsigned int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    unsigned int8 reference_type; 
....................    unsigned int16 file_number; 
....................    unsigned int16 record_number; 
....................    unsigned int16 record_length; 
....................    unsigned int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(unsigned int8 address, unsigned int8 byte_count, unsigned int8* coil_data); 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     unsigned int8 *input_data); 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                         unsigned int16 *reg_data); 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                         unsigned int16 *input_data); 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(unsigned int8 address, unsigned int16 output_address, 
....................                                     unsigned int16 output_value); 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(unsigned int8 address, unsigned int16 reg_address, 
....................                                         unsigned int16 reg_value); 
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(unsigned int8 address, unsigned int8 data); 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data); 
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(unsigned int8 address, unsigned int16 status, 
....................                                         unsigned int16 event_count); 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(unsigned int8 address, unsigned int16 status, 
....................                                     unsigned int16 event_count, unsigned int16 message_count, 
....................                                     unsigned int8 *events, unsigned int8 events_len); 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(unsigned int8 address, unsigned int16 start_address, 
....................                                         unsigned int16 quantity); 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(unsigned int8 address, unsigned int16 start_address, 
....................                                             unsigned int16 quantity); 
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(unsigned int8 address, unsigned int8 slave_id, unsigned int1 run_status, 
....................                               unsigned int8 *data, unsigned int8 data_len); 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     modbus_read_sub_request_rsp *request); 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     modbus_write_sub_request_rsp *request); 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(unsigned int8 address, unsigned int16 reference_address, 
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask); 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(unsigned int8 address, unsigned int8 data_len, 
....................                                                 unsigned int16 *data); 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(unsigned int8 address, unsigned int16 FIFO_len, unsigned int16 *data); 
....................  
.................... void modbus_exception_rsp(unsigned int8 address, unsigned int16 func, exception error); 
.................... #endif //MODBUS_TYPE 
....................  
.................... #endif //MODBUS_APP_LAYER_H 
....................  
.................... #endif 
....................  
.................... #endif //MODBUS_H 
....................  
....................  
.................... #if (MODBUS_PROTOCOL == MODBUS_PROTOCOL_SERIAL) 
....................  #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................   #include <modbus_phy_layer_rtu_local.c> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                              modbus_phy_layer_rtu.c                              //// 
.................... ////                                                                                  //// 
.................... ////      Physical layer of the MODBUS protocol driver for serial communications.     //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MODBUS_PHY_LAYER_RTU_C 
.................... #define MODBUS_PHY_LAYER_RTU_C 
....................  
.................... #include <modbus_phy_layer_local.h> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                modbus_phy_layer.h                                //// 
.................... ////                                                                                  //// 
.................... ////      Physical layer of the MODBUS protocol driver for serial communications.     //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  July 20, 2011       Seperated Physical Layer functions definitions into this    //// 
.................... ////                      file from modbus.c                                          //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MODBUS_PHY_LAYER_H 
.................... #define MODBUS_PHY_LAYER_H 
....................  
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER) 
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\ 
.................... {\ 
....................    modbus_timeout_enabled = 0;\ 
....................    if(address)\ 
....................    {\ 
....................       while(!modbus_kbhit() && --modbus_serial_wait)\ 
....................          delay_us(1);\ 
....................       if(!modbus_serial_wait)\ 
....................          modbus_rx.error=TIMEOUT;\ 
....................    }\ 
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\ 
.................... } 
.................... #else 
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\ 
.................... {\ 
....................    if(address)\ 
....................    {\ 
....................       while(!modbus_kbhit() && --modbus_serial_wait)\ 
....................          delay_us(1);\ 
....................       if(!modbus_serial_wait)\ 
....................          modbus_rx.error=TIMEOUT;\ 
....................    }\ 
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\ 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT) 
....................    #if defined(__PCD__) 
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA) 
....................          #word TXSTA=getenv("SFR:U1STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2) 
....................          #word TXSTA=getenv("SFR:U2STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3) 
....................          #word TXSTA=getenv("SFR:U3STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4) 
....................          #word TXSTA=getenv("SFR:U4STA") 
....................          #bit TRMT=TXSTA.8 
....................       #endif 
....................    #else 
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA) 
....................          #if getenv("sfr_valid:TXSTA") 
....................             #byte TXSTA=getenv("sfr:TXSTA") 
....................          #elif getenv("sf_valid:TXSTA1") 
....................             #byte TXSTA=getenv("sfr:TXSTA1") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX1STA") 
....................          #endif 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2) 
....................          #if getenv("sfr_valid:TXSTA2") 
....................             #byte TXSTA=getenv("sfr:TXSTA2") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX2STA") 
....................          #endif 
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3) 
....................          #if getenv("sfr_valid:TXSTA3") 
....................             #byte TXSTA=getenv("sfr:TXSTA3") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX3STA") 
....................          #endif 
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4) 
....................          #if getenv("sfr_valid:TXSTA4") 
....................             #byte TXSTA=getenv("sfr:TXSTA4") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX4STA") 
....................          #endif 
....................       #endif 
....................       #bit TRMT=TXSTA.1 
....................    #endif 
.................... #endif 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT) 
.................... #define WAIT_FOR_HW_BUFFER()\ 
.................... {\ 
....................    while(!TRMT);\ 
.................... } 
.................... #endif 
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions. 
.................... The first exception is the only one that is not part of the protocol 
.................... specification.  The TIMEOUT exception is returned when no slave 
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2, 
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6, 
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See 
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see 
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    unsigned int8 address; 
....................    unsigned int8 len;                       //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    unsigned int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////  For Custom Commands                                                             //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_putc(unsigned int8 c)                                             //// 
.................... ////    - Sends a character onto the serial line                                      //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(unsigned int8 to, unsigned int8 func); 
....................  
.................... // Purpose:    Sends a message stop 
.................... // Inputs:     none 
.................... // Outputs:    None 
.................... void modbus_serial_send_stop(); 
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(unsigned int8 c); 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////  For Init                                                                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void); 
....................  
.................... #endif //MODBUS_PHY_LAYER_H 
....................  
....................  
.................... #if (MODBUS_TIMER_USED == MODBUS_TIMER_T1) 
....................   #if (MODBUS_TIMER_UPDATE == MODBUS_TIMER_ISR) 
....................     #USE TIMER(TIMER=1,TICK=1ms,BITS=16, ISR) 
*
00A50:  MOVFF  10A,00
00A54:  MOVFF  10B,01
00A58:  CLRF   02
00A5A:  BCF    FD8.0
00A5C:  RLCF   00,F
00A5E:  RLCF   01,F
00A60:  RLCF   02,F
00A62:  MOVFF  01,63
00A66:  MOVFF  02,64
00A6A:  MOVFF  00,FCF
00A6E:  CLRF   FCE
00A70:  RETURN 0
*
0175E:  MOVFF  63,01
01762:  MOVF   FCE,W
01764:  MOVFF  FCF,03
01768:  BCF    F9D.0
0176A:  MOVWF  02
0176C:  MOVF   x63,W
0176E:  SUBWF  01,W
01770:  BZ    177A
01772:  MOVF   FCE,W
01774:  MOVFF  FCF,03
01778:  BRA    177C
0177A:  MOVF   02,W
0177C:  MOVFF  03,00
01780:  MOVFF  63,01
01784:  MOVFF  64,02
01788:  RRCF   02,F
0178A:  RRCF   01,F
0178C:  RRCF   00,F
0178E:  BSF    F9D.0
01790:  GOTO   17D6 (RETURN)
....................   #else 
....................     #USE TIMER(TIMER=1,TICK=.1ms,BITS=16, NOISR) 
....................   #endif 
.................... #elif (MODBUS_TIMER_USED == MODBUS_TIMER_T2) 
....................   #if (MODBUS_TIMER_UPDATE == MODBUS_TIMER_ISR) 
....................     #USE TIMER(TIMER=2,TICK=.1ms,BITS=16, ISR) 
....................   #else 
....................     #USE TIMER(TIMER=2,TICK=.1ms,BITS=16, NOISR) 
....................   #endif 
.................... #endif 
....................  
.................... #define MODBUS_GETDATA_TIMEOUT 40 
....................  
.................... #if( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA ) 
....................   #if MODBUS_PARITY == "EVEN" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART1, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, errors) 
....................   #elif MODBUS_PARITY == "ODD" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART1, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, errors) 
....................   #else 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART1, bits=8, stop=2, parity=N, stream=MODBUS_SERIAL, errors) 
....................   #endif 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2 ) 
....................   #if MODBUS_PARITY == "EVEN" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART2, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, errors) 
....................   #elif MODBUS_PARITY == "ODD" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART2, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, errors) 
....................   #else 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART2, bits=8, stop=2, parity=N, stream=MODBUS_SERIAL, errors) 
....................   #endif 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA2);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3 ) 
....................   #if MODBUS_PARITY == "EVEN" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART3, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, errors) 
....................   #elif MODBUS_PARITY == "ODD" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART3, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, errors) 
....................   #else 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART3, bits=8, stop=2, parity=N, stream=MODBUS_SERIAL, errors) 
....................   #endif 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA3);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4 ) 
....................   #if MODBUS_PARITY == "EVEN" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART4, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, errors) 
....................   #elif MODBUS_PARITY == "ODD" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART4, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, errors) 
....................   #else 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART4, bits=8, stop=2, parity=N, stream=MODBUS_SERIAL, errors) 
....................   #endif 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA4);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_EXT ) 
....................   #if MODBUS_PARITY == "EVEN" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, xmit=MODBUS_SERIAL_TX_PIN, rcv=MODBUS_SERIAL_RX_PIN, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, disable_ints) 
*
009F0:  BSF    F93.0
009F2:  BTFSC  F81.0
009F4:  BRA    09F2
009F6:  MOVLW  08
009F8:  MOVWF  00
009FA:  MOVLB  1
009FC:  CLRF   x09
009FE:  MOVFF  FF2,10A
00A02:  BCF    FF2.7
00A04:  BSF    00.7
00A06:  BRA    0A2A
00A08:  BCF    00.7
00A0A:  BRA    0A2A
00A0C:  BCF    FD8.0
00A0E:  BTFSC  F81.0
00A10:  BSF    FD8.0
00A12:  RRCF   x09,F
00A14:  BSF    00.6
00A16:  BRA    0A2A
00A18:  BCF    00.6
00A1A:  DECFSZ 00,F
00A1C:  BRA    0A0C
00A1E:  BSF    00.5
00A20:  BRA    0A2A
00A22:  BCF    00.5
00A24:  MOVFF  109,01
00A28:  BRA    0A46
00A2A:  MOVLW  84
00A2C:  BTFSC  00.7
00A2E:  MOVLW  24
00A30:  MOVWF  01
00A32:  DECFSZ 01,F
00A34:  BRA    0A32
00A36:  BRA    0A38
00A38:  BTFSC  00.7
00A3A:  BRA    0A08
00A3C:  BTFSC  00.6
00A3E:  BRA    0A18
00A40:  BTFSC  00.5
00A42:  BRA    0A22
00A44:  BRA    0A0C
00A46:  BTFSC  x0A.7
00A48:  BSF    FF2.7
00A4A:  MOVLB  0
00A4C:  GOTO   0ACA (RETURN)
*
0167E:  MOVFF  FF2,03
01682:  BCF    FF2.7
01684:  CLRF   xF7
01686:  BCF    F93.3
01688:  BCF    F8A.3
0168A:  MOVLW  08
0168C:  MOVWF  01
0168E:  BRA    1690
01690:  NOP   
01692:  BSF    01.7
01694:  BRA    16C4
01696:  BCF    01.7
01698:  MOVF   xF6,W
0169A:  XORWF  xF7,F
0169C:  RRCF   xF6,F
0169E:  BTFSC  FD8.0
016A0:  BSF    F8A.3
016A2:  BTFSS  FD8.0
016A4:  BCF    F8A.3
016A6:  BSF    01.6
016A8:  BRA    16C4
016AA:  BCF    01.6
016AC:  DECFSZ 01,F
016AE:  BRA    1698
016B0:  BRA    16B2
016B2:  NOP   
016B4:  BTFSC  xF7.0
016B6:  BSF    F8A.3
016B8:  BTFSS  xF7.0
016BA:  BCF    F8A.3
016BC:  BSF    01.5
016BE:  BRA    16C4
016C0:  BCF    01.5
016C2:  BSF    F8A.3
016C4:  MOVLW  84
016C6:  MOVWF  FE9
016C8:  DECFSZ FE9,F
016CA:  BRA    16C8
016CC:  NOP   
016CE:  BTFSC  01.7
016D0:  BRA    1696
016D2:  BTFSC  01.6
016D4:  BRA    16AA
016D6:  BTFSC  01.5
016D8:  BRA    16C0
016DA:  BTFSC  03.7
016DC:  BSF    FF2.7
016DE:  GOTO   16E8 (RETURN)
....................   #elif MODBUS_PARITY == "ODD" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, xmit=MODBUS_SERIAL_TX_PIN, rcv=MODBUS_SERIAL_RX_PIN, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, disable_ints) 
....................   #else 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, xmit=MODBUS_SERIAL_TX_PIN, rcv=MODBUS_SERIAL_RX_PIN, bits=8, stop=2, parity=N, stream=MODBUS_SERIAL, disable_ints) 
....................   #endif 
....................    #if defined(__PCD__) 
....................    #define RCV_OFF() {disable_interrupts(INT_EXT0);} 
....................    #else 
....................    #define RCV_OFF() {disable_interrupts(INT_EXT);} 
....................    #endif 
.................... #else 
....................    #error Please define a correct interrupt source 
.................... #endif 
....................  
.................... /* status of between byte timeout */ 
.................... int1 modbus_timeout_enabled = false; 
....................  
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER) 
.................... unsigned int32 modbus_serial_wait=MODBUS_SERIAL_TIMEOUT; 
.................... #endif 
....................  
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
....................  
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... union 
.................... { 
....................    unsigned int8 b[2]; 
....................    unsigned int16 d; 
.................... } modbus_serial_crc; 
....................  
....................  
.................... /* Table of CRC values for highorder byte */ 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for loworder byte */ 
.................... const unsigned char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) 
.................... { 
....................    #if (MODBUS_SERIAL_INT_SOURCE!=MODBUS_INT_EXT) 
....................       while(kbhit(MODBUS_SERIAL)) {fgetc(MODBUS_SERIAL);}  //Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
....................       #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA) 
....................          clear_interrupt(INT_RDA); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2) 
....................          clear_interrupt(INT_RDA2); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3) 
....................          clear_interrupt(INT_RDA3); 
....................       #else 
....................          clear_interrupt(INT_RDA4); 
....................       #endif 
....................  
....................       #if (MODBUS_SERIAL_RX_ENABLE!=0) 
....................          output_low(MODBUS_SERIAL_RX_ENABLE); 
....................       #endif 
....................  
....................       #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA) 
....................         enable_interrupts(INT_RDA); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2) 
....................         enable_interrupts(INT_RDA2); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3) 
....................         enable_interrupts(INT_RDA3); 
....................       #else 
....................         enable_interrupts(INT_RDA4); 
....................       #endif 
....................    #else 
....................       #if defined(__PCD__) 
....................          clear_interrupt(INT_EXT0); 
....................       #else 
....................          clear_interrupt(INT_EXT); 
*
00F78:  BCF    FF2.1
....................       #endif 
....................  
....................       ext_int_edge(H_TO_L); 
00F7A:  BCF    FF1.6
....................  
....................       #if (MODBUS_SERIAL_RX_ENABLE!=0) 
....................          output_low(MODBUS_SERIAL_RX_ENABLE); 
00F7C:  BCF    F93.5
00F7E:  BCF    F8A.5
....................       #endif 
....................  
....................       #if defined(__PCD__) 
....................          enable_interrupts(INT_EXT0); 
....................       #else 
....................          enable_interrupts(INT_EXT); 
00F80:  BSF    FF2.4
....................       #endif 
....................    #endif 
00F82:  RETURN 0
.................... } 
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... // Not used for ASCII mode 
.................... void modbus_enable_timeout(int1 enable) 
.................... { 
....................    modbus_timeout_enabled = enable; 
*
00A72:  BCF    1E.1
00A74:  MOVLB  1
00A76:  BTFSC  x09.0
00A78:  BSF    1E.1
....................    set_ticks(0); 
00A7A:  CLRF   x0B
00A7C:  CLRF   x0A
00A7E:  MOVLB  0
00A80:  RCALL  0A50
00A82:  RETURN 0
.................... } 
....................  
.................... // Purpose:    Handles a timeout when waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... // Not used for ASCII mode 
.................... void modbus_timeout_now(void) 
.................... { 
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
*
01794:  MOVF   x69,W
01796:  SUBLW  02
01798:  BNZ   17AE
0179A:  MOVF   x6A,F
0179C:  BNZ   17AE
0179E:  MOVF   x6B,F
017A0:  BNZ   17AE
017A2:  BTFSC  1E.0
017A4:  BRA    17AE
....................    { 
....................       modbus_rx.len-=2; 
017A6:  MOVLW  02
017A8:  SUBWF  20,F
....................       modbus_serial_new=TRUE; 
017AA:  BSF    1E.0
....................    } else { 
017AC:  BRA    17B0
....................       modbus_serial_new=FALSE; 
017AE:  BCF    1E.0
....................    } 
....................  
....................    modbus_serial_crc.d=0xFFFF; 
017B0:  SETF   x6B
017B2:  SETF   x6A
....................    modbus_serial_state=MODBUS_GETADDY; 
017B4:  CLRF   x69
017B6:  CLRF   16
017B8:  BTFSC  FF2.7
017BA:  BSF    16.7
017BC:  BCF    FF2.7
....................    modbus_enable_timeout(FALSE); 
017BE:  MOVLB  1
017C0:  CLRF   x09
017C2:  MOVLB  0
017C4:  CALL   0A72
017C8:  BTFSC  16.7
017CA:  BSF    FF2.7
017CC:  GOTO   17EA (RETURN)
.................... } 
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... // Not used for ASCII mode 
.................... void modbus_check_timeout(void) 
.................... { 
....................    #if (MODBUS_TIMER_UPDATE == MODBUS_TIMER_NOISR) 
....................    //get_ticks() must be called more often than the timer overflow 
....................    //rate, and the get_ticks() below will not always be called 
....................    //due to short circuit evaluation 
....................    get_ticks(); 
....................    #endif 
....................    //modbus_timeout_enabled must be checked before get_ticks() 
....................    //so that if an interrupt happens it cannot be enabled after 
....................    //an old timer value is used in comparison 
....................    if(modbus_timeout_enabled && (get_ticks() > MODBUS_GETDATA_TIMEOUT)) 
017D0:  BTFSS  1E.1
017D2:  BRA    17EA
017D4:  BRA    175E
017D6:  MOVFF  01,F4
017DA:  MOVFF  00,F3
017DE:  MOVF   xF4,F
017E0:  BNZ   17E8
017E2:  MOVF   xF3,W
017E4:  SUBLW  28
017E6:  BC    17EA
....................    { 
....................      modbus_timeout_now(); 
017E8:  BRA    1794
....................    } 
017EA:  GOTO   17F0 (RETURN)
.................... } 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_calc_crc(char data) 
.................... { 
....................    unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................    uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
00A84:  MOVF   x6B,W
00A86:  MOVLB  1
00A88:  XORWF  x09,W
00A8A:  MOVWF  x0A
....................    modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
00A8C:  CLRF   03
00A8E:  MOVF   x0A,W
00A90:  MOVFF  FF2,10B
00A94:  BCF    FF2.7
00A96:  MOVLB  0
00A98:  RCALL  06A2
00A9A:  MOVLB  1
00A9C:  BTFSC  x0B.7
00A9E:  BSF    FF2.7
00AA0:  MOVWF  01
00AA2:  MOVLB  0
00AA4:  MOVF   x6A,W
00AA6:  XORWF  01,W
00AA8:  MOVWF  x6B
....................    modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
00AAA:  CLRF   03
00AAC:  MOVLB  1
00AAE:  MOVF   x0A,W
00AB0:  MOVFF  FF2,10B
00AB4:  BCF    FF2.7
00AB6:  MOVLB  0
00AB8:  RCALL  07C4
00ABA:  MOVLB  1
00ABC:  BTFSC  x0B.7
00ABE:  BSF    FF2.7
00AC0:  MOVFF  FE8,6A
00AC4:  MOVLB  0
00AC6:  RETURN 0
.................... } 
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(unsigned int8 c) 
.................... { 
....................    fputc(c, MODBUS_SERIAL); 
*
016E2:  MOVFF  F5,F6
016E6:  BRA    167E
016E8:  CLRF   16
016EA:  BTFSC  FF2.7
016EC:  BSF    16.7
016EE:  BCF    FF2.7
....................    modbus_calc_crc(c); 
016F0:  MOVFF  F5,109
016F4:  CALL   0A84
016F8:  BTFSC  16.7
016FA:  BSF    FF2.7
....................    delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact 
016FC:  MOVLW  8A
016FE:  MOVWF  00
01700:  DECFSZ 00,F
01702:  BRA    1700
01704:  NOP   
01706:  RETURN 0
.................... } 
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(unsigned int8 to, unsigned int8 func) 
.................... { 
....................    modbus_serial_crc.d=0xFFFF; 
01708:  SETF   x6B
0170A:  SETF   x6A
....................    modbus_serial_new=FALSE; 
0170C:  BCF    1E.0
....................  
....................    RCV_OFF(); 
0170E:  BCF    FF2.4
....................  
.................... #if (MODBUS_SERIAL_ENABLE_PIN!=0) 
....................    output_high(MODBUS_SERIAL_ENABLE_PIN); 
01710:  BCF    F93.4
01712:  BSF    F8A.4
.................... #endif 
....................  
....................    delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay 
01714:  MOVLW  02
01716:  MOVWF  xF5
01718:  MOVLW  B5
0171A:  MOVWF  xF6
0171C:  RCALL  1664
0171E:  DECFSZ xF5,F
01720:  BRA    1718
....................  
....................    modbus_serial_putc(to); 
01722:  MOVFF  F3,F5
01726:  RCALL  16E2
....................    modbus_serial_putc(func); 
01728:  MOVFF  F4,F5
0172C:  RCALL  16E2
0172E:  RETURN 0
.................... } 
....................  
.................... // Purpose:    Ends a message over the RS485 Bus 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_send_stop() 
.................... { 
....................    unsigned int8 crc_low, crc_high; 
....................  
....................    crc_high=modbus_serial_crc.b[1]; 
01730:  MOVFF  6B,F4
....................    crc_low=modbus_serial_crc.b[0]; 
01734:  MOVFF  6A,F3
....................  
....................    modbus_serial_putc(crc_high); 
01738:  MOVFF  F4,F5
0173C:  RCALL  16E2
....................    modbus_serial_putc(crc_low); 
0173E:  MOVFF  F3,F5
01742:  RCALL  16E2
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE!=MODBUS_INT_EXT) 
....................    WAIT_FOR_HW_BUFFER(); 
.................... #endif 
....................  
....................    delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay 
01744:  MOVLW  02
01746:  MOVWF  xF5
01748:  MOVLW  B5
0174A:  MOVWF  xF6
0174C:  RCALL  1664
0174E:  DECFSZ xF5,F
01750:  BRA    1748
....................  
....................    RCV_ON(); 
01752:  RCALL  0F78
....................  
.................... #if (MODBUS_SERIAL_ENABLE_PIN!=0) 
....................    output_low(MODBUS_SERIAL_ENABLE_PIN); 
01754:  BCF    F93.4
01756:  BCF    F8A.4
.................... #endif 
....................  
....................    modbus_serial_crc.d=0xFFFF; 
01758:  SETF   x6B
0175A:  SETF   x6A
0175C:  RETURN 0
.................... } 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Interrupts                                                                       //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA) 
.................... #int_rda 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2) 
.................... #int_rda2 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3) 
.................... #int_rda3 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA4) 
.................... #int_rda4 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_EXT) 
.................... #if defined(__PCD__) 
.................... #int_ext1 
.................... #else 
.................... #int_ext 
.................... #endif 
.................... #else 
.................... #error Please define a correct interrupt source 
.................... #endif 
.................... void incomming_modbus_serial() { 
....................    char c; 
....................  
....................    c=fgetc(MODBUS_SERIAL); 
*
00AC8:  BRA    09F0
00ACA:  MOVFF  01,108
....................  
....................    if (!modbus_serial_new) 
00ACE:  BTFSC  1E.0
00AD0:  BRA    0B26
....................    { 
....................       if(modbus_serial_state == MODBUS_GETADDY) 
00AD2:  MOVF   x69,F
00AD4:  BNZ   0AE6
....................       { 
....................          modbus_serial_crc.d = 0xFFFF; 
00AD6:  SETF   x6B
00AD8:  SETF   x6A
....................          modbus_rx.address = c; 
00ADA:  MOVFF  108,1F
....................          modbus_serial_state++; 
00ADE:  INCF   x69,F
....................          modbus_rx.len = 0; 
00AE0:  CLRF   20
....................          modbus_rx.error=0; 
00AE2:  CLRF   22
....................       } 
00AE4:  BRA    0B16
....................       else if(modbus_serial_state == MODBUS_GETFUNC) 
00AE6:  DECFSZ x69,W
00AE8:  BRA    0AF2
....................       { 
....................          modbus_rx.func = c; 
00AEA:  MOVFF  108,21
....................          modbus_serial_state++; 
00AEE:  INCF   x69,F
....................       } 
00AF0:  BRA    0B16
....................       else if(modbus_serial_state == MODBUS_GETDATA) 
00AF2:  MOVF   x69,W
00AF4:  SUBLW  02
00AF6:  BNZ   0B16
....................       { 
....................          if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) 
00AF8:  MOVF   20,W
00AFA:  SUBLW  3F
00AFC:  BC    0B02
....................        { 
....................          modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
00AFE:  MOVLW  3F
00B00:  MOVWF  20
....................        } 
....................          modbus_rx.data[modbus_rx.len]=c; 
00B02:  CLRF   03
00B04:  MOVF   20,W
00B06:  ADDLW  23
00B08:  MOVWF  FE9
00B0A:  MOVLW  00
00B0C:  ADDWFC 03,W
00B0E:  MOVWF  FEA
00B10:  MOVFF  108,FEF
....................          modbus_rx.len++; 
00B14:  INCF   20,F
....................      } 
....................      modbus_enable_timeout(TRUE); 
00B16:  MOVLW  01
00B18:  MOVLB  1
00B1A:  MOVWF  x09
00B1C:  MOVLB  0
00B1E:  RCALL  0A72
....................      modbus_calc_crc(c); 
00B20:  MOVFF  108,109
00B24:  RCALL  0A84
....................    } 
....................  
....................    #if (MODBUS_TYPE == MODBUS_TYPE_MASTER) 
....................       modbus_serial_wait=MODBUS_SERIAL_TIMEOUT; 
00B26:  CLRF   x68
00B28:  CLRF   x67
00B2A:  MOVLW  27
00B2C:  MOVWF  x66
00B2E:  MOVLW  10
00B30:  MOVWF  x65
....................    #endif 
.................... } 
.................... #endif //MODBUS_PHY_LAYER_RTU_C 
....................  
....................  #elif (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................   #include <modbus_phy_layer_ascii.c> 
....................  #endif 
.................... #else 
....................  #include <modbus_phy_layer_tcpip.c> 
.................... #endif 
....................  
.................... #if (MODBUS_PROTOCOL == MODBUS_PROTOCOL_TCPIP) 
....................  #include <modbus_app_layer_tcpip.c> 
.................... #else 
....................  #include <modbus_app_layer.c> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                modbus_app_layer.c                                //// 
.................... ////                                                                                  //// 
.................... ////    Application layer of the MODBUS protocol driver for serial communications.    //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MODBUS_APP_LAYER_C 
.................... #define MODBUS_APP_LAYER_C 
....................  
.................... #include <modbus_app_layer.h> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                modbus_app_layer.h                                //// 
.................... ////                                                                                  //// 
.................... ////    Application layer of the MODBUS protocol driver for serial communications.    //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  July 20, 2011       Seperated App Layer functions into this file from modbus.c  //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
00B32:  BCF    FF2.1
00B34:  GOTO   0660
.................... #ifndef MODBUS_APP_LAYER_H 
.................... #define MODBUS_APP_LAYER_H 
....................  
.................... #include <modbus_phy_layer.h> 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Shared API                                                                       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init(); 
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit(); 
....................  
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER) 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Master Api                                                                       //// 
.................... ////                                                                                  //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request.  These 
.................... functions take in one of these structs. 
.................... Please refer to the MODBUS protocol specification if you do not 
.................... understand the members of the structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request 
.................... { 
....................    unsigned int8 reference_type; 
....................    unsigned int16 file_number; 
....................    unsigned int16 record_number; 
....................    unsigned int16 record_length; 
.................... } modbus_read_sub_request; 
....................  
.................... typedef struct _modbus_write_sub_request 
.................... { 
....................    unsigned int8 reference_type; 
....................    unsigned int16 file_number; 
....................    unsigned int16 record_number; 
....................    unsigned int16 record_length; 
....................    unsigned int16 data[MODBUS_SERIAL_RX_BUFFER_SIZE-8]; 
.................... } modbus_write_sub_request; 
....................  
.................... /******************************************************************** 
.................... The following functions are defined in the MODBUS protocol.  Please 
.................... refer to http://www.modbus.org for the purpose of each of these. 
.................... All functions take the slaves address as their first parameter. 
.................... Each function returns the exception code received from the response. 
.................... The function will return 0 if there were no errors in transmission. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity); 
....................  
.................... /* 
.................... read_discrete_input 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_discrete_input(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity); 
.................... /* 
.................... read_holding_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_holding_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity); 
....................  
.................... /* 
.................... read_input_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_input_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity); 
....................  
.................... /* 
.................... write_single_coil 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Address to write into 
....................            int1       on                 true for on, false for off 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_coil(unsigned int8 address, unsigned int16 output_address, int1 on); 
....................  
.................... /* 
.................... write_single_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Address to write into 
....................            int16      reg_value          Value to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_register(unsigned int8 address, unsigned int16 reg_address, unsigned int16 reg_value); 
....................  
.................... /* 
.................... read_exception_status 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_exception_status(unsigned int8 address); 
....................  
.................... /* 
.................... diagnostics 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Subfunction to send 
....................            int16      data               Data to send, changes based on subfunction 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_diagnostics(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data); 
....................  
.................... /* 
.................... get_comm_event_couter 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_counter(unsigned int8 address); 
....................  
.................... /* 
.................... get_comm_event_log 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_log(unsigned int8 address); 
....................  
.................... /* 
.................... write_multiple_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int1*      values             A pointer to an array holding the values to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity, 
....................                            unsigned int8 *values); 
....................  
.................... /* 
.................... write_multiple_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int16*     values             A pointer to an array holding the data to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity, 
....................                            unsigned int16 *values); 
....................  
.................... /* 
.................... report_slave_id 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_report_slave_id(unsigned int8 address); 
....................  
.................... /* 
.................... read_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_file_record(unsigned int8 address, unsigned int8 byte_count, 
....................                             modbus_read_sub_request *request); 
....................  
.................... /* 
.................... write_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record/data information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_file_record(unsigned int8 address, unsigned int8 byte_count, 
....................                             modbus_write_sub_request *request); 
....................  
.................... /* 
.................... mask_write_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reference_address  Address to mask 
....................            int16      AND_mask           A mask to AND with the data at reference_address 
....................            int16      OR_mask            A mask to OR with the data at reference_address 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_mask_write_register(unsigned int8 address, unsigned int16 reference_address, 
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask); 
....................  
.................... /* 
.................... read_write_multiple_registers 
.................... Input:     int8       address                Slave Address 
....................            int16      read_start             Address to start reading 
....................            int16      read_quantity          Amount of registers to read 
....................            int16      write_start            Address to start writing 
....................            int16      write_quantity         Amount of registers to write 
....................            int16*     write_registers_value  Pointer to an aray us to write 
.................... Output:    exception                         0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_write_multiple_registers(unsigned int8 address, unsigned int16 read_start, 
....................                                     unsigned int16 read_quantity, unsigned int16 write_start, 
....................                                     unsigned int16 write_quantity, 
....................                                     unsigned int16 *write_registers_value); 
....................  
.................... /* 
.................... read_FIFO_queue 
.................... Input:     int8       address           Slave Address 
....................            int16      FIFO_address      FIFO address 
.................... Output:    exception                    0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_FIFO_queue(unsigned int8 address, unsigned int16 FIFO_address); 
....................  
.................... #else 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Slave API                                                                        //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_coils_rsp(address,byte_count,*coil_data)                       //// 
.................... ////    - Wrapper to respond to 0x01(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_discrete_input_rsp(address,byte_count,*input_data)             //// 
.................... ////    - Wrapper to respond to 0x02(read discret input) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_holding_registers_rsp(address,byte_count,*reg_data)            //// 
.................... ////    - Wrapper to respond to 0x03(read holding regs) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_input_registers_rsp(address,byte_count,*input_data)            //// 
.................... ////    - Wrapper to respond to 0x04(read input regs) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_coil_rsp(address,output_address,output_value)          //// 
.................... ////    - Wrapper to respond to 0x05(write single coil) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_register_rsp(address,reg_address,reg_value)            //// 
.................... ////    - Wrapper to respond to 0x06(write single reg) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_exception_status_rsp(address, data)                            //// 
.................... ////    - Wrapper to respond to 0x07(read void status) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_diagnostics_rsp(address,sub_func,data)                              //// 
.................... ////    - Wrapper to respond to 0x08(diagnostics) in the MODBUS specification.        //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_counter_rsp(address,status,event_count)              //// 
.................... ////    - Wrapper to respond to 0x0B(get comm event count) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_log_rsp(address,status,event_count,message_count,    //// 
.................... ////                                   *events, events_len)                           //// 
.................... ////    - Wrapper to respond to 0x0C(get comm event log) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_coils_rsp(address,start_address,quantity)            //// 
.................... ////    - Wrapper to respond to 0x0F(write multiple coils) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_registers_rsp(address,start_address,quantity)        //// 
.................... ////    - Wrapper to respond to 0x10(write multiple regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_report_slave_id_rsp(address,slave_id,run_status,*data,data_len)     //// 
.................... ////    - Wrapper to respond to 0x11(report slave id) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_file_record_rsp(address,byte_count,*request)                   //// 
.................... ////    - Wrapper to respond to 0x14(read file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_file_record_rsp(address,byte_count,*request)                  //// 
.................... ////    - Wrapper to respond to 0x15(write file record) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_mask_write_register_rsp(address,reference_address,AND_mask,OR_mask) //// 
.................... ////    - Wrapper to respond to 0x16(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_write_multiple_registers_rsp(address,*data,data_len)           //// 
.................... ////    - Wrapper to respond to 0x17(read write mult regs) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_FIFO_queue_rsp(address,FIFO_len,*data)                         //// 
.................... ////    - Wrapper to respond to 0x18(read FIFO queue) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_exception_rsp(int8 address, int16 func, exception error)            //// 
.................... ////    - Wrapper to send an exception response.  See exception list below.           //// 
.................... ////                                                                                  //// 
.................... //// Exception List:                                                                  //// 
.................... ////  ILLEGAL_FUNCTION, ILLEGAL_DATA_ADDRESS, ILLEGAL_DATA_VALUE,                     //// 
.................... ////  SLAVE_DEVICE_FAILURE, ACKNOWLEDGE, SLAVE_DEVICE_BUSY, MEMORY_PARITY_ERROR,      //// 
.................... ////  GATEWAY_PATH_UNAVAILABLE, GATEWAY_TARGET_NO_RESPONSE                            //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    unsigned int8 record_length; 
....................    unsigned int8 reference_type; 
....................    unsigned int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    unsigned int8 reference_type; 
....................    unsigned int16 file_number; 
....................    unsigned int16 record_number; 
....................    unsigned int16 record_length; 
....................    unsigned int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(unsigned int8 address, unsigned int8 byte_count, unsigned int8* coil_data); 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     unsigned int8 *input_data); 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                         unsigned int16 *reg_data); 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                         unsigned int16 *input_data); 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(unsigned int8 address, unsigned int16 output_address, 
....................                                     unsigned int16 output_value); 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(unsigned int8 address, unsigned int16 reg_address, 
....................                                         unsigned int16 reg_value); 
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(unsigned int8 address, unsigned int8 data); 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data); 
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(unsigned int8 address, unsigned int16 status, 
....................                                         unsigned int16 event_count); 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(unsigned int8 address, unsigned int16 status, 
....................                                     unsigned int16 event_count, unsigned int16 message_count, 
....................                                     unsigned int8 *events, unsigned int8 events_len); 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(unsigned int8 address, unsigned int16 start_address, 
....................                                         unsigned int16 quantity); 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(unsigned int8 address, unsigned int16 start_address, 
....................                                             unsigned int16 quantity); 
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(unsigned int8 address, unsigned int8 slave_id, unsigned int1 run_status, 
....................                               unsigned int8 *data, unsigned int8 data_len); 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     modbus_read_sub_request_rsp *request); 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     modbus_write_sub_request_rsp *request); 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(unsigned int8 address, unsigned int16 reference_address, 
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask); 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(unsigned int8 address, unsigned int8 data_len, 
....................                                                 unsigned int16 *data); 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(unsigned int8 address, unsigned int16 FIFO_len, unsigned int16 *data); 
....................  
.................... void modbus_exception_rsp(unsigned int8 address, unsigned int16 func, exception error); 
.................... #endif //MODBUS_TYPE 
....................  
.................... #endif //MODBUS_APP_LAYER_H 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Shared Api                                                                       //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() 
.................... { 
....................    output_low(MODBUS_SERIAL_ENABLE_PIN); 
*
00F84:  BCF    F93.4
00F86:  BCF    F8A.4
....................  
....................    RCV_ON(); 
00F88:  RCALL  0F78
....................  
....................    #if defined(__PCD__) 
....................       enable_interrupts(INTR_GLOBAL); 
....................    #else 
....................       enable_interrupts(GLOBAL); 
00F8A:  MOVLW  C0
00F8C:  IORWF  FF2,F
....................    #endif 
00F8E:  GOTO   0FA4 (RETURN)
.................... } 
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    #if(MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................    modbus_check_timeout(); 
*
017EE:  BRA    17D0
....................    #endif 
....................  
....................    if(!modbus_serial_new) 
017F0:  BTFSC  1E.0
017F2:  BRA    17FC
....................      return FALSE; 
017F4:  MOVLW  00
017F6:  MOVWF  01
017F8:  BRA    180E
017FA:  BRA    1808
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
017FC:  BTFSS  21.7
017FE:  BRA    1808
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
01800:  MOVFF  23,22
....................       modbus_rx.len = 1; 
01804:  MOVLW  01
01806:  MOVWF  20
....................    } 
....................    modbus_serial_new=FALSE; 
01808:  BCF    1E.0
....................    return TRUE; 
0180A:  MOVLW  01
0180C:  MOVWF  01
0180E:  RETURN 0
.................... } 
....................  
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER) 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Master API                                                                       //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /******************************************************************** 
.................... The following functions are defined in the MODBUS protocol.  Please 
.................... refer to http://www.modbus.org for the purpose of each of these. 
.................... All functions take the slaves address as their first parameter. 
.................... Each function returns the exception code received from the response. 
.................... The function will return 0 if there were no errors in transmission. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
01810:  MOVFF  DF,F3
01814:  MOVLW  01
01816:  MOVWF  xF4
01818:  RCALL  1708
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
0181A:  MOVFF  E1,E4
0181E:  MOVFF  E1,F5
01822:  RCALL  16E2
....................    modbus_serial_putc(make8(start_address,0)); 
01824:  MOVFF  E0,E4
01828:  MOVFF  E0,F5
0182C:  RCALL  16E2
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
0182E:  MOVFF  E3,E4
01832:  MOVFF  E3,F5
01836:  RCALL  16E2
....................    modbus_serial_putc(make8(quantity,0)); 
01838:  MOVFF  E2,E4
0183C:  MOVFF  E2,F5
01840:  RCALL  16E2
....................  
....................    modbus_serial_send_stop(); 
01842:  RCALL  1730
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
01844:  BCF    1E.1
01846:  MOVF   xDF,F
01848:  BZ    188A
0184A:  RCALL  17EE
0184C:  MOVF   01,F
0184E:  BNZ   1876
01850:  MOVLW  FF
01852:  ADDWF  x65,F
01854:  BTFSS  FD8.0
01856:  ADDWF  x66,F
01858:  BTFSS  FD8.0
0185A:  ADDWF  x67,F
0185C:  BTFSS  FD8.0
0185E:  ADDWF  x68,F
01860:  MOVF   x65,F
01862:  BNZ   1870
01864:  MOVF   x66,F
01866:  BNZ   1870
01868:  MOVF   x67,F
0186A:  BNZ   1870
0186C:  MOVF   x68,F
0186E:  BZ    1876
01870:  BRA    1872
01872:  BRA    1874
01874:  BRA    184A
01876:  MOVF   x65,F
01878:  BNZ   188A
0187A:  MOVF   x66,F
0187C:  BNZ   188A
0187E:  MOVF   x67,F
01880:  BNZ   188A
01882:  MOVF   x68,F
01884:  BNZ   188A
01886:  MOVLW  0C
01888:  MOVWF  22
0188A:  CLRF   x68
0188C:  CLRF   x67
0188E:  MOVLW  27
01890:  MOVWF  x66
01892:  MOVLW  10
01894:  MOVWF  x65
....................  
....................    return modbus_rx.error; 
01896:  MOVFF  22,01
0189A:  GOTO   19B0 (RETURN)
.................... } 
....................  
.................... /* 
.................... read_discrete_input 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_discrete_input(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_holding_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_holding_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
*
01A56:  MOVFF  EE,F3
01A5A:  MOVLW  03
01A5C:  MOVWF  xF4
01A5E:  RCALL  1708
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
01A60:  MOVFF  F0,F3
01A64:  MOVFF  F0,F5
01A68:  RCALL  16E2
....................    modbus_serial_putc(make8(start_address,0)); 
01A6A:  MOVFF  EF,F3
01A6E:  MOVFF  EF,F5
01A72:  RCALL  16E2
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
01A74:  MOVFF  F2,F3
01A78:  MOVFF  F2,F5
01A7C:  RCALL  16E2
....................    modbus_serial_putc(make8(quantity,0)); 
01A7E:  MOVFF  F1,F3
01A82:  MOVFF  F1,F5
01A86:  RCALL  16E2
....................  
....................    modbus_serial_send_stop(); 
01A88:  RCALL  1730
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
01A8A:  BCF    1E.1
01A8C:  MOVF   xEE,F
01A8E:  BZ    1AD0
01A90:  RCALL  17EE
01A92:  MOVF   01,F
01A94:  BNZ   1ABC
01A96:  MOVLW  FF
01A98:  ADDWF  x65,F
01A9A:  BTFSS  FD8.0
01A9C:  ADDWF  x66,F
01A9E:  BTFSS  FD8.0
01AA0:  ADDWF  x67,F
01AA2:  BTFSS  FD8.0
01AA4:  ADDWF  x68,F
01AA6:  MOVF   x65,F
01AA8:  BNZ   1AB6
01AAA:  MOVF   x66,F
01AAC:  BNZ   1AB6
01AAE:  MOVF   x67,F
01AB0:  BNZ   1AB6
01AB2:  MOVF   x68,F
01AB4:  BZ    1ABC
01AB6:  BRA    1AB8
01AB8:  BRA    1ABA
01ABA:  BRA    1A90
01ABC:  MOVF   x65,F
01ABE:  BNZ   1AD0
01AC0:  MOVF   x66,F
01AC2:  BNZ   1AD0
01AC4:  MOVF   x67,F
01AC6:  BNZ   1AD0
01AC8:  MOVF   x68,F
01ACA:  BNZ   1AD0
01ACC:  MOVLW  0C
01ACE:  MOVWF  22
01AD0:  CLRF   x68
01AD2:  CLRF   x67
01AD4:  MOVLW  27
01AD6:  MOVWF  x66
01AD8:  MOVLW  10
01ADA:  MOVWF  x65
....................  
....................    return modbus_rx.error; 
01ADC:  MOVFF  22,01
01AE0:  RETURN 0
.................... } 
....................  
.................... /* 
.................... read_input_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_input_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
*
022B4:  MOVFF  DF,F3
022B8:  MOVLW  04
022BA:  MOVWF  xF4
022BC:  CALL   1708
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
022C0:  MOVFF  E1,E4
022C4:  MOVFF  E1,F5
022C8:  CALL   16E2
....................    modbus_serial_putc(make8(start_address,0)); 
022CC:  MOVFF  E0,E4
022D0:  MOVFF  E0,F5
022D4:  CALL   16E2
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
022D8:  MOVFF  E3,E4
022DC:  MOVFF  E3,F5
022E0:  CALL   16E2
....................    modbus_serial_putc(make8(quantity,0)); 
022E4:  MOVFF  E2,E4
022E8:  MOVFF  E2,F5
022EC:  CALL   16E2
....................  
....................    modbus_serial_send_stop(); 
022F0:  CALL   1730
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
022F4:  BCF    1E.1
022F6:  MOVF   xDF,F
022F8:  BZ    233C
022FA:  CALL   17EE
022FE:  MOVF   01,F
02300:  BNZ   2328
02302:  MOVLW  FF
02304:  ADDWF  x65,F
02306:  BTFSS  FD8.0
02308:  ADDWF  x66,F
0230A:  BTFSS  FD8.0
0230C:  ADDWF  x67,F
0230E:  BTFSS  FD8.0
02310:  ADDWF  x68,F
02312:  MOVF   x65,F
02314:  BNZ   2322
02316:  MOVF   x66,F
02318:  BNZ   2322
0231A:  MOVF   x67,F
0231C:  BNZ   2322
0231E:  MOVF   x68,F
02320:  BZ    2328
02322:  BRA    2324
02324:  BRA    2326
02326:  BRA    22FA
02328:  MOVF   x65,F
0232A:  BNZ   233C
0232C:  MOVF   x66,F
0232E:  BNZ   233C
02330:  MOVF   x67,F
02332:  BNZ   233C
02334:  MOVF   x68,F
02336:  BNZ   233C
02338:  MOVLW  0C
0233A:  MOVWF  22
0233C:  CLRF   x68
0233E:  CLRF   x67
02340:  MOVLW  27
02342:  MOVWF  x66
02344:  MOVLW  10
02346:  MOVWF  x65
....................  
....................    return modbus_rx.error; 
02348:  MOVFF  22,01
0234C:  GOTO   2360 (RETURN)
.................... } 
....................  
.................... /* 
.................... write_single_coil 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Address to write into 
....................            int1       on                 true for on, false for off 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_coil(unsigned int8 address, unsigned int16 output_address, int1 on) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    if(on) 
....................        modbus_serial_putc(0xFF); 
....................    else 
....................        modbus_serial_putc(0x00); 
....................  
....................    modbus_serial_putc(0x00); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_single_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Address to write into 
....................            int16      reg_value          Value to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_register(unsigned int8 address, unsigned int16 reg_address, unsigned int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
....................    modbus_serial_putc(make8(reg_address,0)); 
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
....................    modbus_serial_putc(make8(reg_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_exception_status 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_exception_status(unsigned int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... diagnostics 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Subfunction to send 
....................            int16      data               Data to send, changes based on subfunction 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_diagnostics(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... get_comm_event_couter 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_counter(unsigned int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... get_comm_event_log 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_log(unsigned int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int1*      values             A pointer to an array holding the values to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity, 
....................                            unsigned int8 *values) 
.................... { 
....................    unsigned int8 i,count; 
....................  
....................    count = (unsigned int8)((quantity/8)); 
....................  
....................    if(quantity%8) 
....................       count++; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_putc(count); 
....................  
....................    for(i=0; i < count; ++i) 
....................       modbus_serial_putc(values[i]); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int16*     values             A pointer to an array holding the data to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity, 
....................                            unsigned int16 *values) 
.................... { 
....................    unsigned int8 i,count; 
....................  
....................    count = quantity*2; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_putc(count); 
....................  
....................    for(i=0; i < quantity; ++i) 
....................    { 
....................       modbus_serial_putc(make8(values[i],1)); 
....................       modbus_serial_putc(make8(values[i],0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... report_slave_id 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_report_slave_id(unsigned int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_file_record(unsigned int8 address, unsigned int8 byte_count, 
....................                             modbus_read_sub_request *request) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < (byte_count/7); i+=7) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record/data information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_file_record(unsigned int8 address, unsigned int8 byte_count, 
....................                             modbus_write_sub_request *request) 
.................... { 
....................    unsigned int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length) && 
....................             (j < MODBUS_SERIAL_RX_BUFFER_SIZE-8); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... mask_write_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reference_address  Address to mask 
....................            int16      AND_mask           A mask to AND with the data at reference_address 
....................            int16      OR_mask            A mask to OR with the data at reference_address 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_mask_write_register(unsigned int8 address, unsigned int16 reference_address, 
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers 
.................... Input:     int8       address                Slave Address 
....................            int16      read_start             Address to start reading 
....................            int16      read_quantity          Amount of registers to read 
....................            int16      write_start            Address to start writing 
....................            int16      write_quantity         Amount of registers to write 
....................            int16*     write_registers_value  Pointer to an aray us to write 
.................... Output:    exception                         0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_write_multiple_registers(unsigned int8 address, unsigned int16 read_start, 
....................                                     unsigned int16 read_quantity, unsigned int16 write_start, 
....................                                     unsigned int16 write_quantity, 
....................                                     unsigned int16 *write_registers_value) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(read_start,1)); 
....................    modbus_serial_putc(make8(read_start,0)); 
....................  
....................    modbus_serial_putc(make8(read_quantity,1)); 
....................    modbus_serial_putc(make8(read_quantity,0)); 
....................  
....................    modbus_serial_putc(make8(write_start, 1)); 
....................    modbus_serial_putc(make8(write_start, 0)); 
....................  
....................    modbus_serial_putc(make8(write_quantity, 1)); 
....................    modbus_serial_putc(make8(write_quantity, 0)); 
....................  
....................    modbus_serial_putc((unsigned int8)(2*write_quantity)); 
....................  
....................    for(i=0; i < write_quantity ; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(write_registers_value[i], 1)); 
....................       modbus_serial_putc(make8(write_registers_value[i+1], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue 
.................... Input:     int8       address           Slave Address 
....................            int16      FIFO_address      FIFO address 
.................... Output:    exception                    0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_FIFO_queue(unsigned int8 address, unsigned int16 FIFO_address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(FIFO_address, 1)); 
....................    modbus_serial_putc(make8(FIFO_address, 0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... #else 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Slave API                                                                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(unsigned int8 address, unsigned int8 byte_count, unsigned int8* coil_data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     unsigned int8 *input_data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                         unsigned int16 *reg_data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(*reg_data,1)); 
....................       modbus_serial_putc(make8(*reg_data,0)); 
....................       reg_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                         unsigned int16 *input_data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(*input_data,1)); 
....................       modbus_serial_putc(make8(*input_data,0)); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(unsigned int8 address, unsigned int16 output_address, 
....................                                     unsigned int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
....................    modbus_serial_putc(make8(output_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(unsigned int8 address, unsigned int16 reg_address, 
....................                                         unsigned int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
....................    modbus_serial_putc(make8(reg_address,0)); 
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
....................    modbus_serial_putc(make8(reg_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(unsigned int8 address, unsigned int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(unsigned int8 address, unsigned int16 status, 
....................                                         unsigned int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(unsigned int8 address, unsigned int16 status, 
....................                                     unsigned int16 event_count, unsigned int16 message_count, 
....................                                     unsigned int8 *events, unsigned int8 events_len) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(unsigned int8 address, unsigned int16 start_address, 
....................                                         unsigned int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(unsigned int8 address, unsigned int16 start_address, 
....................                                             unsigned int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(unsigned int8 address, unsigned int8 slave_id, unsigned int1 run_status, 
....................                               unsigned int8 *data, unsigned int8 data_len) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    unsigned int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    unsigned int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(unsigned int8 address, unsigned int16 reference_address, 
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(unsigned int8 address, unsigned int8 data_len, 
....................                                                 unsigned int16 *data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(unsigned int8 address, unsigned int16 FIFO_len, unsigned int16 *data) 
.................... { 
....................    unsigned int8 i; 
....................    unsigned int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       func               function to respond to 
....................            exception   error              exception response to send 
.................... Output:    void 
.................... */ 
.................... void modbus_exception_rsp(unsigned int8 address, unsigned int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
....................    modbus_serial_putc(error); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... #endif 
.................... #endif //MODBUS_APP_LAYER_C 
....................  
.................... #endif 
....................  
....................  
.................... #include <umodbus.c> 
.................... void read_all_coils(int8 MODBUS_SLAVE_ADDRESS) 
.................... {   
....................    PC_MSG("Coils:\r\n"); 
*
01994:  MOVLW  38
01996:  MOVWF  FF6
01998:  MOVLW  0B
0199A:  MOVWF  FF7
0199C:  CALL   0E70
....................    if(!(modbus_read_coils(MODBUS_SLAVE_ADDRESS,0,8))) 
019A0:  MOVFF  DD,DF
019A4:  CLRF   xE1
019A6:  CLRF   xE0
019A8:  CLRF   xE3
019AA:  MOVLW  08
019AC:  MOVWF  xE2
019AE:  BRA    1810
019B0:  MOVF   01,F
019B2:  BNZ   1A20
....................    { 
....................       PC_MSG("Data: "); 
019B4:  MOVLW  42
019B6:  MOVWF  FF6
019B8:  MOVLW  0B
019BA:  MOVWF  FF7
019BC:  CALL   0E70
....................       /*Started at 1 since 0 is quantity of coils*/ 
....................       for(int i=1; i < (modbus_rx.len); ++i) 
019C0:  MOVLW  01
019C2:  MOVWF  xDE
019C4:  MOVF   20,W
019C6:  SUBWF  xDE,W
019C8:  BC    1A12
....................          fprintf(PC,"GET_ALL_COILS=%u:%X*", MODBUS_SLAVE_ADDRESS, modbus_rx.data[i]); 
019CA:  CLRF   03
019CC:  MOVF   xDE,W
019CE:  ADDLW  23
019D0:  MOVWF  FE9
019D2:  MOVLW  00
019D4:  ADDWFC 03,W
019D6:  MOVWF  FEA
019D8:  MOVFF  FEF,DF
019DC:  MOVLW  4A
019DE:  MOVWF  FF6
019E0:  MOVLW  0B
019E2:  MOVWF  FF7
019E4:  MOVLW  0E
019E6:  MOVWF  xEE
019E8:  RCALL  189E
019EA:  MOVFF  DD,EE
019EE:  MOVLW  1B
019F0:  MOVWF  xEF
019F2:  RCALL  18E6
019F4:  MOVLW  3A
019F6:  BTFSS  F9E.4
019F8:  BRA    19F6
019FA:  MOVWF  FAD
019FC:  MOVFF  DF,EE
01A00:  MOVLW  37
01A02:  MOVWF  xEF
01A04:  RCALL  1952
01A06:  MOVLW  2A
01A08:  BTFSS  F9E.4
01A0A:  BRA    1A08
01A0C:  MOVWF  FAD
01A0E:  INCF   xDE,F
01A10:  BRA    19C4
....................       PC_MSG("\r\n\r\n"); 
01A12:  MOVLW  60
01A14:  MOVWF  FF6
01A16:  MOVLW  0B
01A18:  MOVWF  FF7
01A1A:  CALL   0E70
....................    } 
01A1E:  BRA    1A52
....................    else 
....................    { 
....................       fprintf(PC,"ERR_ALL_COILS=%u:%X*",MODBUS_SLAVE_ADDRESS,modbus_rx.error); 
01A20:  MOVLW  66
01A22:  MOVWF  FF6
01A24:  MOVLW  0B
01A26:  MOVWF  FF7
01A28:  MOVLW  0E
01A2A:  MOVWF  xEE
01A2C:  RCALL  189E
01A2E:  MOVFF  DD,EE
01A32:  MOVLW  1B
01A34:  MOVWF  xEF
01A36:  RCALL  18E6
01A38:  MOVLW  3A
01A3A:  BTFSS  F9E.4
01A3C:  BRA    1A3A
01A3E:  MOVWF  FAD
01A40:  MOVFF  22,EE
01A44:  MOVLW  37
01A46:  MOVWF  xEF
01A48:  RCALL  1952
01A4A:  MOVLW  2A
01A4C:  BTFSS  F9E.4
01A4E:  BRA    1A4C
01A50:  MOVWF  FAD
....................    } 
01A52:  GOTO   2400 (RETURN)
.................... } 
....................  
.................... void read_all_inputs(int8 MODBUS_SLAVE_ADDRESS) 
.................... { 
....................    PC_MSG("Inputs:\r\n"); 
....................    if(!(modbus_read_discrete_input(MODBUS_SLAVE_ADDRESS,0,8))) 
....................    { 
....................       PC_MSG("Data: "); 
....................       /*Started at 1 since 0 is quantity of coils*/ 
....................       for(int i=1; i < (modbus_rx.len); ++i) 
....................          PC_DATA("%X ", modbus_rx.data[i]); 
....................       PC_MSG("\r\n\r\n"); 
....................    } 
....................    else 
....................    { 
....................       //PC_DATA("GET_ALL_COILSERRO", modbus_rx.error); 
....................    } 
.................... } 
....................  
....................  
.................... void read_temperatura(int8 MODBUS_SLAVE_ADDRESS) 
*
01EAA:  CLRF   xDE
.................... {   
....................    int8 cont = 0; 
....................     
....................    while (cont < 5) 
01EAC:  MOVF   xDE,W
01EAE:  SUBLW  04
01EB0:  BTFSS  FD8.0
01EB2:  BRA    2064
....................    { 
....................       if(!(modbus_read_holding_registers(MODBUS_SLAVE_ADDRESS,0,1))) 
01EB4:  MOVFF  DD,EE
01EB8:  CLRF   xF0
01EBA:  CLRF   xEF
01EBC:  CLRF   xF2
01EBE:  MOVLW  01
01EC0:  MOVWF  xF1
01EC2:  RCALL  1A56
01EC4:  MOVF   01,F
01EC6:  BTFSS  FD8.2
01EC8:  BRA    2056
....................       {   
....................          if (modbus_rx.len > 2){ 
01ECA:  MOVF   20,W
01ECC:  SUBLW  02
01ECE:  BTFSC  FD8.0
01ED0:  BRA    2056
....................             unsigned char sign; 
....................              
....................             int16 sensData = make16(modbus_rx.data[1],modbus_rx.data[2]); 
01ED2:  MOVFF  24,E1
01ED6:  MOVFF  25,E0
....................              
....................             // check negative  
....................             if (bit_test(sensData, 15)) 
01EDA:  BTFSS  xE1.7
01EDC:  BRA    1EFC
....................             {  
....................                sign = '-';  
01EDE:  MOVLW  2D
01EE0:  MOVWF  xDF
....................                sensData = ~sensData + 1;                 
01EE2:  MOVFF  E0,EE
01EE6:  COMF   xEE,F
01EE8:  MOVFF  E1,EF
01EEC:  COMF   xEF,F
01EEE:  MOVLW  01
01EF0:  ADDWF  xEE,W
01EF2:  MOVWF  xE0
01EF4:  MOVLW  00
01EF6:  ADDWFC xEF,W
01EF8:  MOVWF  xE1
....................             } else  
01EFA:  BRA    1F00
....................                   sign = '+';  
01EFC:  MOVLW  2B
01EFE:  MOVWF  xDF
....................     
....................             int16 fract = 0;  
....................             int8 tmp = sensData&0xF;        // obtain the fractional part nibble                 
....................             float celsius = sensData >> 4 ;  // calculate the whole number part  
01F00:  CLRF   xE3
01F02:  CLRF   xE2
01F04:  MOVF   xE0,W
01F06:  ANDLW  0F
01F08:  MOVWF  xE4
01F0A:  RRCF   xE1,W
01F0C:  MOVWF  03
01F0E:  RRCF   xE0,W
01F10:  MOVWF  02
01F12:  RRCF   03,F
01F14:  RRCF   02,F
01F16:  RRCF   03,F
01F18:  RRCF   02,F
01F1A:  RRCF   03,F
01F1C:  RRCF   02,F
01F1E:  MOVLW  0F
01F20:  ANDWF  03,F
01F22:  MOVFF  02,EF
01F26:  MOVFF  03,F0
01F2A:  RCALL  1AE2
01F2C:  MOVFF  03,E8
01F30:  MOVFF  02,E7
01F34:  MOVFF  01,E6
01F38:  MOVFF  00,E5
....................               
....................             if (tmp == 0xFF)  
01F3C:  INCFSZ xE4,W
01F3E:  BRA    1F72
....................                 celsius = celsius + 1;    // Calculate the fractional part             
01F40:  BCF    FD8.1
01F42:  MOVFF  E8,F1
01F46:  MOVFF  E7,F0
01F4A:  MOVFF  E6,EF
01F4E:  MOVFF  E5,EE
01F52:  CLRF   xF5
01F54:  CLRF   xF4
01F56:  CLRF   xF3
01F58:  MOVLW  7F
01F5A:  MOVWF  xF2
01F5C:  CALL   1036
01F60:  MOVFF  03,E8
01F64:  MOVFF  02,E7
01F68:  MOVFF  01,E6
01F6C:  MOVFF  00,E5
01F70:  BRA    1F86
....................             else  
....................                for (int i=0; i<tmp; i++)     
01F72:  CLRF   xE9
01F74:  MOVF   xE4,W
01F76:  SUBWF  xE9,W
01F78:  BC    1F86
....................                   fract = fract + 0625;     
01F7A:  MOVLW  95
01F7C:  ADDWF  xE2,F
01F7E:  MOVLW  01
01F80:  ADDWFC xE3,F
01F82:  INCF   xE9,F
01F84:  BRA    1F74
....................       
....................             // Testa se o valor da temperatura não é negativo 
....................             if (celsius > 1) 
01F86:  CLRF   xF1
01F88:  CLRF   xF0
01F8A:  CLRF   xEF
01F8C:  MOVLW  7F
01F8E:  MOVWF  xEE
01F90:  MOVFF  E8,F5
01F94:  MOVFF  E7,F4
01F98:  MOVFF  E6,F3
01F9C:  MOVFF  E5,F2
01FA0:  CALL   0FA8
01FA4:  BNC   2056
....................             {   
....................                float temp = celsius + (fract * 0.0001); 
01FA6:  MOVFF  E3,F0
01FAA:  MOVFF  E2,EF
01FAE:  RCALL  1AE2
01FB0:  MOVFF  03,FE
01FB4:  MOVFF  02,FD
01FB8:  MOVFF  01,FC
01FBC:  MOVFF  00,FB
01FC0:  MOVLW  17
01FC2:  MOVLB  1
01FC4:  MOVWF  x02
01FC6:  MOVLW  B7
01FC8:  MOVWF  x01
01FCA:  MOVLW  51
01FCC:  MOVWF  x00
01FCE:  MOVLW  71
01FD0:  MOVLB  0
01FD2:  MOVWF  xFF
01FD4:  RCALL  1B18
01FD6:  BCF    FD8.1
01FD8:  MOVFF  E8,F1
01FDC:  MOVFF  E7,F0
01FE0:  MOVFF  E6,EF
01FE4:  MOVFF  E5,EE
01FE8:  MOVFF  03,F5
01FEC:  MOVFF  02,F4
01FF0:  MOVFF  01,F3
01FF4:  MOVFF  00,F2
01FF8:  CALL   1036
01FFC:  MOVFF  03,ED
02000:  MOVFF  02,EC
02004:  MOVFF  01,EB
02008:  MOVFF  00,EA
....................                 
....................                fprintf(PC,"GET_TEMP=%u:%f*\r\n",MODBUS_SLAVE_ADDRESS,temp); 
0200C:  MOVLW  94
0200E:  MOVWF  FF6
02010:  MOVLW  0B
02012:  MOVWF  FF7
02014:  MOVLW  09
02016:  MOVWF  xEE
02018:  RCALL  189E
0201A:  MOVFF  DD,EE
0201E:  MOVLW  1B
02020:  MOVWF  xEF
02022:  RCALL  18E6
02024:  MOVLW  3A
02026:  BTFSS  F9E.4
02028:  BRA    2026
0202A:  MOVWF  FAD
0202C:  MOVLW  89
0202E:  MOVWF  FE9
02030:  MOVFF  ED,F1
02034:  MOVFF  EC,F0
02038:  MOVFF  EB,EF
0203C:  MOVFF  EA,EE
02040:  MOVLW  02
02042:  MOVWF  xF2
02044:  BRA    1D20
02046:  MOVLW  A2
02048:  MOVWF  FF6
0204A:  MOVLW  0B
0204C:  MOVWF  FF7
0204E:  MOVLW  03
02050:  MOVWF  xEE
02052:  RCALL  189E
....................                return; 
02054:  BRA    20A4
....................             } 
....................          } 
....................       } 
....................        
....................       cont += 1; 
02056:  MOVLW  01
02058:  ADDWF  xDE,F
....................       delay_ms(100); 
0205A:  MOVLW  64
0205C:  MOVWF  xEE
0205E:  CALL   0E48
02062:  BRA    1EAC
....................    } 
....................     
....................    fprintf(PC,"GET_TEMP=%u:ERRO_%X*\r\n", MODBUS_SLAVE_ADDRESS, modbus_rx.error); 
02064:  MOVLW  A6
02066:  MOVWF  FF6
02068:  MOVLW  0B
0206A:  MOVWF  FF7
0206C:  MOVLW  09
0206E:  MOVWF  xEE
02070:  RCALL  189E
02072:  MOVFF  DD,EE
02076:  MOVLW  1B
02078:  MOVWF  xEF
0207A:  RCALL  18E6
0207C:  MOVLW  B1
0207E:  MOVWF  FF6
02080:  MOVLW  0B
02082:  MOVWF  FF7
02084:  MOVLW  06
02086:  MOVWF  xEE
02088:  RCALL  189E
0208A:  MOVFF  22,EE
0208E:  MOVLW  37
02090:  MOVWF  xEF
02092:  RCALL  1952
02094:  MOVLW  B9
02096:  MOVWF  FF6
02098:  MOVLW  0B
0209A:  MOVWF  FF7
0209C:  MOVLW  03
0209E:  MOVWF  xEE
020A0:  CALL   189E
020A4:  GOTO   244A (RETURN)
.................... } 
....................  
.................... void read_vitais(int8 MODBUS_SLAVE_ADDRESS) 
*
0214E:  CLRF   xDE
.................... {   
....................    int8 cont = 0; 
....................     
....................    while (cont < 5) 
02150:  MOVF   xDE,W
02152:  SUBLW  04
02154:  BNC   21CA
....................    { 
....................       if(!(modbus_read_holding_registers(MODBUS_SLAVE_ADDRESS,1,1))) 
02156:  MOVFF  DD,EE
0215A:  CLRF   xF0
0215C:  MOVLW  01
0215E:  MOVWF  xEF
02160:  CLRF   xF2
02162:  MOVWF  xF1
02164:  RCALL  1A56
02166:  MOVF   01,F
02168:  BNZ   21BC
....................       { 
....................          if (modbus_rx.len > 2){ 
0216A:  MOVF   20,W
0216C:  SUBLW  02
0216E:  BC    21BC
....................             int16 BPM = make16(modbus_rx.data[1],modbus_rx.data[2]); 
02170:  MOVFF  24,E0
02174:  MOVFF  25,DF
....................              
....................             fprintf(PC,"GET_BPM=%u:%lu*\r\n",MODBUS_SLAVE_ADDRESS,BPM); 
02178:  MOVLW  BE
0217A:  MOVWF  FF6
0217C:  MOVLW  0B
0217E:  MOVWF  FF7
02180:  MOVLW  08
02182:  MOVWF  xEE
02184:  CALL   189E
02188:  MOVFF  DD,EE
0218C:  MOVLW  1B
0218E:  MOVWF  xEF
02190:  CALL   18E6
02194:  MOVLW  3A
02196:  BTFSS  F9E.4
02198:  BRA    2196
0219A:  MOVWF  FAD
0219C:  MOVLW  10
0219E:  MOVWF  FE9
021A0:  MOVFF  E0,E2
021A4:  MOVFF  DF,E1
021A8:  BRA    20A8
021AA:  MOVLW  CC
021AC:  MOVWF  FF6
021AE:  MOVLW  0B
021B0:  MOVWF  FF7
021B2:  MOVLW  03
021B4:  MOVWF  xEE
021B6:  CALL   189E
....................             return; 
021BA:  BRA    2212
....................          } 
....................       } 
....................        
....................       cont += 1; 
021BC:  MOVLW  01
021BE:  ADDWF  xDE,F
....................       delay_ms(100); 
021C0:  MOVLW  64
021C2:  MOVWF  xEE
021C4:  CALL   0E48
021C8:  BRA    2150
....................    } 
....................     
....................    fprintf(PC,"GET_BPM=%u:ERRO_%X*\r\n", MODBUS_SLAVE_ADDRESS, modbus_rx.error); 
021CA:  MOVLW  D0
021CC:  MOVWF  FF6
021CE:  MOVLW  0B
021D0:  MOVWF  FF7
021D2:  MOVLW  08
021D4:  MOVWF  xEE
021D6:  CALL   189E
021DA:  MOVFF  DD,EE
021DE:  MOVLW  1B
021E0:  MOVWF  xEF
021E2:  CALL   18E6
021E6:  MOVLW  DA
021E8:  MOVWF  FF6
021EA:  MOVLW  0B
021EC:  MOVWF  FF7
021EE:  MOVLW  06
021F0:  MOVWF  xEE
021F2:  CALL   189E
021F6:  MOVFF  22,EE
021FA:  MOVLW  37
021FC:  MOVWF  xEF
021FE:  CALL   1952
02202:  MOVLW  E2
02204:  MOVWF  FF6
02206:  MOVLW  0B
02208:  MOVWF  FF7
0220A:  MOVLW  03
0220C:  MOVWF  xEE
0220E:  CALL   189E
02212:  GOTO   2494 (RETURN)
.................... } 
....................  
.................... void read_all_holding(int8 MODBUS_SLAVE_ADDRESS) 
.................... { 
....................    PC_MSG("Holding Registers:\r\n"); 
02216:  MOVLW  E6
02218:  MOVWF  FF6
0221A:  MOVLW  0B
0221C:  MOVWF  FF7
0221E:  CALL   0E70
....................    if(!(modbus_read_holding_registers(MODBUS_SLAVE_ADDRESS,0,4))) 
02222:  MOVFF  DD,EE
02226:  CLRF   xF0
02228:  CLRF   xEF
0222A:  CLRF   xF2
0222C:  MOVLW  04
0222E:  MOVWF  xF1
02230:  RCALL  1A56
02232:  MOVF   01,F
02234:  BNZ   2284
....................    {   
....................       PC_MSG("Data: "); 
02236:  MOVLW  FC
02238:  MOVWF  FF6
0223A:  MOVLW  0B
0223C:  MOVWF  FF7
0223E:  CALL   0E70
....................       //Started at 1 since 0 is quantity of coils 
....................       for(int i=1; i < (modbus_rx.len); ++i){ 
02242:  MOVLW  01
02244:  MOVWF  xDE
02246:  MOVF   20,W
02248:  SUBWF  xDE,W
0224A:  BC    2276
....................          PC_DATA("%u ", modbus_rx.data[i]);     
0224C:  CLRF   03
0224E:  MOVF   xDE,W
02250:  ADDLW  23
02252:  MOVWF  FE9
02254:  MOVLW  00
02256:  ADDWFC 03,W
02258:  MOVWF  FEA
0225A:  MOVFF  FEF,DF
0225E:  MOVFF  DF,EE
02262:  MOVLW  1B
02264:  MOVWF  xEF
02266:  CALL   18E6
0226A:  MOVLW  20
0226C:  BTFSS  F9E.4
0226E:  BRA    226C
02270:  MOVWF  FAD
02272:  INCF   xDE,F
02274:  BRA    2246
....................       } 
....................        
....................       PC_MSG("\r\n\r\n"); 
02276:  MOVLW  04
02278:  MOVWF  FF6
0227A:  MOVLW  0C
0227C:  MOVWF  FF7
0227E:  CALL   0E70
....................    } 
02282:  BRA    22B0
....................    else 
....................    { 
....................       PC_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
02284:  MOVLW  0A
02286:  MOVWF  FF6
02288:  MOVLW  0C
0228A:  MOVWF  FF7
0228C:  MOVLW  0E
0228E:  MOVWF  xEE
02290:  CALL   189E
02294:  MOVFF  22,EE
02298:  MOVLW  37
0229A:  MOVWF  xEF
0229C:  CALL   1952
022A0:  MOVLW  1A
022A2:  MOVWF  FF6
022A4:  MOVLW  0C
022A6:  MOVWF  FF7
022A8:  MOVLW  08
022AA:  MOVWF  xEE
022AC:  CALL   189E
....................    } 
022B0:  GOTO   24DE (RETURN)
.................... } 
....................  
.................... void read_all_input_reg(int8 MODBUS_SLAVE_ADDRESS) 
.................... { 
....................    //PC_MSG("Input Registers:\r\n"); 
....................    if(!(modbus_read_input_registers(MODBUS_SLAVE_ADDRESS,0,2))) 
*
02350:  MOVFF  DD,DF
02354:  CLRF   xE1
02356:  CLRF   xE0
02358:  CLRF   xE3
0235A:  MOVLW  02
0235C:  MOVWF  xE2
0235E:  BRA    22B4
02360:  MOVF   01,F
02362:  BNZ   23B0
....................    { 
....................       PC_MSG("Data: "); 
02364:  MOVLW  24
02366:  MOVWF  FF6
02368:  MOVLW  0C
0236A:  MOVWF  FF7
0236C:  CALL   0E70
....................       /*Started at 1 since 0 is quantity of coils*/ 
....................       for(int i=1; i < (modbus_rx.len); ++i) 
02370:  MOVLW  01
02372:  MOVWF  xDE
02374:  MOVF   20,W
02376:  SUBWF  xDE,W
02378:  BC    23A4
....................          PC_DATA("%X ", modbus_rx.data[i]); 
0237A:  CLRF   03
0237C:  MOVF   xDE,W
0237E:  ADDLW  23
02380:  MOVWF  FE9
02382:  MOVLW  00
02384:  ADDWFC 03,W
02386:  MOVWF  FEA
02388:  MOVFF  FEF,DF
0238C:  MOVFF  DF,EE
02390:  MOVLW  37
02392:  MOVWF  xEF
02394:  CALL   1952
02398:  MOVLW  20
0239A:  BTFSS  F9E.4
0239C:  BRA    239A
0239E:  MOVWF  FAD
023A0:  INCF   xDE,F
023A2:  BRA    2374
....................       PC_MSG("\r\n\r\n"); 
023A4:  MOVLW  2C
023A6:  MOVWF  FF6
023A8:  MOVLW  0C
023AA:  MOVWF  FF7
023AC:  CALL   0E70
....................    } 
....................    else 
....................    { 
....................       //PC_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
....................    } 
023B0:  GOTO   2528 (RETURN)
.................... } 
....................  
.................... void write_coil(int8 MODBUS_SLAVE_ADDRESS) 
.................... { 
....................    PC_MSG("Writing Single Coil:\r\n"); 
....................    if(!(modbus_write_single_coil(MODBUS_SLAVE_ADDRESS,6,TRUE))) 
....................    { 
....................       PC_MSG("Data: "); 
....................       for(int i=0; i < (modbus_rx.len); ++i) 
....................          PC_DATA("%X ", modbus_rx.data[i]); 
....................       PC_MSG("\r\n\r\n"); 
....................    } 
....................    else 
....................    { 
....................       PC_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
....................    } 
.................... } 
....................  
.................... void write_reg(int8 MODBUS_SLAVE_ADDRESS) 
.................... { 
....................    PC_MSG("Writing Single Register:\r\n"); 
....................    if(!(modbus_write_single_register(MODBUS_SLAVE_ADDRESS,3,0x4444))) 
....................    { 
....................       PC_MSG("Data: "); 
....................       for(int i=0; i < (modbus_rx.len); ++i) 
....................          PC_DATA("%X ", modbus_rx.data[i]); 
....................       PC_MSG("\r\n\r\n"); 
....................    } 
....................    else 
....................    { 
....................       PC_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
....................    } 
.................... } 
....................  
.................... void write_coils(int8 MODBUS_SLAVE_ADDRESS) 
.................... { 
....................    int8 coils[1] = { 0x50 }; 
....................    PC_MSG("Writing Multiple Coils:\r\n"); 
....................    if(!(modbus_write_multiple_coils(MODBUS_SLAVE_ADDRESS,0,8,coils))) 
....................    { 
....................       PC_MSG("Data: "); 
....................       for(int i=0; i < (modbus_rx.len); ++i) 
....................          PC_DATA("%X ", modbus_rx.data[i]); 
....................       PC_MSG("\r\n\r\n"); 
....................    } 
....................    else 
....................    { 
....................       PC_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
....................    } 
.................... } 
....................  
.................... void write_regs(int8 MODBUS_SLAVE_ADDRESS) 
.................... { 
....................    int16 reg_array[2] = {0x1111, 0x2222}; 
....................    PC_MSG("Writing Multiple Registers:\r\n"); 
....................    if(!(modbus_write_multiple_registers(MODBUS_SLAVE_ADDRESS,0,2,reg_array))) 
....................    { 
....................       PC_MSG("Data: "); 
....................       for(int i=0; i < (modbus_rx.len); ++i) 
....................          PC_DATA("%X ", modbus_rx.data[i]); 
....................       PC_MSG("\r\n\r\n"); 
....................    } 
....................    else 
....................    { 
....................       PC_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
....................    } 
.................... } 
....................  
.................... void unknown_func(int8 MODBUS_SLAVE_ADDRESS) 
.................... { 
....................    PC_MSG("Trying unknown function\r\n"); 
....................    PC_MSG("Diagnostic:\r\n"); 
....................    if(!(modbus_diagnostics(MODBUS_SLAVE_ADDRESS,0,0))) 
....................    { 
....................       PC_MSG("Data:"); 
....................       for(int i=0; i < (modbus_rx.len); ++i) 
....................          PC_DATA("%X ", modbus_rx.data[i]); 
....................       PC_MSG("\r\n\r\n"); 
....................    } 
....................    else 
....................    { 
....................       PC_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
....................    } 
.................... } 
....................  
.................... #include <userial.c> 
.................... char received[20];         // Armazena os dados recebidos na serial 
.................... char tmp[20];              // Armazena dados temporários  
....................  
.................... char comando[4];           // Armazena o tipo do comando 
.................... char param[18];            // Armazena o valor do parametro 
.................... char endereco[4];          // Armazena o numero do parametro 
.................... char valor[10];            // Armazena o valor a ser tratado 
....................  
.................... // Bloco responsáveis por modificar dados 
.................... void tratar_SET() 
.................... {   
....................    tmp = "RESET"; 
*
01314:  CLRF   FEA
01316:  MOVLW  80
01318:  MOVWF  FE9
0131A:  MOVFF  FF2,D8
0131E:  BCF    FF2.7
01320:  MOVLW  00
01322:  CALL   08E6
01326:  TBLRD*-
01328:  TBLRD*+
0132A:  MOVF   FF5,W
0132C:  MOVWF  FEE
0132E:  IORLW  00
01330:  BNZ   1328
01332:  BTFSC  xD8.7
01334:  BSF    FF2.7
....................    if (!strcmp(tmp,param)) 
01336:  CLRF   xDE
01338:  MOVLW  80
0133A:  MOVWF  xDD
0133C:  CLRF   xE0
0133E:  MOVLW  98
01340:  MOVWF  xDF
01342:  RCALL  12A0
01344:  MOVF   01,F
01346:  BNZ   135A
....................    {          
....................       fprintf(PC,"SET_RESET=1:OK*"); 
01348:  MOVLW  8C
0134A:  MOVWF  FF6
0134C:  MOVLW  0D
0134E:  MOVWF  FF7
01350:  RCALL  0E70
....................       delay_ms(200); 
01352:  MOVLW  C8
01354:  MOVWF  xEE
01356:  RCALL  0E48
....................       reset_cpu(); 
01358:  RESET
....................    } 
0135A:  GOTO   147A (RETURN)
.................... } 
....................  
.................... // Bloco responsáveis pela leitura dos dados 
.................... void tratar_GET() 
.................... { 
....................    tmp = "ALL_COILS"; 
*
023B4:  CLRF   FEA
023B6:  MOVLW  80
023B8:  MOVWF  FE9
023BA:  MOVFF  FF2,DD
023BE:  BCF    FF2.7
023C0:  MOVLW  00
023C2:  CALL   0906
023C6:  TBLRD*-
023C8:  TBLRD*+
023CA:  MOVF   FF5,W
023CC:  MOVWF  FEE
023CE:  IORLW  00
023D0:  BNZ   23C8
023D2:  BTFSC  xDD.7
023D4:  BSF    FF2.7
....................    if (!strcmp(tmp,param)) 
023D6:  CLRF   xDE
023D8:  MOVLW  80
023DA:  MOVWF  xDD
023DC:  CLRF   xE0
023DE:  MOVLW  98
023E0:  MOVWF  xDF
023E2:  CALL   12A0
023E6:  MOVF   01,F
023E8:  BNZ   2400
....................    {          
....................       int add = atoi(endereco); 
023EA:  CLRF   xDE
023EC:  MOVLW  AA
023EE:  MOVWF  xDD
023F0:  CALL   14CA
023F4:  MOVFF  01,D8
....................       read_all_coils(add); 
023F8:  MOVFF  D8,DD
023FC:  GOTO   1994
....................    } 
....................     
....................    tmp = "TEMP"; 
02400:  CLRF   FEA
02402:  MOVLW  80
02404:  MOVWF  FE9
02406:  MOVFF  FF2,DD
0240A:  BCF    FF2.7
0240C:  MOVLW  00
0240E:  CALL   092A
02412:  TBLRD*-
02414:  TBLRD*+
02416:  MOVF   FF5,W
02418:  MOVWF  FEE
0241A:  IORLW  00
0241C:  BNZ   2414
0241E:  BTFSC  xDD.7
02420:  BSF    FF2.7
....................    if (!strcmp(tmp,param)) 
02422:  CLRF   xDE
02424:  MOVLW  80
02426:  MOVWF  xDD
02428:  CLRF   xE0
0242A:  MOVLW  98
0242C:  MOVWF  xDF
0242E:  CALL   12A0
02432:  MOVF   01,F
02434:  BNZ   244A
....................    {          
....................       int add = atoi(endereco); 
02436:  CLRF   xDE
02438:  MOVLW  AA
0243A:  MOVWF  xDD
0243C:  CALL   14CA
02440:  MOVFF  01,D9
....................       read_temperatura(add); 
02444:  MOVFF  D9,DD
02448:  BRA    1EAA
....................    } 
....................     
....................    tmp = "BPM"; 
0244A:  CLRF   FEA
0244C:  MOVLW  80
0244E:  MOVWF  FE9
02450:  MOVFF  FF2,DD
02454:  BCF    FF2.7
02456:  MOVLW  00
02458:  CALL   094A
0245C:  TBLRD*-
0245E:  TBLRD*+
02460:  MOVF   FF5,W
02462:  MOVWF  FEE
02464:  IORLW  00
02466:  BNZ   245E
02468:  BTFSC  xDD.7
0246A:  BSF    FF2.7
....................    if (!strcmp(tmp,param)) 
0246C:  CLRF   xDE
0246E:  MOVLW  80
02470:  MOVWF  xDD
02472:  CLRF   xE0
02474:  MOVLW  98
02476:  MOVWF  xDF
02478:  CALL   12A0
0247C:  MOVF   01,F
0247E:  BNZ   2494
....................    {          
....................       int add = atoi(endereco); 
02480:  CLRF   xDE
02482:  MOVLW  AA
02484:  MOVWF  xDD
02486:  CALL   14CA
0248A:  MOVFF  01,DA
....................       read_vitais(add); 
0248E:  MOVFF  DA,DD
02492:  BRA    214E
....................    } 
....................     
....................    tmp = "ALL"; 
02494:  CLRF   FEA
02496:  MOVLW  80
02498:  MOVWF  FE9
0249A:  MOVFF  FF2,DD
0249E:  BCF    FF2.7
024A0:  MOVLW  00
024A2:  CALL   0968
024A6:  TBLRD*-
024A8:  TBLRD*+
024AA:  MOVF   FF5,W
024AC:  MOVWF  FEE
024AE:  IORLW  00
024B0:  BNZ   24A8
024B2:  BTFSC  xDD.7
024B4:  BSF    FF2.7
....................    if (!strcmp(tmp,param)) 
024B6:  CLRF   xDE
024B8:  MOVLW  80
024BA:  MOVWF  xDD
024BC:  CLRF   xE0
024BE:  MOVLW  98
024C0:  MOVWF  xDF
024C2:  CALL   12A0
024C6:  MOVF   01,F
024C8:  BNZ   24DE
....................    { 
....................       int add = atoi(endereco); 
024CA:  CLRF   xDE
024CC:  MOVLW  AA
024CE:  MOVWF  xDD
024D0:  CALL   14CA
024D4:  MOVFF  01,DB
....................       read_all_holding(add); 
024D8:  MOVFF  DB,DD
024DC:  BRA    2216
....................    } 
....................     
....................    tmp = "INPUTS"; 
024DE:  CLRF   FEA
024E0:  MOVLW  80
024E2:  MOVWF  FE9
024E4:  MOVFF  FF2,DD
024E8:  BCF    FF2.7
024EA:  MOVLW  00
024EC:  CALL   0986
024F0:  TBLRD*-
024F2:  TBLRD*+
024F4:  MOVF   FF5,W
024F6:  MOVWF  FEE
024F8:  IORLW  00
024FA:  BNZ   24F2
024FC:  BTFSC  xDD.7
024FE:  BSF    FF2.7
....................    if (!strcmp(tmp,param)) 
02500:  CLRF   xDE
02502:  MOVLW  80
02504:  MOVWF  xDD
02506:  CLRF   xE0
02508:  MOVLW  98
0250A:  MOVWF  xDF
0250C:  CALL   12A0
02510:  MOVF   01,F
02512:  BNZ   2528
....................    {          
....................       int add = atoi(endereco); 
02514:  CLRF   xDE
02516:  MOVLW  AA
02518:  MOVWF  xDD
0251A:  CALL   14CA
0251E:  MOVFF  01,DC
....................       read_all_input_reg(add); 
02522:  MOVFF  DC,DD
02526:  BRA    2350
....................    } 
02528:  GOTO   25EA (RETURN)
....................     
.................... } 
....................  
.................... // Procedimento realiza o tratamento de Inserções 
.................... void comando_set() 
*
0135E:  CLRF   xD6
01360:  MOVLW  04
01362:  MOVWF  xD7
.................... {   
....................    int i = 0; 
....................    int inicio = 4; 
....................    while (!(received[inicio] == '=')) 
01364:  CLRF   03
01366:  MOVF   xD7,W
01368:  ADDLW  6C
0136A:  MOVWF  FE9
0136C:  MOVLW  00
0136E:  ADDWFC 03,W
01370:  MOVWF  FEA
01372:  MOVF   FEF,W
01374:  SUBLW  3D
01376:  BZ    13AC
....................    { 
....................       param[i] = received[inicio]; 
01378:  CLRF   03
0137A:  MOVF   xD6,W
0137C:  ADDLW  98
0137E:  MOVWF  01
01380:  MOVLW  00
01382:  ADDWFC 03,F
01384:  MOVFF  03,D9
01388:  CLRF   03
0138A:  MOVF   xD7,W
0138C:  ADDLW  6C
0138E:  MOVWF  FE9
01390:  MOVLW  00
01392:  ADDWFC 03,W
01394:  MOVWF  FEA
01396:  MOVFF  FEF,DA
0139A:  MOVFF  D9,FEA
0139E:  MOVFF  01,FE9
013A2:  MOVFF  DA,FEF
....................       i++; 
013A6:  INCF   xD6,F
....................       inicio++; 
013A8:  INCF   xD7,F
013AA:  BRA    1364
....................    }   param[i] = '\0'; 
013AC:  CLRF   03
013AE:  MOVF   xD6,W
013B0:  ADDLW  98
013B2:  MOVWF  FE9
013B4:  MOVLW  00
013B6:  ADDWFC 03,W
013B8:  MOVWF  FEA
013BA:  CLRF   FEF
....................  
....................    i = 0; 
013BC:  CLRF   xD6
....................    inicio = inicio+1; 
013BE:  MOVLW  01
013C0:  ADDWF  xD7,F
....................    while (!(received[inicio] == ':')) 
013C2:  CLRF   03
013C4:  MOVF   xD7,W
013C6:  ADDLW  6C
013C8:  MOVWF  FE9
013CA:  MOVLW  00
013CC:  ADDWFC 03,W
013CE:  MOVWF  FEA
013D0:  MOVF   FEF,W
013D2:  SUBLW  3A
013D4:  BZ    140A
....................    { 
....................       endereco[i] = received[inicio]; 
013D6:  CLRF   03
013D8:  MOVF   xD6,W
013DA:  ADDLW  AA
013DC:  MOVWF  01
013DE:  MOVLW  00
013E0:  ADDWFC 03,F
013E2:  MOVFF  03,D9
013E6:  CLRF   03
013E8:  MOVF   xD7,W
013EA:  ADDLW  6C
013EC:  MOVWF  FE9
013EE:  MOVLW  00
013F0:  ADDWFC 03,W
013F2:  MOVWF  FEA
013F4:  MOVFF  FEF,DA
013F8:  MOVFF  D9,FEA
013FC:  MOVFF  01,FE9
01400:  MOVFF  DA,FEF
....................       i++; 
01404:  INCF   xD6,F
....................       inicio++; 
01406:  INCF   xD7,F
01408:  BRA    13C2
....................    } endereco[i] = '\0'; 
0140A:  CLRF   03
0140C:  MOVF   xD6,W
0140E:  ADDLW  AA
01410:  MOVWF  FE9
01412:  MOVLW  00
01414:  ADDWFC 03,W
01416:  MOVWF  FEA
01418:  CLRF   FEF
....................  
....................    i = 0; 
0141A:  CLRF   xD6
....................    inicio = inicio+1; 
0141C:  MOVLW  01
0141E:  ADDWF  xD7,F
....................    while (!(received[inicio] == '*')) 
01420:  CLRF   03
01422:  MOVF   xD7,W
01424:  ADDLW  6C
01426:  MOVWF  FE9
01428:  MOVLW  00
0142A:  ADDWFC 03,W
0142C:  MOVWF  FEA
0142E:  MOVF   FEF,W
01430:  SUBLW  2A
01432:  BZ    1468
....................    { 
....................       valor[i] = received[inicio]; 
01434:  CLRF   03
01436:  MOVF   xD6,W
01438:  ADDLW  AE
0143A:  MOVWF  01
0143C:  MOVLW  00
0143E:  ADDWFC 03,F
01440:  MOVFF  03,D9
01444:  CLRF   03
01446:  MOVF   xD7,W
01448:  ADDLW  6C
0144A:  MOVWF  FE9
0144C:  MOVLW  00
0144E:  ADDWFC 03,W
01450:  MOVWF  FEA
01452:  MOVFF  FEF,DA
01456:  MOVFF  D9,FEA
0145A:  MOVFF  01,FE9
0145E:  MOVFF  DA,FEF
....................       i++; 
01462:  INCF   xD6,F
....................       inicio++; 
01464:  INCF   xD7,F
01466:  BRA    1420
....................    } valor[i] = '\0'; 
01468:  CLRF   03
0146A:  MOVF   xD6,W
0146C:  ADDLW  AE
0146E:  MOVWF  FE9
01470:  MOVLW  00
01472:  ADDWFC 03,W
01474:  MOVWF  FEA
01476:  CLRF   FEF
....................     
....................    tratar_SET(); 
01478:  BRA    1314
0147A:  GOTO   2636 (RETURN)
.................... } 
....................  
.................... // Procedimento realiza o tratamento de Solicitações 
.................... void comando_get() 
*
0252C:  CLRF   xD6
0252E:  MOVLW  04
02530:  MOVWF  xD7
.................... { 
....................    int i = 0; 
....................    int inicio = 4; 
....................    while (!(received[inicio] == '=')) 
02532:  CLRF   03
02534:  MOVF   xD7,W
02536:  ADDLW  6C
02538:  MOVWF  FE9
0253A:  MOVLW  00
0253C:  ADDWFC 03,W
0253E:  MOVWF  FEA
02540:  MOVF   FEF,W
02542:  SUBLW  3D
02544:  BZ    257A
....................    { 
....................       param[i] = received[inicio]; 
02546:  CLRF   03
02548:  MOVF   xD6,W
0254A:  ADDLW  98
0254C:  MOVWF  01
0254E:  MOVLW  00
02550:  ADDWFC 03,F
02552:  MOVFF  03,D9
02556:  CLRF   03
02558:  MOVF   xD7,W
0255A:  ADDLW  6C
0255C:  MOVWF  FE9
0255E:  MOVLW  00
02560:  ADDWFC 03,W
02562:  MOVWF  FEA
02564:  MOVFF  FEF,DA
02568:  MOVFF  D9,FEA
0256C:  MOVFF  01,FE9
02570:  MOVFF  DA,FEF
....................       i++; 
02574:  INCF   xD6,F
....................       inicio++; 
02576:  INCF   xD7,F
02578:  BRA    2532
....................    }   param[i] = '\0'; 
0257A:  CLRF   03
0257C:  MOVF   xD6,W
0257E:  ADDLW  98
02580:  MOVWF  FE9
02582:  MOVLW  00
02584:  ADDWFC 03,W
02586:  MOVWF  FEA
02588:  CLRF   FEF
....................  
....................    i = 0; 
0258A:  CLRF   xD6
....................    inicio = inicio+1; 
0258C:  MOVLW  01
0258E:  ADDWF  xD7,F
....................    while (!(received[inicio] == ':')) 
02590:  CLRF   03
02592:  MOVF   xD7,W
02594:  ADDLW  6C
02596:  MOVWF  FE9
02598:  MOVLW  00
0259A:  ADDWFC 03,W
0259C:  MOVWF  FEA
0259E:  MOVF   FEF,W
025A0:  SUBLW  3A
025A2:  BZ    25D8
....................    { 
....................       endereco[i] = received[inicio]; 
025A4:  CLRF   03
025A6:  MOVF   xD6,W
025A8:  ADDLW  AA
025AA:  MOVWF  01
025AC:  MOVLW  00
025AE:  ADDWFC 03,F
025B0:  MOVFF  03,D9
025B4:  CLRF   03
025B6:  MOVF   xD7,W
025B8:  ADDLW  6C
025BA:  MOVWF  FE9
025BC:  MOVLW  00
025BE:  ADDWFC 03,W
025C0:  MOVWF  FEA
025C2:  MOVFF  FEF,DA
025C6:  MOVFF  D9,FEA
025CA:  MOVFF  01,FE9
025CE:  MOVFF  DA,FEF
....................       i++; 
025D2:  INCF   xD6,F
....................       inicio++; 
025D4:  INCF   xD7,F
025D6:  BRA    2590
....................    } endereco[i] = '\0'; 
025D8:  CLRF   03
025DA:  MOVF   xD6,W
025DC:  ADDLW  AA
025DE:  MOVWF  FE9
025E0:  MOVLW  00
025E2:  ADDWFC 03,W
025E4:  MOVWF  FEA
025E6:  CLRF   FEF
....................     
....................    tratar_GET();    
025E8:  BRA    23B4
025EA:  GOTO   266E (RETURN)
.................... } 
....................  
.................... //   Usado para decodificar o comando enviado 
.................... void decodifica() 
.................... { 
....................    char comando[4];     // Armazena o tipo do comando 
....................    char tmp[20];        // Variável armazena temporariamente os dados a serem comparados com o da serial; 
....................     
....................    comando[0] = received[0]; 
025EE:  MOVFF  6C,BE
....................    comando[1] = received[1]; 
025F2:  MOVFF  6D,BF
....................    comando[2] = received[2]; 
025F6:  MOVFF  6E,C0
....................    comando[3] = '\0'; 
025FA:  CLRF   xC1
....................     
....................    tmp = "SET"; // Se for comando SET 
025FC:  CLRF   FEA
025FE:  MOVLW  C2
02600:  MOVWF  FE9
02602:  MOVFF  FF2,D6
02606:  BCF    FF2.7
02608:  MOVLW  00
0260A:  CALL   09A8
0260E:  TBLRD*-
02610:  TBLRD*+
02612:  MOVF   FF5,W
02614:  MOVWF  FEE
02616:  IORLW  00
02618:  BNZ   2610
0261A:  BTFSC  xD6.7
0261C:  BSF    FF2.7
....................    if (!strcmp(comando,tmp)){ comando_set(); } 
0261E:  CLRF   xDE
02620:  MOVLW  BE
02622:  MOVWF  xDD
02624:  CLRF   xE0
02626:  MOVLW  C2
02628:  MOVWF  xDF
0262A:  CALL   12A0
0262E:  MOVF   01,F
02630:  BTFSC  FD8.2
02632:  GOTO   135E
....................     
....................    tmp = "GET"; // Se for comando GET 
02636:  CLRF   FEA
02638:  MOVLW  C2
0263A:  MOVWF  FE9
0263C:  MOVFF  FF2,D6
02640:  BCF    FF2.7
02642:  MOVLW  00
02644:  CALL   09C6
02648:  TBLRD*-
0264A:  TBLRD*+
0264C:  MOVF   FF5,W
0264E:  MOVWF  FEE
02650:  IORLW  00
02652:  BNZ   264A
02654:  BTFSC  xD6.7
02656:  BSF    FF2.7
....................    if (!strcmp(comando,tmp)){ comando_get(); } 
02658:  CLRF   xDE
0265A:  MOVLW  BE
0265C:  MOVWF  xDD
0265E:  CLRF   xE0
02660:  MOVLW  C2
02662:  MOVWF  xDF
02664:  CALL   12A0
02668:  MOVF   01,F
0266A:  BTFSC  FD8.2
0266C:  BRA    252C
0266E:  GOTO   2722 (RETURN)
.................... } 
....................  
.................... /// Evento disparado ao receber dados na serial 
.................... void evt_serial() 
02672:  CLRF   xBB
02674:  CLRF   xBA
02676:  CLRF   xB9
02678:  CLRF   xB8
0267A:  CLRF   xBC
0267C:  MOVLW  01
0267E:  MOVWF  xBD
.................... {   
....................    float timeout = 0;            // Conta o tempo de timeout 
....................    int cont = 0;                 // Conta quantidade de caracteres recebidos 
....................    char tmp = '\1';              // Armazena o caractere recuperado 
....................     
....................    // Desabilita as interrupões 
....................    //disable_interrupts(int_rda); 
....................     
....................    // Enquanto não estourar o timeout ou não vir o caractere de finalização de mensagem '\r' 
....................    while((timeout<200) && (tmp != '*')) 
02680:  MOVFF  BB,F1
02684:  MOVFF  BA,F0
02688:  MOVFF  B9,EF
0268C:  MOVFF  B8,EE
02690:  CLRF   xF5
02692:  CLRF   xF4
02694:  MOVLW  48
02696:  MOVWF  xF3
02698:  MOVLW  86
0269A:  MOVWF  xF2
0269C:  CALL   0FA8
026A0:  BNC   270A
026A2:  MOVF   xBD,W
026A4:  SUBLW  2A
026A6:  BZ    270A
....................    { 
....................       if (kbhit()) 
026A8:  BTFSS  F9E.5
026AA:  BRA    26D2
....................       { 
....................          tmp  = getc(PC);          
026AC:  GOTO   101E
026B0:  MOVFF  01,BD
....................          received[cont] = tmp;          
026B4:  CLRF   03
026B6:  MOVF   xBC,W
026B8:  ADDLW  6C
026BA:  MOVWF  FE9
026BC:  MOVLW  00
026BE:  ADDWFC 03,W
026C0:  MOVWF  FEA
026C2:  MOVFF  BD,FEF
....................          cont++; 
026C6:  INCF   xBC,F
....................          timeout = 0; 
026C8:  CLRF   xBB
026CA:  CLRF   xBA
026CC:  CLRF   xB9
026CE:  CLRF   xB8
....................       }else{ 
026D0:  BRA    2708
....................          timeout = timeout + 0.01; 
026D2:  BCF    FD8.1
026D4:  MOVFF  BB,F1
026D8:  MOVFF  BA,F0
026DC:  MOVFF  B9,EF
026E0:  MOVFF  B8,EE
026E4:  MOVLW  0A
026E6:  MOVWF  xF5
026E8:  MOVLW  D7
026EA:  MOVWF  xF4
026EC:  MOVLW  23
026EE:  MOVWF  xF3
026F0:  MOVLW  78
026F2:  MOVWF  xF2
026F4:  CALL   1036
026F8:  MOVFF  03,BB
026FC:  MOVFF  02,BA
02700:  MOVFF  01,B9
02704:  MOVFF  00,B8
....................       } 
02708:  BRA    2680
....................    } 
....................     
....................    // Finaliza a string 
....................    received[cont] = '\0'; 
0270A:  CLRF   03
0270C:  MOVF   xBC,W
0270E:  ADDLW  6C
02710:  MOVWF  FE9
02712:  MOVLW  00
02714:  ADDWFC 03,W
02716:  MOVWF  FEA
02718:  CLRF   FEF
....................     
....................    // Verifica se possui o tamanho mínimo de um comando 
....................    if (cont > 6){ decodifica(); } 
0271A:  MOVF   xBC,W
0271C:  SUBLW  06
0271E:  BTFSS  FD8.0
02720:  BRA    25EE
02722:  GOTO   2794 (RETURN)
....................     
....................    // Habilita as interrupções 
....................    //enable_interrupts(int_rda);   
.................... } 
....................  
....................  
.................... void MotivoInicializacao(){    
....................  
....................    delay_ms(200); 
*
00E92:  MOVLW  C8
00E94:  MOVWF  xEE
00E96:  RCALL  0E48
....................  
....................    switch ( restart_cause() ) 
00E98:  MOVF   FD0,W
00E9A:  ANDLW  0F
00E9C:  BTFSS  FD0.4
00E9E:  MOVLW  00
00EA0:  BSF    FD0.0
00EA2:  BSF    FD0.1
00EA4:  BSF    FD0.4
00EA6:  BSF    FD8.3
00EA8:  BSF    FD8.4
00EAA:  ADDLW  F0
00EAC:  BC    0F30
00EAE:  ADDLW  10
00EB0:  GOTO   0F34
....................    { 
....................       case WDT_TIMEOUT: 
....................          PC_MSG("EVT_WDT_TIMEOUT=1:1*"); 
00EB4:  MOVLW  9C
00EB6:  MOVWF  FF6
00EB8:  MOVLW  0D
00EBA:  MOVWF  FF7
00EBC:  RCALL  0E70
....................          delay_ms(200); 
00EBE:  MOVLW  C8
00EC0:  MOVWF  xEE
00EC2:  RCALL  0E48
....................          break; 
00EC4:  BRA    0F30
....................       case WDT_FROM_SLEEP: 
....................          PC_MSG("EVT_WDT_SLEEP=1:1*"); 
00EC6:  MOVLW  B2
00EC8:  MOVWF  FF6
00ECA:  MOVLW  0D
00ECC:  MOVWF  FF7
00ECE:  RCALL  0E70
....................          delay_ms(200); 
00ED0:  MOVLW  C8
00ED2:  MOVWF  xEE
00ED4:  RCALL  0E48
....................          break; 
00ED6:  BRA    0F30
....................       case MCLR_FROM_RUN: 
....................          PC_MSG("EVT_MCLR_FROM_RUN=1:1*"); 
00ED8:  MOVLW  C6
00EDA:  MOVWF  FF6
00EDC:  MOVLW  0D
00EDE:  MOVWF  FF7
00EE0:  RCALL  0E70
....................          delay_ms(200); 
00EE2:  MOVLW  C8
00EE4:  MOVWF  xEE
00EE6:  RCALL  0E48
....................          break; 
00EE8:  BRA    0F30
....................       case BROWNOUT_RESTART: 
....................          PC_MSG("EVT_BROWNOUT_RESTART=1:1*"); 
00EEA:  MOVLW  DE
00EEC:  MOVWF  FF6
00EEE:  MOVLW  0D
00EF0:  MOVWF  FF7
00EF2:  RCALL  0E70
....................          delay_ms(200); 
00EF4:  MOVLW  C8
00EF6:  MOVWF  xEE
00EF8:  RCALL  0E48
....................          break; 
00EFA:  BRA    0F30
....................       case  MCLR_FROM_SLEEP: 
....................          PC_MSG("EVT_MCLR_FROM_SLEEP=1:1*"); 
00EFC:  MOVLW  F8
00EFE:  MOVWF  FF6
00F00:  MOVLW  0D
00F02:  MOVWF  FF7
00F04:  RCALL  0E70
....................          delay_ms(200); 
00F06:  MOVLW  C8
00F08:  MOVWF  xEE
00F0A:  RCALL  0E48
....................          break; 
00F0C:  BRA    0F30
....................       case  RESET_INSTRUCTION: 
....................          PC_MSG("EVT_RESET_INSTRUCTION=1:1*"); 
00F0E:  MOVLW  12
00F10:  MOVWF  FF6
00F12:  MOVLW  0E
00F14:  MOVWF  FF7
00F16:  RCALL  0E70
....................          delay_ms(200); 
00F18:  MOVLW  C8
00F1A:  MOVWF  xEE
00F1C:  RCALL  0E48
....................          break; 
00F1E:  BRA    0F30
....................       case  NORMAL_POWER_UP: 
....................          PC_MSG("EVT_NORMAL_POWER_UP=1:1*"); 
00F20:  MOVLW  2E
00F22:  MOVWF  FF6
00F24:  MOVLW  0E
00F26:  MOVWF  FF7
00F28:  RCALL  0E70
....................          delay_ms(200); 
00F2A:  MOVLW  C8
00F2C:  MOVWF  xEE
00F2E:  RCALL  0E48
....................          break; 
....................    } 
00F30:  GOTO   0F94 (RETURN)
.................... } 
....................  
.................... void initialize(){    
....................    MotivoInicializacao(); 
*
00F92:  BRA    0E92
....................  
....................    setup_adc_ports(NO_ANALOGS); 
00F94:  MOVLW  00
00F96:  MOVWF  F7E
00F98:  BCF    FC1.4
00F9A:  BCF    FC1.5
00F9C:  MOVF   F7F,W
00F9E:  ANDLW  E0
00FA0:  MOVWF  F7F
....................    modbus_init(); 
00FA2:  BRA    0F84
00FA4:  GOTO   278E (RETURN)
.................... } 
....................  
....................  
.................... #define LOADER_END   0x5FF 
.................... #include <bootloader.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                       BOOTLOADER.H                                //// 
.................... ////                                                                   //// 
.................... ////  This include file must be included by any application loaded     //// 
.................... ////  by the example bootloader (ex_bootloader.c).                     //// 
.................... ////                                                                   //// 
.................... ////  The directives in this file relocate the reset and interrupt     //// 
.................... ////  vectors as well as reserving space for the bootloader.           //// 
.................... ////                                                                   //// 
.................... ////  LOADER_END may need to be adjusted for a specific chip and       //// 
.................... ////  bootloader.  LOADER_END must be 1 minus a multiple of            //// 
.................... ////  FLASH_ERASE_SIZE.                                                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2013 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #ifndef __BOOTLOADER_H__ 
.................... #define __BOOTLOADER_H__ 
....................  
.................... #ifndef LOADER_END 
....................  #if defined(__PCM__) 
....................   #define LOADER_END 0x2FF 
....................  #elif defined(__PCH__) 
....................   #define FLASH_SIZE getenv("FLASH_ERASE_SIZE") 
....................   #if ((0x500 % FLASH_SIZE) == 0)         //IF 0x500 is even flash boundary 
....................    #define LOADER_END   0x4FF 
....................   #else                                  //ELSE, goto next even boundary 
....................    #define LOADER_END   ((0x500+FLASH_SIZE-(0x500 % FLASH_SIZE))-1) 
....................   #endif 
....................  #else 
....................   #error Bootloader only works with PCM or PCH compiler 
....................  #endif 
.................... #endif 
....................  
.................... #define LOADER_SIZE   LOADER_END 
....................  
.................... #ifndef BOOTLOADER_AT_START 
....................  #define BOOTLOADER_AT_START 
.................... #endif 
....................  
.................... #ifndef _bootloader 
....................  #if defined(__PCM__) 
....................   #build(reset=LOADER_END+1, interrupt=LOADER_END+5) 
....................  #elif defined(__PCH__) 
....................   #build(reset=LOADER_END+1, interrupt=LOADER_END+9) 
....................  #endif 
....................  
....................  #org 0, LOADER_END {} 
.................... #else 
....................  #ifdef __PCM__ 
....................   #if getenv("PROGRAM_MEMORY") <= 0x800 
....................    #org LOADER_END+3, (getenv("PROGRAM_MEMORY") - 1) {} 
....................   #else 
....................    #org LOADER_END+3, 0x7FF {} 
....................    #if getenv("PROGRAM_MEMORY") <= 0x1000 
....................     #org 0x800, (getenv("PROGRAM_MEMORY") - 1) {} 
....................    #else 
....................     #org 0x800, 0xFFF{} 
....................     #if getenv("PROGRAM_MEMORY") <= 0x1800 
....................      #org 0x1000, (getenv("PROGRAM_MEMORY") - 1) {} 
....................     #else 
....................      #org 0x1000, 0x17FF {} 
....................      #if getenv("PROGRAM_MEMORY") <= 0x2000 
....................       #org 0x1800, (getenv("PROGRAM_MEMORY") - 1) {} 
....................      #else 
....................       #org 0x1800, 0x1FFF {} 
....................       #if getenv("PROGRAM_MEMORY") <= 0x2800 
....................        #org 0x2000, (getenv("PROGRAM_MEMORY") - 1) {} 
....................       #else 
....................        #org 0x2000, 0x27FF {} 
....................        #if getenv("PROGRAM_MEMORY") <= 0x3000 
....................         #org 0x2800, (getenv("PROGRAM_MEMORY") - 1) {} 
....................        #else 
....................         #org 0x2800, 0x2FFF {} 
....................         #if getenv("PROGRAM_MEMORY") <= 0x3800 
....................          #org 0x3000, (getenv("PROGRAM_MEMORY") - 1) {} 
....................         #else 
....................          #org 0x3000, 0x37FF {} 
....................          #org 0x3800, 0x3FFF {} 
....................         #endif 
....................        #endif 
....................       #endif 
....................      #endif 
....................     #endif 
....................    #endif 
....................   #endif 
....................  #else 
....................   #if getenv("PROGRAM_MEMORY") <= 0x10000 
....................    #org LOADER_END+5, (getenv("PROGRAM_MEMORY") - 1) {} 
....................   #else 
....................    #org LOADER_END+5, 0xFFFE {} 
....................    #org 0x10000, (getenv("PROGRAM_MEMORY") - 1) {} 
....................   #endif 
....................  #endif 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... void main() 
*
02726:  CLRF   FF8
02728:  BCF    FD0.7
0272A:  BSF    07.7
0272C:  MOVLW  70
0272E:  MOVWF  FD3
02730:  BCF    F9B.6
02732:  BCF    F9B.7
02734:  MOVF   FD3,W
02736:  CLRF   17
02738:  BSF    FB8.3
0273A:  MOVLW  A0
0273C:  MOVWF  FAF
0273E:  MOVLW  01
02740:  MOVWF  FB0
02742:  MOVLW  A6
02744:  MOVWF  FAC
02746:  MOVLW  90
02748:  MOVWF  FAB
0274A:  BCF    1E.0
0274C:  CLRF   x64
0274E:  CLRF   x63
02750:  MOVLW  B5
02752:  MOVWF  FCD
02754:  CLRF   FCF
02756:  CLRF   FCE
02758:  BCF    F9E.0
0275A:  BSF    F9D.0
0275C:  BCF    F93.3
0275E:  BSF    F8A.3
02760:  BCF    1E.1
02762:  CLRF   x68
02764:  CLRF   x67
02766:  MOVLW  27
02768:  MOVWF  x66
0276A:  MOVLW  10
0276C:  MOVWF  x65
0276E:  CLRF   x69
02770:  MOVLW  00
02772:  MOVWF  F7E
02774:  BCF    FC1.4
02776:  BCF    FC1.5
02778:  MOVF   F7F,W
0277A:  ANDLW  E0
0277C:  MOVWF  F7F
0277E:  BCF    F79.5
02780:  BCF    F79.4
02782:  CLRF   F7A
02784:  CLRF   F7B
02786:  CLRF   18
02788:  CLRF   19
.................... {   
....................    initialize(); 
0278A:  GOTO   0F92
....................     
....................    // Loop principal 
....................    while(TRUE){      
....................       // Se houver alguma informação na serial 
....................       if (kbhit()){ 
0278E:  BTFSS  F9E.5
02790:  BRA    2794
....................          // Função responsável por receber os dados da serial 
....................          evt_serial(); 
02792:  BRA    2672
....................       } 
02794:  BRA    278E
....................        
....................       /*read_temperatura(1); 
....................       delay_ms(500); 
....................       read_vitais(2); 
....................       delay_ms(1000);*/ 
....................    } 
.................... } 
....................  
02796:  SLEEP 

Configuration Fuses:
   Word  1: C800   INTRC_IO FCMEN IESO
   Word  2: 1E18   PUT NOBROWNOUT BORV18 NOWDT WDT32768
   Word  3: 8F00   CCP2C1 PBADEN LPT1OSC HFOFST MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
