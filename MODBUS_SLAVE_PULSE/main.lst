CCS PCH C Compiler, Version 5.007, 61971               15-ago-16 14:57

               Filename:   \\192.168.25.2\storage\Repositório\LuisOtávio\RS485\MODBUS_SLAVE - PULSE\main.lst

               ROM used:   8048 bytes (12%)
                           Largest free fragment is 55948
               RAM used:   232 (6%) at main() level
                           292 (8%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 31

*
00600:  GOTO   23DE
*
00608:  MOVWF  04
0060A:  MOVFF  FD8,05
0060E:  MOVFF  FE0,06
00612:  MOVLB  0
00614:  MOVFF  FE9,0C
00618:  MOVFF  FEA,07
0061C:  MOVFF  FE1,08
00620:  MOVFF  FE2,09
00624:  MOVFF  FD9,0A
00628:  MOVFF  FDA,0B
0062C:  MOVFF  FF3,12
00630:  MOVFF  FF4,13
00634:  MOVFF  FFA,14
00638:  MOVFF  00,0E
0063C:  MOVFF  01,0F
00640:  MOVFF  02,10
00644:  MOVFF  03,11
00648:  BTFSS  F9D.0
0064A:  GOTO   0654
0064E:  BTFSC  F9E.0
00650:  GOTO   0904
00654:  BTFSS  FF2.4
00656:  GOTO   0660
0065A:  BTFSC  FF2.1
0065C:  GOTO   09E8
00660:  MOVFF  0E,00
00664:  MOVFF  0F,01
00668:  MOVFF  10,02
0066C:  MOVFF  11,03
00670:  MOVFF  0C,FE9
00674:  MOVFF  07,FEA
00678:  BSF    07.7
0067A:  MOVFF  08,FE1
0067E:  MOVFF  09,FE2
00682:  MOVFF  0A,FD9
00686:  MOVFF  0B,FDA
0068A:  MOVFF  12,FF3
0068E:  MOVFF  13,FF4
00692:  MOVFF  14,FFA
00696:  MOVF   04,W
00698:  MOVFF  06,FE0
0069C:  MOVFF  05,FD8
006A0:  RETFIE 0
.................... #include <main.h> 
.................... #include <hardware.h> 
.................... #include <18F26K80.h> 
.................... //////// Standard Header file for the PIC18F26K80 device //////////////// 
*
0090A:  BCF    F9E.0
0090C:  GOTO   0660
.................... #device PIC18F26K80 
*
006A2:  BTFSS  07.7
006A4:  BRA    06AC
006A6:  MOVFF  FF2,0D
006AA:  BCF    FF2.7
006AC:  CLRF   FF7
006AE:  ADDLW  C4
006B0:  MOVWF  FF6
006B2:  MOVLW  06
006B4:  ADDWFC FF7,F
006B6:  TBLRD*+
006B8:  MOVF   FF5,W
006BA:  BTFSS  07.7
006BC:  BRA    06C2
006BE:  BTFSC  0D.7
006C0:  BSF    FF2.7
006C2:  RETURN 0
006C4:  DATA 00,C1
006C6:  DATA 81,40
006C8:  DATA 01,C0
006CA:  DATA 80,41
006CC:  DATA 01,C0
006CE:  DATA 80,41
006D0:  DATA 00,C1
006D2:  DATA 81,40
006D4:  DATA 01,C0
006D6:  DATA 80,41
006D8:  DATA 00,C1
006DA:  DATA 81,40
006DC:  DATA 00,C1
006DE:  DATA 81,40
006E0:  DATA 01,C0
006E2:  DATA 80,41
006E4:  DATA 01,C0
006E6:  DATA 80,41
006E8:  DATA 00,C1
006EA:  DATA 81,40
006EC:  DATA 00,C1
006EE:  DATA 81,40
006F0:  DATA 01,C0
006F2:  DATA 80,41
006F4:  DATA 00,C1
006F6:  DATA 81,40
006F8:  DATA 01,C0
006FA:  DATA 80,41
006FC:  DATA 01,C0
006FE:  DATA 80,41
00700:  DATA 00,C1
00702:  DATA 81,40
00704:  DATA 01,C0
00706:  DATA 80,41
00708:  DATA 00,C1
0070A:  DATA 81,40
0070C:  DATA 00,C1
0070E:  DATA 81,40
00710:  DATA 01,C0
00712:  DATA 80,41
00714:  DATA 00,C1
00716:  DATA 81,40
00718:  DATA 01,C0
0071A:  DATA 80,41
0071C:  DATA 01,C0
0071E:  DATA 80,41
00720:  DATA 00,C1
00722:  DATA 81,40
00724:  DATA 00,C1
00726:  DATA 81,40
00728:  DATA 01,C0
0072A:  DATA 80,41
0072C:  DATA 01,C0
0072E:  DATA 80,41
00730:  DATA 00,C1
00732:  DATA 81,40
00734:  DATA 01,C0
00736:  DATA 80,41
00738:  DATA 00,C1
0073A:  DATA 81,40
0073C:  DATA 00,C1
0073E:  DATA 81,40
00740:  DATA 01,C0
00742:  DATA 80,41
00744:  DATA 01,C0
00746:  DATA 80,41
00748:  DATA 00,C1
0074A:  DATA 81,40
0074C:  DATA 00,C1
0074E:  DATA 81,40
00750:  DATA 01,C0
00752:  DATA 80,41
00754:  DATA 00,C1
00756:  DATA 81,40
00758:  DATA 01,C0
0075A:  DATA 80,41
0075C:  DATA 01,C0
0075E:  DATA 80,41
00760:  DATA 00,C1
00762:  DATA 81,40
00764:  DATA 00,C1
00766:  DATA 81,40
00768:  DATA 01,C0
0076A:  DATA 80,41
0076C:  DATA 01,C0
0076E:  DATA 80,41
00770:  DATA 00,C1
00772:  DATA 81,40
00774:  DATA 01,C0
00776:  DATA 80,41
00778:  DATA 00,C1
0077A:  DATA 81,40
0077C:  DATA 00,C1
0077E:  DATA 81,40
00780:  DATA 01,C0
00782:  DATA 80,41
00784:  DATA 00,C1
00786:  DATA 81,40
00788:  DATA 01,C0
0078A:  DATA 80,41
0078C:  DATA 01,C0
0078E:  DATA 80,41
00790:  DATA 00,C1
00792:  DATA 81,40
00794:  DATA 01,C0
00796:  DATA 80,41
00798:  DATA 00,C1
0079A:  DATA 81,40
0079C:  DATA 00,C1
0079E:  DATA 81,40
007A0:  DATA 01,C0
007A2:  DATA 80,41
007A4:  DATA 01,C0
007A6:  DATA 80,41
007A8:  DATA 00,C1
007AA:  DATA 81,40
007AC:  DATA 00,C1
007AE:  DATA 81,40
007B0:  DATA 01,C0
007B2:  DATA 80,41
007B4:  DATA 00,C1
007B6:  DATA 81,40
007B8:  DATA 01,C0
007BA:  DATA 80,41
007BC:  DATA 01,C0
007BE:  DATA 80,41
007C0:  DATA 00,C1
007C2:  DATA 81,40
007C4:  BTFSS  07.7
007C6:  BRA    07CE
007C8:  MOVFF  FF2,0D
007CC:  BCF    FF2.7
007CE:  CLRF   FF7
007D0:  ADDLW  E6
007D2:  MOVWF  FF6
007D4:  MOVLW  07
007D6:  ADDWFC FF7,F
007D8:  TBLRD*+
007DA:  MOVF   FF5,W
007DC:  BTFSS  07.7
007DE:  BRA    07E4
007E0:  BTFSC  0D.7
007E2:  BSF    FF2.7
007E4:  RETURN 0
007E6:  DATA 00,C0
007E8:  DATA C1,01
007EA:  DATA C3,03
007EC:  DATA 02,C2
007EE:  DATA C6,06
007F0:  DATA 07,C7
007F2:  DATA 05,C5
007F4:  DATA C4,04
007F6:  DATA CC,0C
007F8:  DATA 0D,CD
007FA:  DATA 0F,CF
007FC:  DATA CE,0E
007FE:  DATA 0A,CA
00800:  DATA CB,0B
00802:  DATA C9,09
00804:  DATA 08,C8
00806:  DATA D8,18
00808:  DATA 19,D9
0080A:  DATA 1B,DB
0080C:  DATA DA,1A
0080E:  DATA 1E,DE
00810:  DATA DF,1F
00812:  DATA DD,1D
00814:  DATA 1C,DC
00816:  DATA 14,D4
00818:  DATA D5,15
0081A:  DATA D7,17
0081C:  DATA 16,D6
0081E:  DATA D2,12
00820:  DATA 13,D3
00822:  DATA 11,D1
00824:  DATA D0,10
00826:  DATA F0,30
00828:  DATA 31,F1
0082A:  DATA 33,F3
0082C:  DATA F2,32
0082E:  DATA 36,F6
00830:  DATA F7,37
00832:  DATA F5,35
00834:  DATA 34,F4
00836:  DATA 3C,FC
00838:  DATA FD,3D
0083A:  DATA FF,3F
0083C:  DATA 3E,FE
0083E:  DATA FA,3A
00840:  DATA 3B,FB
00842:  DATA 39,F9
00844:  DATA F8,38
00846:  DATA 28,E8
00848:  DATA E9,29
0084A:  DATA EB,2B
0084C:  DATA 2A,EA
0084E:  DATA EE,2E
00850:  DATA 2F,EF
00852:  DATA 2D,ED
00854:  DATA EC,2C
00856:  DATA E4,24
00858:  DATA 25,E5
0085A:  DATA 27,E7
0085C:  DATA E6,26
0085E:  DATA 22,E2
00860:  DATA E3,23
00862:  DATA E1,21
00864:  DATA 20,E0
00866:  DATA A0,60
00868:  DATA 61,A1
0086A:  DATA 63,A3
0086C:  DATA A2,62
0086E:  DATA 66,A6
00870:  DATA A7,67
00872:  DATA A5,65
00874:  DATA 64,A4
00876:  DATA 6C,AC
00878:  DATA AD,6D
0087A:  DATA AF,6F
0087C:  DATA 6E,AE
0087E:  DATA AA,6A
00880:  DATA 6B,AB
00882:  DATA 69,A9
00884:  DATA A8,68
00886:  DATA 78,B8
00888:  DATA B9,79
0088A:  DATA BB,7B
0088C:  DATA 7A,BA
0088E:  DATA BE,7E
00890:  DATA 7F,BF
00892:  DATA 7D,BD
00894:  DATA BC,7C
00896:  DATA B4,74
00898:  DATA 75,B5
0089A:  DATA 77,B7
0089C:  DATA B6,76
0089E:  DATA 72,B2
008A0:  DATA B3,73
008A2:  DATA B1,71
008A4:  DATA 70,B0
008A6:  DATA 50,90
008A8:  DATA 91,51
008AA:  DATA 93,53
008AC:  DATA 52,92
008AE:  DATA 96,56
008B0:  DATA 57,97
008B2:  DATA 55,95
008B4:  DATA 94,54
008B6:  DATA 9C,5C
008B8:  DATA 5D,9D
008BA:  DATA 5F,9F
008BC:  DATA 9E,5E
008BE:  DATA 5A,9A
008C0:  DATA 9B,5B
008C2:  DATA 99,59
008C4:  DATA 58,98
008C6:  DATA 88,48
008C8:  DATA 49,89
008CA:  DATA 4B,8B
008CC:  DATA 8A,4A
008CE:  DATA 4E,8E
008D0:  DATA 8F,4F
008D2:  DATA 8D,4D
008D4:  DATA 4C,8C
008D6:  DATA 44,84
008D8:  DATA 85,45
008DA:  DATA 87,47
008DC:  DATA 46,86
008DE:  DATA 82,42
008E0:  DATA 43,83
008E2:  DATA 41,81
008E4:  DATA 80,40
008E6:  DATA 47,45
008E8:  DATA 54,5F
008EA:  DATA 42,50
008EC:  DATA 4D,3D
008EE:  DATA 25,75
008F0:  DATA 3A,25
008F2:  DATA 6C,75
008F4:  DATA 2A,0D
008F6:  DATA 0A,00
008F8:  DATA 54,45
008FA:  DATA 4D,50
008FC:  DATA 3A,25
008FE:  DATA 66,3B
00900:  DATA 0D,0A
00902:  DATA 00,00
00904:  INCF   xE3,F
00906:  BTFSC  FD8.2
00908:  INCF   xE4,F
*
00A4C:  DATA 49,4E
00A4E:  DATA 49,43
00A50:  DATA 49,41
00A52:  DATA 4C,49
00A54:  DATA 5A,41
00A56:  DATA 44,4F
00A58:  DATA 00,00
*
00A74:  TBLRD*+
00A76:  MOVF   FF5,F
00A78:  BZ    0A94
00A7A:  MOVFF  FF6,EC
00A7E:  MOVFF  FF7,ED
00A82:  MOVF   FF5,W
00A84:  BTFSS  F9E.4
00A86:  BRA    0A84
00A88:  MOVWF  FAD
00A8A:  MOVFF  EC,FF6
00A8E:  MOVFF  ED,FF7
00A92:  BRA    0A74
00A94:  GOTO   24F2 (RETURN)
*
00B4A:  MOVFF  107,10E
00B4E:  MOVLB  1
00B50:  MOVF   x0B,W
00B52:  XORWF  x0E,F
00B54:  BTFSS  x0E.7
00B56:  BRA    0B62
00B58:  BCF    FD8.2
00B5A:  BCF    FD8.0
00B5C:  BTFSC  x07.7
00B5E:  BSF    FD8.0
00B60:  BRA    0BC0
00B62:  MOVFF  107,10E
00B66:  MOVFF  10A,10F
00B6A:  MOVF   x06,W
00B6C:  SUBWF  x0F,F
00B6E:  BZ    0B7C
00B70:  BTFSS  x0E.7
00B72:  BRA    0BC0
00B74:  MOVF   FD8,W
00B76:  XORLW  01
00B78:  MOVWF  FD8
00B7A:  BRA    0BC0
00B7C:  MOVFF  10B,10F
00B80:  MOVF   x07,W
00B82:  SUBWF  x0F,F
00B84:  BZ    0B92
00B86:  BTFSS  x0E.7
00B88:  BRA    0BC0
00B8A:  MOVF   FD8,W
00B8C:  XORLW  01
00B8E:  MOVWF  FD8
00B90:  BRA    0BC0
00B92:  MOVFF  10C,10F
00B96:  MOVF   x08,W
00B98:  SUBWF  x0F,F
00B9A:  BZ    0BA8
00B9C:  BTFSS  x0E.7
00B9E:  BRA    0BC0
00BA0:  MOVF   FD8,W
00BA2:  XORLW  01
00BA4:  MOVWF  FD8
00BA6:  BRA    0BC0
00BA8:  MOVFF  10D,10F
00BAC:  MOVF   x09,W
00BAE:  SUBWF  x0F,F
00BB0:  BZ    0BBE
00BB2:  BTFSS  x0E.7
00BB4:  BRA    0BC0
00BB6:  MOVF   FD8,W
00BB8:  XORLW  01
00BBA:  MOVWF  FD8
00BBC:  BRA    0BC0
00BBE:  BCF    FD8.0
00BC0:  MOVLB  0
00BC2:  RETURN 0
00BC4:  MOVLW  8E
00BC6:  MOVWF  00
00BC8:  MOVFF  108,01
00BCC:  MOVFF  107,02
00BD0:  CLRF   03
00BD2:  MOVF   01,F
00BD4:  BNZ   0BE8
00BD6:  MOVFF  02,01
00BDA:  CLRF   02
00BDC:  MOVLW  08
00BDE:  SUBWF  00,F
00BE0:  MOVF   01,F
00BE2:  BNZ   0BE8
00BE4:  CLRF   00
00BE6:  BRA    0BF8
00BE8:  BCF    FD8.0
00BEA:  BTFSC  01.7
00BEC:  BRA    0BF6
00BEE:  RLCF   02,F
00BF0:  RLCF   01,F
00BF2:  DECF   00,F
00BF4:  BRA    0BE8
00BF6:  BCF    01.7
00BF8:  RETURN 0
00BFA:  MOVLB  1
00BFC:  MOVF   x13,W
00BFE:  BTFSC  FD8.2
00C00:  BRA    0CE4
00C02:  MOVWF  00
00C04:  MOVF   x17,W
00C06:  BTFSC  FD8.2
00C08:  BRA    0CE4
00C0A:  ADDWF  00,F
00C0C:  BNC   0C16
00C0E:  MOVLW  81
00C10:  ADDWF  00,F
00C12:  BC    0CE4
00C14:  BRA    0C1E
00C16:  MOVLW  7F
00C18:  SUBWF  00,F
00C1A:  BNC   0CE4
00C1C:  BZ    0CE4
00C1E:  MOVFF  114,11B
00C22:  MOVF   x18,W
00C24:  XORWF  x1B,F
00C26:  BSF    x14.7
00C28:  BSF    x18.7
00C2A:  MOVF   x16,W
00C2C:  MULWF  x1A
00C2E:  MOVFF  FF4,11D
00C32:  MOVF   x15,W
00C34:  MULWF  x19
00C36:  MOVFF  FF4,03
00C3A:  MOVFF  FF3,11C
00C3E:  MULWF  x1A
00C40:  MOVF   FF3,W
00C42:  ADDWF  x1D,F
00C44:  MOVF   FF4,W
00C46:  ADDWFC x1C,F
00C48:  MOVLW  00
00C4A:  ADDWFC 03,F
00C4C:  MOVF   x16,W
00C4E:  MULWF  x19
00C50:  MOVF   FF3,W
00C52:  ADDWF  x1D,F
00C54:  MOVF   FF4,W
00C56:  ADDWFC x1C,F
00C58:  MOVLW  00
00C5A:  CLRF   02
00C5C:  ADDWFC 03,F
00C5E:  ADDWFC 02,F
00C60:  MOVF   x14,W
00C62:  MULWF  x1A
00C64:  MOVF   FF3,W
00C66:  ADDWF  x1C,F
00C68:  MOVF   FF4,W
00C6A:  ADDWFC 03,F
00C6C:  MOVLW  00
00C6E:  ADDWFC 02,F
00C70:  MOVF   x14,W
00C72:  MULWF  x19
00C74:  MOVF   FF3,W
00C76:  ADDWF  03,F
00C78:  MOVF   FF4,W
00C7A:  ADDWFC 02,F
00C7C:  MOVLW  00
00C7E:  CLRF   01
00C80:  ADDWFC 01,F
00C82:  MOVF   x16,W
00C84:  MULWF  x18
00C86:  MOVF   FF3,W
00C88:  ADDWF  x1C,F
00C8A:  MOVF   FF4,W
00C8C:  ADDWFC 03,F
00C8E:  MOVLW  00
00C90:  ADDWFC 02,F
00C92:  ADDWFC 01,F
00C94:  MOVF   x15,W
00C96:  MULWF  x18
00C98:  MOVF   FF3,W
00C9A:  ADDWF  03,F
00C9C:  MOVF   FF4,W
00C9E:  ADDWFC 02,F
00CA0:  MOVLW  00
00CA2:  ADDWFC 01,F
00CA4:  MOVF   x14,W
00CA6:  MULWF  x18
00CA8:  MOVF   FF3,W
00CAA:  ADDWF  02,F
00CAC:  MOVF   FF4,W
00CAE:  ADDWFC 01,F
00CB0:  INCF   00,F
00CB2:  BTFSC  01.7
00CB4:  BRA    0CC0
00CB6:  RLCF   x1C,F
00CB8:  RLCF   03,F
00CBA:  RLCF   02,F
00CBC:  RLCF   01,F
00CBE:  DECF   00,F
00CC0:  MOVLW  00
00CC2:  BTFSS  x1C.7
00CC4:  BRA    0CDA
00CC6:  INCF   03,F
00CC8:  ADDWFC 02,F
00CCA:  ADDWFC 01,F
00CCC:  MOVF   01,W
00CCE:  BNZ   0CDA
00CD0:  MOVF   02,W
00CD2:  BNZ   0CDA
00CD4:  MOVF   03,W
00CD6:  BNZ   0CDA
00CD8:  INCF   00,F
00CDA:  BTFSC  x1B.7
00CDC:  BSF    01.7
00CDE:  BTFSS  x1B.7
00CE0:  BCF    01.7
00CE2:  BRA    0CEC
00CE4:  CLRF   00
00CE6:  CLRF   01
00CE8:  CLRF   02
00CEA:  CLRF   03
00CEC:  MOVLB  0
00CEE:  RETURN 0
00CF0:  MOVLW  80
00CF2:  BTFSS  FD8.1
00CF4:  BRA    0CFA
00CF6:  MOVLB  1
00CF8:  XORWF  x0B,F
00CFA:  MOVLB  1
00CFC:  CLRF   x10
00CFE:  CLRF   x11
00D00:  MOVFF  107,10F
00D04:  MOVF   x0B,W
00D06:  XORWF  x0F,F
00D08:  MOVF   x06,W
00D0A:  BTFSC  FD8.2
00D0C:  BRA    0ECC
00D0E:  MOVWF  x0E
00D10:  MOVWF  00
00D12:  MOVF   x0A,W
00D14:  BTFSC  FD8.2
00D16:  BRA    0EDE
00D18:  SUBWF  x0E,F
00D1A:  BTFSC  FD8.2
00D1C:  BRA    0E24
00D1E:  BNC   0D9C
00D20:  MOVFF  10B,114
00D24:  BSF    x14.7
00D26:  MOVFF  10C,113
00D2A:  MOVFF  10D,112
00D2E:  CLRF   x11
00D30:  BCF    FD8.0
00D32:  RRCF   x14,F
00D34:  RRCF   x13,F
00D36:  RRCF   x12,F
00D38:  RRCF   x11,F
00D3A:  DECFSZ x0E,F
00D3C:  BRA    0D2E
00D3E:  BTFSS  x0F.7
00D40:  BRA    0D48
00D42:  BSF    x10.0
00D44:  BRA    0F06
00D46:  BCF    x10.0
00D48:  BCF    x0E.0
00D4A:  BSF    x10.4
00D4C:  MOVLW  01
00D4E:  MOVWF  FEA
00D50:  MOVLW  09
00D52:  MOVWF  FE9
00D54:  BRA    0F2C
00D56:  BCF    x10.4
00D58:  BTFSC  x0F.7
00D5A:  BRA    0D70
00D5C:  BTFSS  x0E.0
00D5E:  BRA    0D86
00D60:  RRCF   x14,F
00D62:  RRCF   x13,F
00D64:  RRCF   x12,F
00D66:  RRCF   x11,F
00D68:  INCF   00,F
00D6A:  BTFSC  FD8.2
00D6C:  BRA    0EFC
00D6E:  BRA    0D86
00D70:  BTFSC  x14.7
00D72:  BRA    0D8C
00D74:  BCF    FD8.0
00D76:  RLCF   x11,F
00D78:  RLCF   x12,F
00D7A:  RLCF   x13,F
00D7C:  RLCF   x14,F
00D7E:  DECF   00,F
00D80:  BTFSC  FD8.2
00D82:  BRA    0EFC
00D84:  BRA    0D70
00D86:  BSF    x10.6
00D88:  BRA    0E64
00D8A:  BCF    x10.6
00D8C:  MOVFF  107,10F
00D90:  BTFSS  x07.7
00D92:  BRA    0D98
00D94:  BSF    x14.7
00D96:  BRA    0EEE
00D98:  BCF    x14.7
00D9A:  BRA    0EEE
00D9C:  MOVFF  10A,10E
00DA0:  MOVFF  10A,00
00DA4:  MOVF   x06,W
00DA6:  SUBWF  x0E,F
00DA8:  MOVFF  107,114
00DAC:  BSF    x14.7
00DAE:  MOVFF  108,113
00DB2:  MOVFF  109,112
00DB6:  CLRF   x11
00DB8:  BCF    FD8.0
00DBA:  RRCF   x14,F
00DBC:  RRCF   x13,F
00DBE:  RRCF   x12,F
00DC0:  RRCF   x11,F
00DC2:  DECFSZ x0E,F
00DC4:  BRA    0DB6
00DC6:  BTFSS  x0F.7
00DC8:  BRA    0DD0
00DCA:  BSF    x10.1
00DCC:  BRA    0F06
00DCE:  BCF    x10.1
00DD0:  BCF    x0E.0
00DD2:  BSF    x10.5
00DD4:  MOVLW  01
00DD6:  MOVWF  FEA
00DD8:  MOVLW  0D
00DDA:  MOVWF  FE9
00DDC:  BRA    0F2C
00DDE:  BCF    x10.5
00DE0:  BTFSC  x0F.7
00DE2:  BRA    0DF8
00DE4:  BTFSS  x0E.0
00DE6:  BRA    0E0E
00DE8:  RRCF   x14,F
00DEA:  RRCF   x13,F
00DEC:  RRCF   x12,F
00DEE:  RRCF   x11,F
00DF0:  INCF   00,F
00DF2:  BTFSC  FD8.2
00DF4:  BRA    0EFC
00DF6:  BRA    0E0E
00DF8:  BTFSC  x14.7
00DFA:  BRA    0E14
00DFC:  BCF    FD8.0
00DFE:  RLCF   x11,F
00E00:  RLCF   x12,F
00E02:  RLCF   x13,F
00E04:  RLCF   x14,F
00E06:  DECF   00,F
00E08:  BTFSC  FD8.2
00E0A:  BRA    0EFC
00E0C:  BRA    0DF8
00E0E:  BSF    x10.7
00E10:  BRA    0E64
00E12:  BCF    x10.7
00E14:  MOVFF  10B,10F
00E18:  BTFSS  x0B.7
00E1A:  BRA    0E20
00E1C:  BSF    x14.7
00E1E:  BRA    0EEE
00E20:  BCF    x14.7
00E22:  BRA    0EEE
00E24:  MOVFF  10B,114
00E28:  BSF    x14.7
00E2A:  MOVFF  10C,113
00E2E:  MOVFF  10D,112
00E32:  BTFSS  x0F.7
00E34:  BRA    0E3E
00E36:  BCF    x14.7
00E38:  BSF    x10.2
00E3A:  BRA    0F06
00E3C:  BCF    x10.2
00E3E:  CLRF   x11
00E40:  BCF    x0E.0
00E42:  MOVLW  01
00E44:  MOVWF  FEA
00E46:  MOVLW  09
00E48:  MOVWF  FE9
00E4A:  BRA    0F2C
00E4C:  BTFSC  x0F.7
00E4E:  BRA    0E88
00E50:  MOVFF  107,10F
00E54:  BTFSS  x0E.0
00E56:  BRA    0E64
00E58:  RRCF   x14,F
00E5A:  RRCF   x13,F
00E5C:  RRCF   x12,F
00E5E:  RRCF   x11,F
00E60:  INCF   00,F
00E62:  BZ    0EFC
00E64:  BTFSS  x11.7
00E66:  BRA    0E7E
00E68:  INCF   x12,F
00E6A:  BNZ   0E7E
00E6C:  INCF   x13,F
00E6E:  BNZ   0E7E
00E70:  INCF   x14,F
00E72:  BNZ   0E7E
00E74:  RRCF   x14,F
00E76:  RRCF   x13,F
00E78:  RRCF   x12,F
00E7A:  INCF   00,F
00E7C:  BZ    0EFC
00E7E:  BTFSC  x10.6
00E80:  BRA    0D8A
00E82:  BTFSC  x10.7
00E84:  BRA    0E12
00E86:  BRA    0EC0
00E88:  MOVLW  80
00E8A:  XORWF  x14,F
00E8C:  BTFSS  x14.7
00E8E:  BRA    0E98
00E90:  BRA    0F06
00E92:  MOVFF  10B,10F
00E96:  BRA    0EAC
00E98:  MOVFF  107,10F
00E9C:  MOVF   x14,F
00E9E:  BNZ   0EAC
00EA0:  MOVF   x13,F
00EA2:  BNZ   0EAC
00EA4:  MOVF   x12,F
00EA6:  BNZ   0EAC
00EA8:  CLRF   00
00EAA:  BRA    0EEE
00EAC:  BTFSC  x14.7
00EAE:  BRA    0EC0
00EB0:  BCF    FD8.0
00EB2:  RLCF   x11,F
00EB4:  RLCF   x12,F
00EB6:  RLCF   x13,F
00EB8:  RLCF   x14,F
00EBA:  DECFSZ 00,F
00EBC:  BRA    0EAC
00EBE:  BRA    0EFC
00EC0:  BTFSS  x0F.7
00EC2:  BRA    0EC8
00EC4:  BSF    x14.7
00EC6:  BRA    0EEE
00EC8:  BCF    x14.7
00ECA:  BRA    0EEE
00ECC:  MOVFF  10A,00
00ED0:  MOVFF  10B,114
00ED4:  MOVFF  10C,113
00ED8:  MOVFF  10D,112
00EDC:  BRA    0EEE
00EDE:  MOVFF  106,00
00EE2:  MOVFF  107,114
00EE6:  MOVFF  108,113
00EEA:  MOVFF  109,112
00EEE:  MOVFF  114,01
00EF2:  MOVFF  113,02
00EF6:  MOVFF  112,03
00EFA:  BRA    0F64
00EFC:  CLRF   00
00EFE:  CLRF   01
00F00:  CLRF   02
00F02:  CLRF   03
00F04:  BRA    0F64
00F06:  CLRF   x11
00F08:  COMF   x12,F
00F0A:  COMF   x13,F
00F0C:  COMF   x14,F
00F0E:  COMF   x11,F
00F10:  INCF   x11,F
00F12:  BNZ   0F1E
00F14:  INCF   x12,F
00F16:  BNZ   0F1E
00F18:  INCF   x13,F
00F1A:  BNZ   0F1E
00F1C:  INCF   x14,F
00F1E:  BTFSC  x10.0
00F20:  BRA    0D46
00F22:  BTFSC  x10.1
00F24:  BRA    0DCE
00F26:  BTFSC  x10.2
00F28:  BRA    0E3C
00F2A:  BRA    0E92
00F2C:  MOVF   FEF,W
00F2E:  ADDWF  x12,F
00F30:  BNC   0F3C
00F32:  INCF   x13,F
00F34:  BNZ   0F3C
00F36:  INCF   x14,F
00F38:  BTFSC  FD8.2
00F3A:  BSF    x0E.0
00F3C:  MOVF   FED,F
00F3E:  MOVF   FEF,W
00F40:  ADDWF  x13,F
00F42:  BNC   0F4A
00F44:  INCF   x14,F
00F46:  BTFSC  FD8.2
00F48:  BSF    x0E.0
00F4A:  MOVF   FED,F
00F4C:  MOVF   FEF,W
00F4E:  BTFSC  FEF.7
00F50:  BRA    0F54
00F52:  XORLW  80
00F54:  ADDWF  x14,F
00F56:  BTFSC  FD8.0
00F58:  BSF    x0E.0
00F5A:  BTFSC  x10.4
00F5C:  BRA    0D56
00F5E:  BTFSC  x10.5
00F60:  BRA    0DDE
00F62:  BRA    0E4C
00F64:  MOVLB  0
00F66:  RETURN 0
*
01152:  CLRF   01
01154:  CLRF   02
01156:  CLRF   00
01158:  CLRF   03
0115A:  MOVF   xF0,W
0115C:  BNZ   1162
0115E:  MOVF   xEF,W
01160:  BZ    1192
01162:  MOVLW  10
01164:  MOVWF  xF1
01166:  BCF    FD8.0
01168:  RLCF   xED,F
0116A:  RLCF   xEE,F
0116C:  RLCF   00,F
0116E:  RLCF   03,F
01170:  MOVF   xF0,W
01172:  SUBWF  03,W
01174:  BNZ   117A
01176:  MOVF   xEF,W
01178:  SUBWF  00,W
0117A:  BNC   118A
0117C:  MOVF   xEF,W
0117E:  SUBWF  00,F
01180:  BTFSS  FD8.0
01182:  DECF   03,F
01184:  MOVF   xF0,W
01186:  SUBWF  03,F
01188:  BSF    FD8.0
0118A:  RLCF   01,F
0118C:  RLCF   02,F
0118E:  DECFSZ xF1,F
01190:  BRA    1166
01192:  GOTO   134A (RETURN)
01196:  TBLRD*+
01198:  MOVFF  FF6,107
0119C:  MOVFF  FF7,108
011A0:  MOVF   FF5,W
011A2:  BTFSS  F9E.4
011A4:  BRA    11A2
011A6:  MOVWF  FAD
011A8:  MOVFF  107,FF6
011AC:  MOVFF  108,FF7
011B0:  MOVLB  1
011B2:  DECFSZ x06,F
011B4:  BRA    11B8
011B6:  BRA    11BC
011B8:  MOVLB  0
011BA:  BRA    1196
011BC:  MOVLB  0
011BE:  RETURN 0
011C0:  MOVF   xF0,W
011C2:  CLRF   01
011C4:  SUBWF  xEF,W
011C6:  BC    11CE
011C8:  MOVFF  EF,00
011CC:  BRA    11E6
011CE:  CLRF   00
011D0:  MOVLW  08
011D2:  MOVWF  xF1
011D4:  RLCF   xEF,F
011D6:  RLCF   00,F
011D8:  MOVF   xF0,W
011DA:  SUBWF  00,W
011DC:  BTFSC  FD8.0
011DE:  MOVWF  00
011E0:  RLCF   01,F
011E2:  DECFSZ xF1,F
011E4:  BRA    11D4
011E6:  RETURN 0
011E8:  MOVF   01,W
011EA:  MOVFF  ED,EF
011EE:  MOVLW  64
011F0:  MOVWF  xF0
011F2:  RCALL  11C0
011F4:  MOVFF  00,ED
011F8:  MOVF   01,W
011FA:  MOVLW  30
011FC:  BNZ   120C
011FE:  BTFSS  xEE.1
01200:  BRA    121C
01202:  BTFSC  xEE.3
01204:  BRA    121C
01206:  BTFSC  xEE.4
01208:  MOVLW  20
0120A:  BRA    1212
0120C:  BCF    xEE.3
0120E:  BCF    xEE.4
01210:  BSF    xEE.0
01212:  ADDWF  01,F
01214:  MOVF   01,W
01216:  BTFSS  F9E.4
01218:  BRA    1216
0121A:  MOVWF  FAD
0121C:  MOVFF  ED,EF
01220:  MOVLW  0A
01222:  MOVWF  xF0
01224:  RCALL  11C0
01226:  MOVFF  00,ED
0122A:  MOVF   01,W
0122C:  MOVLW  30
0122E:  BNZ   123C
01230:  BTFSC  xEE.3
01232:  BRA    1246
01234:  BTFSS  xEE.0
01236:  BRA    1246
01238:  BTFSC  xEE.4
0123A:  MOVLW  20
0123C:  ADDWF  01,F
0123E:  MOVF   01,W
01240:  BTFSS  F9E.4
01242:  BRA    1240
01244:  MOVWF  FAD
01246:  MOVLW  30
01248:  ADDWF  xED,F
0124A:  MOVF   xED,W
0124C:  BTFSS  F9E.4
0124E:  BRA    124C
01250:  MOVWF  FAD
01252:  GOTO   136E (RETURN)
01256:  MOVFF  FEA,F5
0125A:  MOVFF  FE9,F4
0125E:  SWAPF  xEE,W
01260:  IORLW  F0
01262:  MOVWF  xF0
01264:  ADDWF  xF0,F
01266:  ADDLW  E2
01268:  MOVWF  xF1
0126A:  ADDLW  32
0126C:  MOVWF  xF3
0126E:  MOVF   xEE,W
01270:  ANDLW  0F
01272:  ADDWF  xF1,F
01274:  ADDWF  xF1,F
01276:  ADDWF  xF3,F
01278:  ADDLW  E9
0127A:  MOVWF  xF2
0127C:  ADDWF  xF2,F
0127E:  ADDWF  xF2,F
01280:  SWAPF  xED,W
01282:  ANDLW  0F
01284:  ADDWF  xF2,F
01286:  ADDWF  xF3,F
01288:  RLCF   xF2,F
0128A:  RLCF   xF3,F
0128C:  COMF   xF3,F
0128E:  RLCF   xF3,F
01290:  MOVF   xED,W
01292:  ANDLW  0F
01294:  ADDWF  xF3,F
01296:  RLCF   xF0,F
01298:  MOVLW  07
0129A:  MOVWF  xEF
0129C:  MOVLW  0A
0129E:  DECF   xF2,F
012A0:  ADDWF  xF3,F
012A2:  BNC   129E
012A4:  DECF   xF1,F
012A6:  ADDWF  xF2,F
012A8:  BNC   12A4
012AA:  DECF   xF0,F
012AC:  ADDWF  xF1,F
012AE:  BNC   12AA
012B0:  DECF   xEF,F
012B2:  ADDWF  xF0,F
012B4:  BNC   12B0
012B6:  CLRF   FEA
012B8:  MOVLW  EF
012BA:  MOVWF  FE9
012BC:  MOVLW  07
012BE:  ANDWF  xF4,W
012C0:  BCF    xF4.6
012C2:  ADDWF  FE9,F
012C4:  MOVLW  F3
012C6:  SUBWF  FE9,W
012C8:  BTFSC  FD8.2
012CA:  BSF    xF4.6
012CC:  MOVF   FEF,W
012CE:  MOVWF  00
012D0:  BNZ   12E2
012D2:  BTFSC  xF4.6
012D4:  BRA    12E2
012D6:  BTFSC  xF4.4
012D8:  BRA    12F2
012DA:  BTFSC  xF4.3
012DC:  BRA    12E2
012DE:  MOVLW  20
012E0:  BRA    12E8
012E2:  BSF    xF4.3
012E4:  BCF    xF4.4
012E6:  MOVLW  30
012E8:  ADDWF  00,F
012EA:  MOVF   00,W
012EC:  BTFSS  F9E.4
012EE:  BRA    12EC
012F0:  MOVWF  FAD
012F2:  MOVF   FEE,W
012F4:  BTFSS  xF4.6
012F6:  BRA    12C4
012F8:  GOTO   1384 (RETURN)
*
017C8:  MOVLB  1
017CA:  MOVF   x13,W
017CC:  SUBLW  B6
017CE:  MOVWF  x13
017D0:  CLRF   03
017D2:  MOVFF  114,117
017D6:  BSF    x14.7
017D8:  BCF    FD8.0
017DA:  RRCF   x14,F
017DC:  RRCF   x15,F
017DE:  RRCF   x16,F
017E0:  RRCF   03,F
017E2:  RRCF   02,F
017E4:  RRCF   01,F
017E6:  RRCF   00,F
017E8:  DECFSZ x13,F
017EA:  BRA    17D8
017EC:  BTFSS  x17.7
017EE:  BRA    1806
017F0:  COMF   00,F
017F2:  COMF   01,F
017F4:  COMF   02,F
017F6:  COMF   03,F
017F8:  INCF   00,F
017FA:  BTFSC  FD8.2
017FC:  INCF   01,F
017FE:  BTFSC  FD8.2
01800:  INCF   02,F
01802:  BTFSC  FD8.2
01804:  INCF   03,F
01806:  MOVLB  0
01808:  GOTO   18F8 (RETURN)
0180C:  BTFSC  FD8.1
0180E:  BRA    1818
01810:  MOVLW  01
01812:  MOVWF  FEA
01814:  MOVLW  1B
01816:  MOVWF  FE9
01818:  CLRF   00
0181A:  CLRF   01
0181C:  CLRF   02
0181E:  CLRF   03
01820:  MOVLB  1
01822:  CLRF   x1B
01824:  CLRF   x1C
01826:  CLRF   x1D
01828:  CLRF   x1E
0182A:  MOVF   x1A,W
0182C:  IORWF  x19,W
0182E:  IORWF  x18,W
01830:  IORWF  x17,W
01832:  BZ    188C
01834:  MOVLW  20
01836:  MOVWF  x1F
01838:  BCF    FD8.0
0183A:  RLCF   x13,F
0183C:  RLCF   x14,F
0183E:  RLCF   x15,F
01840:  RLCF   x16,F
01842:  RLCF   x1B,F
01844:  RLCF   x1C,F
01846:  RLCF   x1D,F
01848:  RLCF   x1E,F
0184A:  MOVF   x1A,W
0184C:  SUBWF  x1E,W
0184E:  BNZ   1860
01850:  MOVF   x19,W
01852:  SUBWF  x1D,W
01854:  BNZ   1860
01856:  MOVF   x18,W
01858:  SUBWF  x1C,W
0185A:  BNZ   1860
0185C:  MOVF   x17,W
0185E:  SUBWF  x1B,W
01860:  BNC   1880
01862:  MOVF   x17,W
01864:  SUBWF  x1B,F
01866:  MOVF   x18,W
01868:  BTFSS  FD8.0
0186A:  INCFSZ x18,W
0186C:  SUBWF  x1C,F
0186E:  MOVF   x19,W
01870:  BTFSS  FD8.0
01872:  INCFSZ x19,W
01874:  SUBWF  x1D,F
01876:  MOVF   x1A,W
01878:  BTFSS  FD8.0
0187A:  INCFSZ x1A,W
0187C:  SUBWF  x1E,F
0187E:  BSF    FD8.0
01880:  RLCF   00,F
01882:  RLCF   01,F
01884:  RLCF   02,F
01886:  RLCF   03,F
01888:  DECFSZ x1F,F
0188A:  BRA    1838
0188C:  MOVFF  11B,FEF
01890:  MOVFF  11C,FEC
01894:  MOVFF  11D,FEC
01898:  MOVFF  11E,FEC
0189C:  MOVLB  0
0189E:  RETURN 0
018A0:  MOVF   FE9,W
018A2:  MOVLB  1
018A4:  MOVWF  x0B
018A6:  MOVF   x0A,W
018A8:  MOVWF  x0D
018AA:  BZ    18E4
018AC:  MOVFF  109,116
018B0:  MOVFF  108,115
018B4:  MOVFF  107,114
018B8:  MOVFF  106,113
018BC:  CLRF   x1A
018BE:  CLRF   x19
018C0:  MOVLW  20
018C2:  MOVWF  x18
018C4:  MOVLW  82
018C6:  MOVWF  x17
018C8:  MOVLB  0
018CA:  CALL   0BFA
018CE:  MOVFF  03,109
018D2:  MOVFF  02,108
018D6:  MOVFF  01,107
018DA:  MOVFF  00,106
018DE:  MOVLB  1
018E0:  DECFSZ x0D,F
018E2:  BRA    18AC
018E4:  MOVFF  109,116
018E8:  MOVFF  108,115
018EC:  MOVFF  107,114
018F0:  MOVFF  106,113
018F4:  MOVLB  0
018F6:  BRA    17C8
018F8:  MOVFF  03,109
018FC:  MOVFF  02,108
01900:  MOVFF  01,107
01904:  MOVFF  00,106
01908:  MOVLB  1
0190A:  BTFSS  x09.7
0190C:  BRA    1928
0190E:  DECF   x0B,F
01910:  BSF    x0B.5
01912:  COMF   x06,F
01914:  COMF   x07,F
01916:  COMF   x08,F
01918:  COMF   x09,F
0191A:  INCF   x06,F
0191C:  BTFSC  FD8.2
0191E:  INCF   x07,F
01920:  BTFSC  FD8.2
01922:  INCF   x08,F
01924:  BTFSC  FD8.2
01926:  INCF   x09,F
01928:  MOVLW  3B
0192A:  MOVWF  x12
0192C:  MOVLW  9A
0192E:  MOVWF  x11
01930:  MOVLW  CA
01932:  MOVWF  x10
01934:  CLRF   x0F
01936:  MOVLW  0A
01938:  MOVWF  x0D
0193A:  MOVF   x0A,W
0193C:  BTFSC  FD8.2
0193E:  INCF   x0B,F
01940:  BSF    FD8.1
01942:  MOVLW  01
01944:  MOVWF  FEA
01946:  MOVLW  06
01948:  MOVWF  FE9
0194A:  MOVFF  109,116
0194E:  MOVFF  108,115
01952:  MOVFF  107,114
01956:  MOVFF  106,113
0195A:  MOVFF  112,11A
0195E:  MOVFF  111,119
01962:  MOVFF  110,118
01966:  MOVFF  10F,117
0196A:  MOVLB  0
0196C:  RCALL  180C
0196E:  MOVF   01,W
01970:  MOVF   00,F
01972:  BNZ   199A
01974:  MOVLB  1
01976:  INCF   x0A,W
01978:  SUBWF  x0D,W
0197A:  BTFSS  FD8.2
0197C:  BRA    1982
0197E:  MOVLB  0
01980:  BRA    199A
01982:  MOVF   x0B,W
01984:  BZ    19A0
01986:  ANDLW  0F
01988:  SUBWF  x0D,W
0198A:  BZ    198E
0198C:  BC    1A06
0198E:  BTFSC  x0B.7
01990:  BRA    1A06
01992:  BTFSC  x0B.6
01994:  BRA    19A0
01996:  MOVLW  20
01998:  BRA    19FC
0199A:  MOVLW  20
0199C:  MOVLB  1
0199E:  ANDWF  x0B,F
019A0:  BTFSS  x0B.5
019A2:  BRA    19BE
019A4:  BCF    x0B.5
019A6:  MOVF   x0A,W
019A8:  BTFSS  FD8.2
019AA:  DECF   x0B,F
019AC:  MOVF   00,W
019AE:  MOVWF  x0B
019B0:  MOVLW  2D
019B2:  BTFSS  F9E.4
019B4:  BRA    19B2
019B6:  MOVWF  FAD
019B8:  MOVF   x0B,W
019BA:  MOVWF  00
019BC:  CLRF   x0B
019BE:  MOVF   x0A,W
019C0:  SUBWF  x0D,W
019C2:  BNZ   19DA
019C4:  MOVF   00,W
019C6:  MOVWF  x0B
019C8:  MOVLW  2E
019CA:  BTFSS  F9E.4
019CC:  BRA    19CA
019CE:  MOVWF  FAD
019D0:  MOVF   x0B,W
019D2:  MOVWF  00
019D4:  MOVLW  20
019D6:  ANDWF  x0B,F
019D8:  MOVLW  00
019DA:  MOVLW  30
019DC:  BTFSS  x0B.5
019DE:  BRA    19FC
019E0:  BCF    x0B.5
019E2:  MOVF   x0A,W
019E4:  BTFSS  FD8.2
019E6:  DECF   x0B,F
019E8:  MOVF   00,W
019EA:  MOVWF  x0B
019EC:  MOVLW  2D
019EE:  BTFSS  F9E.4
019F0:  BRA    19EE
019F2:  MOVWF  FAD
019F4:  MOVF   x0B,W
019F6:  MOVWF  00
019F8:  CLRF   x0B
019FA:  MOVLW  30
019FC:  ADDWF  00,F
019FE:  MOVF   00,W
01A00:  BTFSS  F9E.4
01A02:  BRA    1A00
01A04:  MOVWF  FAD
01A06:  BCF    FD8.1
01A08:  MOVFF  112,116
01A0C:  MOVFF  111,115
01A10:  MOVFF  110,114
01A14:  MOVFF  10F,113
01A18:  CLRF   x1A
01A1A:  CLRF   x19
01A1C:  CLRF   x18
01A1E:  MOVLW  0A
01A20:  MOVWF  x17
01A22:  MOVLB  0
01A24:  RCALL  180C
01A26:  MOVFF  03,112
01A2A:  MOVFF  02,111
01A2E:  MOVFF  01,110
01A32:  MOVFF  00,10F
01A36:  MOVLB  1
01A38:  DECFSZ x0D,F
01A3A:  BRA    1940
01A3C:  MOVLB  0
01A3E:  GOTO   1C76 (RETURN)
....................  
.................... #list 
....................  
.................... #device ADC=12 
....................  
.................... #FUSES NOMCLR 
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... //#FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... //#FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
....................  
.................... #use delay(internal=16MHz) 
*
01128:  MOVLW  01
0112A:  MOVWF  FEA
0112C:  MOVLW  07
0112E:  MOVWF  FE9
01130:  MOVF   FEF,W
01132:  BZ    1150
01134:  MOVLW  05
01136:  MOVWF  01
01138:  CLRF   00
0113A:  DECFSZ 00,F
0113C:  BRA    113A
0113E:  DECFSZ 01,F
01140:  BRA    1138
01142:  MOVLW  2E
01144:  MOVWF  00
01146:  DECFSZ 00,F
01148:  BRA    1146
0114A:  BRA    114C
0114C:  DECFSZ FEF,F
0114E:  BRA    1134
01150:  RETURN 0
*
013F4:  MOVLW  04
013F6:  MOVLB  1
013F8:  SUBWF  x12,F
013FA:  BNC   1410
013FC:  MOVLW  01
013FE:  MOVWF  FEA
01400:  MOVLW  12
01402:  MOVWF  FE9
01404:  MOVF   FEF,W
01406:  BZ    1410
01408:  BRA    140C
0140A:  NOP   
0140C:  DECFSZ FEF,F
0140E:  BRA    140A
01410:  MOVLB  0
01412:  RETURN 0
.................... #use rs232 (baud=9600, xmit=PIN_C6, rcv=PIN_C7, stream=PC) 
....................  
.................... //#use STANDARD_IO( A ) 
....................  
.................... #define ONEWIRE PIN_A0 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <variaveis.c> 
.................... int8 coils = 0b00000101; 
.................... int8 inputs = 0b00001001; 
.................... int16 hold_regs[] = {0x0000,0x0000,0x0000,0x0000}; 
.................... int16 input_regs[] = {0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000}; 
.................... int16 event_count = 0; 
....................  
.................... #define RS485_USE_EXT_INT                 TRUE 
....................  
.................... #define MODBUS_TYPE                       MODBUS_TYPE_SLAVE 
.................... #define MODBUS_SERIAL_TYPE                MODBUS_RTU     //use MODBUS_ASCII for ASCII mode 
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE      64 
.................... #define MODBUS_SERIAL_BAUD                9600 
....................  
.................... #define MODBUS_SERIAL_INT_SOURCE          MODBUS_INT_EXT 
....................  
.................... #define MODBUS_SERIAL_TX_PIN              PIN_B3   // Data transmit pin 
.................... #define MODBUS_SERIAL_RX_PIN              PIN_B0   // Data receive pin 
....................  
.................... #define MODBUS_SERIAL_ENABLE_PIN          PIN_B4   // Controls DE pin for RS485 
.................... #define MODBUS_SERIAL_RX_ENABLE           PIN_B5   // Controls RE pin for RS485 
....................  
.................... #define MODBUS_ADDRESS                    1 
....................  
.................... //  VARIABLES 
.................... int pulsePin = 1;                         // Pulse Sensor purple wire connected to analog pin 0 
.................... #define blinkPin PIN_C4;                  // pin to blink led at each beat 
.................... #define fadePin PIN_C5;                   // pin to do fancy classy fading blink at each beat 
.................... int fadeRate = 1;                         // used to fade LED on with PWM on fadePin 
.................... // these variables are volatile because they are used during the interrupt service routine! 
.................... int16 BPM;                   // used to hold the pulse rate 
.................... int8 Signal;                // holds the incoming raw data 
.................... int8 IBI = 600;             // holds the time between beats, the Inter-Beat Interval 
.................... boolean Pulse = false;     // true when pulse wave is high, false when it's low 
.................... boolean QS = false;        // becomes true when Arduoino finds a beat. 
....................  
.................... #include <pulse.c> 
.................... int16 P = 0;                      // used to find peak in pulse wave 
.................... int16 T = 4000;                     // used to find trough in pulse wave 
.................... int16 amp = 100;                   // used to hold amplitude of pulse waveform 
.................... int16 ad_read; 
.................... int cont = 0; 
.................... int qtd = 0; 
.................... int flag = 0; 
.................... int tentativas = 0; 
....................  
.................... void ISR(){ 
....................  
....................    // Realiza a leitura do AD 
....................    ad_read = read_adc(); 
*
00F68:  BSF    FC2.1
00F6A:  BTFSC  FC2.1
00F6C:  BRA    0F6A
00F6E:  MOVFF  FC3,46
00F72:  MOVFF  FC4,47
....................  
....................    // Verifica o valor máximo 
....................    if (ad_read > P){ 
00F76:  MOVF   41,W
00F78:  SUBWF  47,W
00F7A:  BNC   0F8C
00F7C:  BNZ   0F84
00F7E:  MOVF   46,W
00F80:  SUBWF  40,W
00F82:  BC    0F8C
....................       P = ad_read; 
00F84:  MOVFF  47,41
00F88:  MOVFF  46,40
....................    } 
....................  
....................    // Verifica o valor mínimo 
....................    if (ad_read < T){ 
00F8C:  MOVF   47,W
00F8E:  SUBWF  43,W
00F90:  BNC   0FA2
00F92:  BNZ   0F9A
00F94:  MOVF   42,W
00F96:  SUBWF  46,W
00F98:  BC    0FA2
....................       T = ad_read; 
00F9A:  MOVFF  47,43
00F9E:  MOVFF  46,42
....................    } 
....................     
....................    // Verifica a amplitude 
....................    if ((P - T) > amp){ 
00FA2:  MOVF   42,W
00FA4:  SUBWF  40,W
00FA6:  MOVWF  xED
00FA8:  MOVF   43,W
00FAA:  SUBWFB 41,W
00FAC:  MOVWF  xEE
00FAE:  MOVF   45,W
00FB0:  SUBWF  xEE,W
00FB2:  BNC   0FC8
00FB4:  BNZ   0FBC
00FB6:  MOVF   xED,W
00FB8:  SUBWF  44,W
00FBA:  BC    0FC8
....................       amp = P - T; 
00FBC:  MOVF   42,W
00FBE:  SUBWF  40,W
00FC0:  MOVWF  44
00FC2:  MOVF   43,W
00FC4:  SUBWFB 41,W
00FC6:  MOVWF  45
....................    } 
....................  
....................    // Verifica se pulso ascendente 
....................    if ((ad_read > (P - (amp*0.5))) && (flag == 0)){  
00FC8:  MOVFF  45,108
00FCC:  MOVFF  44,107
00FD0:  RCALL  0BC4
00FD2:  MOVFF  03,116
00FD6:  MOVFF  02,115
00FDA:  MOVFF  01,114
00FDE:  MOVFF  00,113
00FE2:  MOVLB  1
00FE4:  CLRF   x1A
00FE6:  CLRF   x19
00FE8:  CLRF   x18
00FEA:  MOVLW  7E
00FEC:  MOVWF  x17
00FEE:  MOVLB  0
00FF0:  RCALL  0BFA
00FF2:  MOVFF  03,F0
00FF6:  MOVFF  02,EF
00FFA:  MOVFF  01,EE
00FFE:  MOVFF  00,ED
01002:  MOVFF  41,108
01006:  MOVFF  40,107
0100A:  RCALL  0BC4
0100C:  BSF    FD8.1
0100E:  MOVFF  03,109
01012:  MOVFF  02,108
01016:  MOVFF  01,107
0101A:  MOVFF  00,106
0101E:  MOVFF  F0,10D
01022:  MOVFF  EF,10C
01026:  MOVFF  EE,10B
0102A:  MOVFF  ED,10A
0102E:  RCALL  0CF0
01030:  MOVFF  03,F4
01034:  MOVFF  02,F3
01038:  MOVFF  01,F2
0103C:  MOVFF  00,F1
01040:  MOVFF  47,108
01044:  MOVFF  46,107
01048:  RCALL  0BC4
0104A:  MOVFF  F4,109
0104E:  MOVFF  F3,108
01052:  MOVFF  F2,107
01056:  MOVFF  F1,106
0105A:  MOVFF  03,10D
0105E:  MOVFF  02,10C
01062:  MOVFF  01,10B
01066:  MOVFF  00,10A
0106A:  RCALL  0B4A
0106C:  BNC   1078
0106E:  MOVF   4A,F
01070:  BNZ   1078
....................       cont += 1; 
01072:  MOVLW  01
01074:  ADDWF  48,F
....................       flag = 1; 
01076:  MOVWF  4A
....................    } 
....................     
....................    // Verifica se pulso descendente 
....................    if ((ad_read < (T + (amp*0.5))) && (flag == 1)){  
01078:  MOVFF  45,108
0107C:  MOVFF  44,107
01080:  RCALL  0BC4
01082:  MOVFF  03,116
01086:  MOVFF  02,115
0108A:  MOVFF  01,114
0108E:  MOVFF  00,113
01092:  MOVLB  1
01094:  CLRF   x1A
01096:  CLRF   x19
01098:  CLRF   x18
0109A:  MOVLW  7E
0109C:  MOVWF  x17
0109E:  MOVLB  0
010A0:  RCALL  0BFA
010A2:  MOVFF  03,F0
010A6:  MOVFF  02,EF
010AA:  MOVFF  01,EE
010AE:  MOVFF  00,ED
010B2:  MOVFF  43,108
010B6:  MOVFF  42,107
010BA:  RCALL  0BC4
010BC:  BCF    FD8.1
010BE:  MOVFF  03,109
010C2:  MOVFF  02,108
010C6:  MOVFF  01,107
010CA:  MOVFF  00,106
010CE:  MOVFF  F0,10D
010D2:  MOVFF  EF,10C
010D6:  MOVFF  EE,10B
010DA:  MOVFF  ED,10A
010DE:  RCALL  0CF0
010E0:  MOVFF  03,F4
010E4:  MOVFF  02,F3
010E8:  MOVFF  01,F2
010EC:  MOVFF  00,F1
010F0:  MOVFF  47,108
010F4:  MOVFF  46,107
010F8:  RCALL  0BC4
010FA:  MOVFF  03,109
010FE:  MOVFF  02,108
01102:  MOVFF  01,107
01106:  MOVFF  00,106
0110A:  MOVFF  F4,10D
0110E:  MOVFF  F3,10C
01112:  MOVFF  F2,10B
01116:  MOVFF  F1,10A
0111A:  RCALL  0B4A
0111C:  BNC   1124
0111E:  DECFSZ 4A,W
01120:  BRA    1124
....................       flag = 0; 
01122:  CLRF   4A
....................    } 
01124:  GOTO   1318 (RETURN)
.................... } 
....................  
.................... void ler_batidas(){ 
....................    P = 0; 
*
012FC:  CLRF   41
012FE:  CLRF   40
....................    T = 4000; 
01300:  MOVLW  0F
01302:  MOVWF  43
01304:  MOVLW  A0
01306:  MOVWF  42
....................    amp = 0; 
01308:  CLRF   45
0130A:  CLRF   44
....................    cont = 0; 
0130C:  CLRF   48
....................     
....................    for(int i = 0; i < 100; i++){ 
0130E:  CLRF   xEC
01310:  MOVF   xEC,W
01312:  SUBLW  63
01314:  BNC   1326
....................       ISR(); 
01316:  BRA    0F68
....................       delay_ms(2); 
01318:  MOVLW  02
0131A:  MOVLB  1
0131C:  MOVWF  x07
0131E:  MOVLB  0
01320:  RCALL  1128
01322:  INCF   xEC,F
01324:  BRA    1310
....................    } 
....................     
....................    // Verifica se a amplitude é a de um dedo no sensor 
....................    if ((amp < 250) && (amp > 50)){ 
01326:  MOVF   45,F
01328:  BNZ   13A0
0132A:  MOVF   44,W
0132C:  SUBLW  F9
0132E:  BNC   13A0
01330:  MOVF   45,F
01332:  BNZ   133A
01334:  MOVF   44,W
01336:  SUBLW  32
01338:  BC    13A0
....................       BPM = 1500/cont;       
0133A:  MOVLW  05
0133C:  MOVWF  xEE
0133E:  MOVLW  DC
01340:  MOVWF  xED
01342:  CLRF   xF0
01344:  MOVFF  48,EF
01348:  BRA    1152
0134A:  MOVFF  02,3C
0134E:  MOVFF  01,3B
....................       fprintf(PC,"GET_BPM=%u:%lu*\r\n",MODBUS_ADDRESS,BPM);       
01352:  MOVLW  E6
01354:  MOVWF  FF6
01356:  MOVLW  08
01358:  MOVWF  FF7
0135A:  MOVLW  08
0135C:  MOVLB  1
0135E:  MOVWF  x06
01360:  MOVLB  0
01362:  RCALL  1196
01364:  MOVLW  01
01366:  MOVWF  xED
01368:  MOVLW  1B
0136A:  MOVWF  xEE
0136C:  BRA    11E8
0136E:  MOVLW  3A
01370:  BTFSS  F9E.4
01372:  BRA    1370
01374:  MOVWF  FAD
01376:  MOVLW  10
01378:  MOVWF  FE9
0137A:  MOVFF  3C,EE
0137E:  MOVFF  3B,ED
01382:  BRA    1256
01384:  MOVLW  F4
01386:  MOVWF  FF6
01388:  MOVLW  08
0138A:  MOVWF  FF7
0138C:  MOVLW  03
0138E:  MOVLB  1
01390:  MOVWF  x06
01392:  MOVLB  0
01394:  RCALL  1196
....................       hold_regs[1] = BPM; 
01396:  MOVFF  3C,22
0139A:  MOVFF  3B,21
....................    }else{ 
0139E:  BRA    13B2
....................       if (Tentativas > 5){ 
013A0:  MOVF   4B,W
013A2:  SUBLW  05
013A4:  BC    13AE
....................          hold_regs[1] = 0; 
013A6:  CLRF   22
013A8:  CLRF   21
....................          Tentativas = 0; 
013AA:  CLRF   4B
....................       }else{ 
013AC:  BRA    13B2
....................          Tentativas += 1; 
013AE:  MOVLW  01
013B0:  ADDWF  4B,F
....................       } 
....................    } 
013B2:  GOTO   13E4 (RETURN)
....................     
....................    //fprintf(PC,"P: %lu T: %lu A: %lu\r\n",P,T,amp); 
.................... } 
....................  
.................... #include <ctemp.c> 
.................... #include <onewire.c> 
....................  
....................  
.................... // Global variables  
.................... int8 RomBytes[8];       
.................... int8 lastDiscrep = 0;  
.................... short doneFlag = 0;  
.................... int8 FoundROM[9][8];    // Table of found ROM codes, 8 bytes for each  
.................... int8 numROMs;  
.................... int8 dowcrc;            // crc is accumulated in this variable  
....................  
.................... //calc_CRC - INTERNAL FUNCTION  
.................... //Purpose:    To calculate an 8-bit CRC based on a polynomial and the series  
.................... //            of data bytes  
.................... //Note:       Polynomial used x^8 + x^5 + x^4 + 1 = 10001100  
.................... //Inputs:     A pointer to an array of the data bytes and an int saying how many  
.................... //            bytes there are in the data array  
.................... //Outputs:    An int8 which is the calculated CRC  
.................... int8 calc_CRC(int8* data, int8 bytes)  
*
014E2:  MOVLB  1
014E4:  CLRF   x15
.................... {  
....................    #define CRC_POLY      0x8C  
....................    int8 shift_register = 0, i, datab, bits;  
....................  
....................    for(i = 0; i < bytes; ++i)  
014E6:  CLRF   x16
014E8:  MOVF   x14,W
014EA:  SUBWF  x16,W
014EC:  BC    152E
....................    {  
....................       datab = *(data + i);  
014EE:  MOVF   x16,W
014F0:  ADDWF  x12,W
014F2:  MOVWF  01
014F4:  MOVLW  00
014F6:  ADDWFC x13,W
014F8:  MOVFF  01,FE9
014FC:  MOVWF  FEA
014FE:  MOVFF  FEF,117
....................  
....................       for(bits = 0; bits < 8; ++bits)  
01502:  CLRF   x18
01504:  MOVF   x18,W
01506:  SUBLW  07
01508:  BNC   152A
....................       {  
....................          if(bit_test((shift_register ^ datab), 0))  
0150A:  MOVF   x15,W
0150C:  XORWF  x17,W
0150E:  MOVWF  x19
01510:  BTFSS  FE8.0
01512:  BRA    151E
....................          {  
....................             shift_register = shift_register >> 1;  
01514:  BCF    FD8.0
01516:  RRCF   x15,F
....................             shift_register ^= CRC_POLY;  
01518:  MOVLW  8C
0151A:  XORWF  x15,F
....................          }  
0151C:  BRA    1522
....................          else  
....................          {  
....................             shift_register = shift_register >> 1;  
0151E:  BCF    FD8.0
01520:  RRCF   x15,F
....................          }  
....................  
....................          datab = datab >> 1;  
01522:  BCF    FD8.0
01524:  RRCF   x17,F
01526:  INCF   x18,F
01528:  BRA    1504
....................       }  
0152A:  INCF   x16,F
0152C:  BRA    14E8
....................    }  
....................    return shift_register;  
0152E:  MOVFF  115,01
01532:  MOVLB  0
01534:  GOTO   1548 (RETURN)
.................... } //calc_CRC  
....................  
....................  
.................... // Returns 0 for one wire device presence, 1 for none  
.................... int8 ow_reset(void)  
.................... {  
....................    int8 presence;  
....................      
....................    output_low(ONEWIRE);  
*
01414:  BCF    F92.0
01416:  BCF    F89.0
....................    delay_us(488);          // Min. 480uS  
01418:  MOVLW  02
0141A:  MOVLB  1
0141C:  MOVWF  x11
0141E:  MOVLW  F3
01420:  MOVWF  x12
01422:  MOVLB  0
01424:  RCALL  13F4
01426:  MOVLB  1
01428:  DECFSZ x11,F
0142A:  BRA    141E
....................    output_float(ONEWIRE);  
0142C:  BSF    F92.0
....................    delay_us(72);           // Takes 15 to 60uS for devices to respond  
0142E:  MOVLW  5F
01430:  MOVWF  00
01432:  DECFSZ 00,F
01434:  BRA    1432
01436:  BRA    1438
....................    presence = input(ONEWIRE);  
01438:  BSF    F92.0
0143A:  CLRF   x10
0143C:  BTFSC  F80.0
0143E:  INCF   x10,F
....................    delay_us(424);          // Wait for end of timeslot  
01440:  MOVLW  02
01442:  MOVWF  x11
01444:  MOVLW  D3
01446:  MOVWF  x12
01448:  MOVLB  0
0144A:  RCALL  13F4
0144C:  MOVLB  1
0144E:  DECFSZ x11,F
01450:  BRA    1444
....................    return(presence);  
01452:  MOVFF  110,01
01456:  MOVLB  0
01458:  RETURN 0
.................... }  
....................  
.................... //******************************************************************************  
.................... // Read bit on one wire bus  
.................... int8 read_bit(void)  
.................... {  
....................    output_low(ONEWIRE);  
*
014BC:  BCF    F92.0
014BE:  BCF    F89.0
....................    delay_us(5);         //1 Added, 1uS min. Code relied on 8051 being slow. // Added, 1uS min.(@4Mhz 1-2@20Mhz 3-9)  
014C0:  MOVLW  06
014C2:  MOVWF  00
014C4:  DECFSZ 00,F
014C6:  BRA    14C4
014C8:  NOP   
....................    output_float(ONEWIRE);  
014CA:  BSF    F92.0
....................    delay_us(17);        //12 Read within 15uS from start of time slot // Read within 15uS from start of time slot (@4Mhz 6-11 @20Mhz 15-22)  
014CC:  MOVLW  16
014CE:  MOVWF  00
014D0:  DECFSZ 00,F
014D2:  BRA    14D0
014D4:  NOP   
....................    return(input(ONEWIRE));     
014D6:  BSF    F92.0
014D8:  MOVLW  00
014DA:  BTFSC  F80.0
014DC:  MOVLW  01
014DE:  MOVWF  01
014E0:  RETURN 0
.................... }     
....................  
.................... //******************************************************************************  
.................... void write_bit(int8 bitval)  
.................... {  
....................    output_low(ONEWIRE);  
*
0145A:  BCF    F92.0
0145C:  BCF    F89.0
....................  
....................    if(bitval == 1) {  
0145E:  MOVLB  1
01460:  DECFSZ x13,W
01462:  BRA    1470
....................       delay_us(5);      //1us 1uS min. Code relied on 8051 being slow. // 1uS min. (@4Mhz 1-2 @20Mhz 3-9)  
01464:  MOVLW  06
01466:  MOVWF  00
01468:  DECFSZ 00,F
0146A:  BRA    1468
0146C:  NOP   
....................       output_float(ONEWIRE);  
0146E:  BSF    F92.0
....................    }  
....................    delay_us(105);       //105us Wait for end of timeslot  
01470:  MOVLW  8B
01472:  MOVWF  00
01474:  DECFSZ 00,F
01476:  BRA    1474
01478:  BRA    147A
....................    output_float(ONEWIRE);  
0147A:  BSF    F92.0
0147C:  MOVLB  0
0147E:  RETURN 0
.................... }  
....................  
.................... //******************************************************************************  
.................... int8 read_byte(void)  
*
01780:  MOVLB  1
01782:  CLRF   x09
.................... {  
....................    int8 i;  
....................    int8 val = 0;  
....................  
....................    for(i=0;i<8;i++)  
01784:  CLRF   x08
01786:  MOVF   x08,W
01788:  SUBLW  07
0178A:  BNC   17BE
....................    {  
....................       if(read_bit()) val |= (0x01 << i);  
0178C:  MOVLB  0
0178E:  RCALL  14BC
01790:  MOVF   01,F
01792:  BZ    17AE
01794:  MOVLW  01
01796:  MOVWF  00
01798:  MOVLB  1
0179A:  MOVF   x08,W
0179C:  MOVWF  01
0179E:  BZ    17A8
017A0:  BCF    FD8.0
017A2:  RLCF   00,F
017A4:  DECFSZ 01,F
017A6:  BRA    17A0
017A8:  MOVF   00,W
017AA:  IORWF  x09,F
017AC:  MOVLB  0
....................       delay_us(120);  // To finish time slot  
017AE:  MOVLW  9F
017B0:  MOVWF  00
017B2:  DECFSZ 00,F
017B4:  BRA    17B2
017B6:  BRA    17B8
017B8:  MOVLB  1
017BA:  INCF   x08,F
017BC:  BRA    1786
....................    }  
....................  
....................    return val;  
017BE:  MOVFF  109,01
017C2:  MOVLB  0
017C4:  GOTO   1AC2 (RETURN)
.................... }  
....................  
.................... //******************************************************************************  
.................... void write_byte(int8 val)  
.................... {  
....................    int8 i;  
....................    int8 temp;  
....................  
....................    for (i=0;i<8;i++)  
*
01480:  MOVLB  1
01482:  CLRF   x11
01484:  MOVF   x11,W
01486:  SUBLW  07
01488:  BNC   14AE
....................    {  
....................       temp = val >> i;  
0148A:  MOVFF  110,112
0148E:  MOVF   x11,W
01490:  MOVWF  01
01492:  BZ    149C
01494:  BCF    FD8.0
01496:  RRCF   x12,F
01498:  DECFSZ 01,F
0149A:  BRA    1494
....................       temp &= 0x01;  
0149C:  MOVLW  01
0149E:  ANDWF  x12,F
....................       write_bit(temp);  
014A0:  MOVFF  112,113
014A4:  MOVLB  0
014A6:  RCALL  145A
014A8:  MOVLB  1
014AA:  INCF   x11,F
014AC:  BRA    1484
....................    }  
....................  
....................    delay_us(105);  
014AE:  MOVLW  8B
014B0:  MOVWF  00
014B2:  DECFSZ 00,F
014B4:  BRA    14B2
014B6:  BRA    14B8
014B8:  MOVLB  0
014BA:  RETURN 0
.................... }  
....................  
.................... //******************************************************************************  
.................... // One wire crc  
.................... int8 ow_crc(int8 x)  
.................... {  
....................    dowcrc = calc_CRC(x,8);  
*
01538:  MOVLB  1
0153A:  CLRF   x13
0153C:  MOVFF  111,112
01540:  MOVLW  08
01542:  MOVWF  x14
01544:  MOVLB  0
01546:  BRA    14E2
01548:  MOVFF  01,9E
....................    return dowcrc;  
0154C:  MOVFF  9E,01
01550:  GOTO   1664 (RETURN)
.................... }  
....................  
.................... //******************************************************************************  
.................... // Searches for the next device on the one wire bus. If there are no more  
.................... // devices on the bus then false is returned.  
.................... int8 Next(void)  
01554:  MOVLW  01
01556:  MOVLB  1
01558:  MOVWF  x08
0155A:  CLRF   x09
0155C:  MOVWF  x0A
0155E:  CLRF   x0B
01560:  CLRF   x0C
.................... {  
....................    int8 m = 1;             // ROM Bit index  
....................    int8 n = 0;             // ROM Byte index  
....................    int8 k = 1;             // Bit mask  
....................    int8 x = 0;  
....................    int8 discrepMarker = 0;  
....................    int8 g;                 // Output bit  
....................    int8 nxt;               // Return value  
....................    short flag;  
....................  
....................    nxt = FALSE;            // Reset next flag to false  
01562:  CLRF   x0E
....................    dowcrc = 0;             // Reset the dowcrc  
01564:  MOVLB  0
01566:  CLRF   x9E
....................    flag = ow_reset();  
01568:  RCALL  1414
0156A:  MOVLB  1
0156C:  BCF    x0F.0
0156E:  BTFSC  01.0
01570:  BSF    x0F.0
....................  
....................    if (flag||doneFlag)     // If no parts return false  
01572:  BTFSC  x0F.0
01574:  BRA    157A
01576:  BTFSS  3F.2
01578:  BRA    1582
....................    {  
....................       lastDiscrep = 0;     // Reset the search  
0157A:  CLRF   54
....................       return FALSE;  
0157C:  MOVLW  00
0157E:  MOVWF  01
01580:  BRA    168E
....................    }  
....................      
....................    write_byte(0xF0);       // Send SearchROM command  
01582:  MOVLW  F0
01584:  MOVWF  x10
01586:  MOVLB  0
01588:  RCALL  1480
....................    do  
....................    {  
....................       x = 0;  
0158A:  MOVLB  1
0158C:  CLRF   x0B
....................       if (read_bit() == 1)  
0158E:  MOVLB  0
01590:  RCALL  14BC
01592:  DECFSZ 01,W
01594:  BRA    159E
....................          x = 2;  
01596:  MOVLW  02
01598:  MOVLB  1
0159A:  MOVWF  x0B
0159C:  MOVLB  0
....................       delay_us(120);  
0159E:  MOVLW  9F
015A0:  MOVWF  00
015A2:  DECFSZ 00,F
015A4:  BRA    15A2
015A6:  BRA    15A8
....................       if (read_bit() == 1)  
015A8:  RCALL  14BC
015AA:  DECFSZ 01,W
015AC:  BRA    15B4
....................          x |= 1;                    // And it's complement   
015AE:  MOVLB  1
015B0:  BSF    x0B.0
015B2:  MOVLB  0
....................       if (x == 3)                   // There are no devices on the one wire bus  
015B4:  MOVLB  1
015B6:  MOVF   x0B,W
015B8:  SUBLW  03
015BA:  BNZ   15C0
....................          break;  
015BC:  BRA    1670
015BE:  BRA    166A
....................       else  
....................       {  
....................          if (x > 0)                 // All devices coupled have 0 or 1  
015C0:  MOVF   x0B,F
015C2:  BZ    15CC
....................             g = x >> 1;             // Bit write value for search  
015C4:  BCF    FD8.0
015C6:  RRCF   x0B,W
015C8:  MOVWF  x0D
015CA:  BRA    1606
....................  
....................          // If this discrepancy is before the last discrepancy on a previous  
....................          // Next then pick the same as last time.  
....................          else  
....................          {  
....................             if (m < lastDiscrep)  
015CC:  MOVF   54,W
015CE:  SUBWF  x08,W
015D0:  BC    15F0
....................                g = ((RomBytes[n] & k) > 0);  
015D2:  CLRF   03
015D4:  MOVF   x09,W
015D6:  ADDLW  4C
015D8:  MOVWF  FE9
015DA:  MOVLW  00
015DC:  ADDWFC 03,W
015DE:  MOVWF  FEA
015E0:  MOVF   FEF,W
015E2:  ANDWF  x0A,W
015E4:  BNZ   15EA
015E6:  MOVLW  00
015E8:  BRA    15EC
015EA:  MOVLW  01
015EC:  MOVWF  x0D
015EE:  BRA    15FE
....................             // If equal to last pick 1  
....................             else  
....................                g = (m == lastDiscrep);  // If not then pick 0  
015F0:  MOVF   54,W
015F2:  SUBWF  x08,W
015F4:  BZ    15FA
015F6:  MOVLW  00
015F8:  BRA    15FC
015FA:  MOVLW  01
015FC:  MOVWF  x0D
....................  
....................                // If 0 was picked then record position with mask k  
....................                if (g == 0) discrepMarker = m;  
015FE:  MOVF   x0D,F
01600:  BTFSC  FD8.2
01602:  MOVFF  108,10C
....................          }  
....................  
....................          // Isolate bit in ROM[n] with mask k  
....................          if (g == 1) RomBytes[n] |= k;  
01606:  DECFSZ x0D,W
01608:  BRA    1620
0160A:  CLRF   03
0160C:  MOVF   x09,W
0160E:  ADDLW  4C
01610:  MOVWF  FE9
01612:  MOVLW  00
01614:  ADDWFC 03,W
01616:  MOVWF  FEA
01618:  MOVF   FEF,W
0161A:  IORWF  x0A,W
0161C:  MOVWF  FEF
0161E:  BRA    1636
....................          else RomBytes[n] &= ~k;  
01620:  CLRF   03
01622:  MOVF   x09,W
01624:  ADDLW  4C
01626:  MOVWF  FE9
01628:  MOVLW  00
0162A:  ADDWFC 03,W
0162C:  MOVWF  FEA
0162E:  MOVF   x0A,W
01630:  XORLW  FF
01632:  ANDWF  FEF,W
01634:  MOVWF  FEF
....................  
....................          write_bit(g);  // ROM search write  
01636:  MOVFF  10D,113
0163A:  MOVLB  0
0163C:  RCALL  145A
....................  
....................          m++;           // Increment bit counter m  
0163E:  MOVLB  1
01640:  INCF   x08,F
....................          k = k << 1;    // and shift the bit mask k  
01642:  BCF    FD8.0
01644:  RLCF   x0A,F
....................          // If the mask is 0 then go to new ROM  
....................          if (k == 0)  
01646:  MOVF   x0A,F
01648:  BNZ   166A
....................          {  // Byte n and reset mask  
....................             ow_crc(RomBytes[n]);      // Accumulate the crc  
0164A:  CLRF   03
0164C:  MOVF   x09,W
0164E:  ADDLW  4C
01650:  MOVWF  FE9
01652:  MOVLW  00
01654:  ADDWFC 03,W
01656:  MOVWF  FEA
01658:  MOVFF  FEF,110
0165C:  MOVFF  110,111
01660:  MOVLB  0
01662:  BRA    1538
....................             n++;  
01664:  MOVLB  1
01666:  INCF   x09,F
....................             k++;  
01668:  INCF   x0A,F
....................          }  
....................       }  
....................    } while (n < 8);  // Loop through until through all ROM bytes 0-7  
0166A:  MOVF   x09,W
0166C:  SUBLW  07
0166E:  BC    158C
....................  
....................    if (m < (65||dowcrc))   // If search was unsuccessful then  
01670:  MOVF   x08,W
01672:  SUBLW  40
01674:  BNC   167A
....................       lastDiscrep = 0;     // reset the last Discrepancy to zero  
01676:  CLRF   54
01678:  BRA    168A
....................    else  // Search was successful, so set lastDiscrep, lastOne, nxt  
....................    {  
....................       lastDiscrep = discrepMarker;  
0167A:  MOVFF  10C,54
....................       doneFlag = (lastDiscrep == 0);  
0167E:  BCF    3F.2
01680:  MOVF   54,F
01682:  BNZ   1686
01684:  BSF    3F.2
....................       nxt = TRUE; // Indicates search not yet complete, more parts remain  
01686:  MOVLW  01
01688:  MOVWF  x0E
....................    }  
....................  
....................    return nxt;  
0168A:  MOVFF  10E,01
0168E:  MOVLB  0
01690:  RETURN 0
.................... }  
....................  
.................... //******************************************************************************  
.................... // Resets current state of a ROM search and calls Next to find the first device  
.................... // on the one wire bus.  
.................... int8 First(void)  
.................... {  
....................    lastDiscrep = 0;  
01692:  CLRF   54
....................    doneFlag = FALSE;  
01694:  BCF    3F.2
....................    return Next();    // Call Next and return it's return value;  
01696:  RCALL  1554
01698:  MOVF   01,W
0169A:  GOTO   16AC (RETURN)
.................... }  
....................  
.................... //******************************************************************************  
.................... int8 FindDevices(void)  
0169E:  MOVLB  1
016A0:  CLRF   x07
.................... {  
....................    int8 m, cont = 0;  
....................    if(!ow_reset())  
016A2:  MOVLB  0
016A4:  RCALL  1414
016A6:  MOVF   01,F
016A8:  BNZ   1712
....................    {  
....................       if(First())    // Begins when at least one part found  
016AA:  BRA    1692
016AC:  MOVF   01,F
016AE:  BZ    1712
....................       {  
....................          numROMs = 0;  
016B0:  CLRF   x9D
....................          do  
....................          {  
....................             numROMs++;   
016B2:  INCF   x9D,F
....................             cont++;  
016B4:  MOVLB  1
016B6:  INCF   x07,F
....................             for (m=0;m<8;m++)  
016B8:  CLRF   x06
016BA:  MOVF   x06,W
016BC:  SUBLW  07
016BE:  BNC   170A
....................             {  
....................                FoundROM[numROMs][m] = RomBytes[m];  
016C0:  MOVLB  0
016C2:  MOVF   x9D,W
016C4:  MULLW  08
016C6:  MOVF   FF3,W
016C8:  MOVLB  1
016CA:  CLRF   x09
016CC:  MOVWF  x08
016CE:  CLRF   03
016D0:  MOVF   x06,W
016D2:  ADDWF  x08,W
016D4:  MOVWF  01
016D6:  MOVF   x09,W
016D8:  ADDWFC 03,F
016DA:  MOVF   01,W
016DC:  ADDLW  55
016DE:  MOVWF  01
016E0:  MOVLW  00
016E2:  ADDWFC 03,F
016E4:  MOVFF  03,109
016E8:  CLRF   03
016EA:  MOVF   x06,W
016EC:  ADDLW  4C
016EE:  MOVWF  FE9
016F0:  MOVLW  00
016F2:  ADDWFC 03,W
016F4:  MOVWF  FEA
016F6:  MOVFF  FEF,10A
016FA:  MOVFF  109,FEA
016FE:  MOVFF  01,FE9
01702:  MOVFF  10A,FEF
01706:  INCF   x06,F
01708:  BRA    16BA
....................             }  
....................          } while (Next());   // Continues until no additional                               
0170A:  MOVLB  0
0170C:  RCALL  1554
0170E:  MOVF   01,F
01710:  BNZ   16B2
....................       }  
....................    }  
....................    return cont;  
01712:  MOVLB  1
01714:  MOVFF  107,01
01718:  MOVLB  0
0171A:  GOTO   1A4E (RETURN)
....................  
.................... }  
....................  
.................... //******************************************************************************  
.................... // Sends Match ROM command to bus then device address  
.................... int8 Send_MatchRom(void)  
.................... {  
....................    int8 i;  
....................    if (ow_reset()) return FALSE;          // 0 if device present  
0171E:  RCALL  1414
01720:  MOVF   01,F
01722:  BZ    172A
01724:  MOVLW  00
01726:  MOVWF  01
01728:  BRA    177A
....................    write_byte(0x55);                      // Match ROM  
0172A:  MOVLW  55
0172C:  MOVLB  1
0172E:  MOVWF  x10
01730:  MOVLB  0
01732:  RCALL  1480
....................  
....................    for (i=0;i<8;i++)  
01734:  MOVLB  1
01736:  CLRF   x06
01738:  MOVF   x06,W
0173A:  SUBLW  07
0173C:  BNC   1776
....................    {  
....................       write_byte(FoundRom[numROMs][i]);   // Send ROM code  
0173E:  MOVLB  0
01740:  MOVF   x9D,W
01742:  MULLW  08
01744:  MOVF   FF3,W
01746:  MOVLB  1
01748:  CLRF   x08
0174A:  MOVWF  x07
0174C:  CLRF   03
0174E:  MOVF   x06,W
01750:  ADDWF  x07,W
01752:  MOVWF  01
01754:  MOVF   x08,W
01756:  ADDWFC 03,F
01758:  MOVF   01,W
0175A:  ADDLW  55
0175C:  MOVWF  FE9
0175E:  MOVLW  00
01760:  ADDWFC 03,W
01762:  MOVWF  FEA
01764:  MOVFF  FEF,107
01768:  MOVFF  107,110
0176C:  MOVLB  0
0176E:  RCALL  1480
01770:  MOVLB  1
01772:  INCF   x06,F
01774:  BRA    1738
....................    }  
....................  
....................    return TRUE;  
01776:  MOVLW  01
01778:  MOVWF  01
0177A:  MOVLB  0
0177C:  GOTO   1A90 (RETURN)
.................... }  
....................  
....................  
....................  
.................... void le_DS18B20() 
*
01A42:  CLRF   xEE
.................... {      
....................       //int8 numDev = 0; 
....................       //int8 scratch[9]; 
....................        
....................       //int1 RST = 0;              //Utilizado pela one-wire 
....................       int8 i, tmp, numDev = 0; 
....................       float celsius; 
....................       int16 sensData, fract; 
....................       int8 scratch[9];       
....................       unsigned char sign;  
....................        
....................       if (!ow_reset())     // If a device is present and it's time to send string  
01A44:  RCALL  1414
01A46:  MOVF   01,F
01A48:  BTFSS  FD8.2
01A4A:  BRA    1C8E
....................       {    
....................          numDev = FindDevices();   
01A4C:  BRA    169E
01A4E:  MOVFF  01,EE
....................            
....................          write_byte(0xCC); // Skip Rom command  
01A52:  MOVLW  CC
01A54:  MOVLB  1
01A56:  MOVWF  x10
01A58:  MOVLB  0
01A5A:  RCALL  1480
....................          write_byte(0x44); // Temperature convert command  
01A5C:  MOVLW  44
01A5E:  MOVLB  1
01A60:  MOVWF  x10
01A62:  MOVLB  0
01A64:  RCALL  1480
....................          output_float(ONEWIRE);  
01A66:  BSF    F92.0
....................          delay_ms(750);    // Max. conv. time is 750mS for 12 bit  
01A68:  MOVLW  03
01A6A:  MOVLB  1
01A6C:  MOVWF  x06
01A6E:  MOVLW  FA
01A70:  MOVWF  x07
01A72:  MOVLB  0
01A74:  CALL   1128
01A78:  MOVLB  1
01A7A:  DECFSZ x06,F
01A7C:  BRA    1A6E
....................          ow_reset();  
01A7E:  MOVLB  0
01A80:  RCALL  1414
....................            
....................          // read all devices on bus  
....................          for (numRoms=1; numRoms <= numDev; numRoms++)  
01A82:  MOVLW  01
01A84:  MOVWF  x9D
01A86:  MOVF   x9D,W
01A88:  SUBWF  xEE,W
01A8A:  BTFSS  FD8.0
01A8C:  BRA    1C8E
....................          {  
....................             if (Send_MatchRom())  
01A8E:  BRA    171E
01A90:  MOVF   01,F
01A92:  BTFSC  FD8.2
01A94:  BRA    1C8A
....................             {  
....................                write_byte(0xBE); // Read scratch pad command                 
01A96:  MOVLW  BE
01A98:  MOVLB  1
01A9A:  MOVWF  x10
01A9C:  MOVLB  0
01A9E:  RCALL  1480
....................                for(int i=0; i<2; i++)  
01AA0:  MOVLB  1
01AA2:  CLRF   x01
01AA4:  MOVF   x01,W
01AA6:  SUBLW  01
01AA8:  BNC   1AD4
....................                {  
....................                   scratch[i]= read_byte();  
01AAA:  CLRF   03
01AAC:  MOVF   x01,W
01AAE:  ADDLW  F7
01AB0:  MOVWF  01
01AB2:  MOVLW  00
01AB4:  ADDWFC 03,F
01AB6:  MOVFF  01,106
01ABA:  MOVFF  03,107
01ABE:  MOVLB  0
01AC0:  BRA    1780
01AC2:  MOVFF  107,FEA
01AC6:  MOVFF  106,FE9
01ACA:  MOVFF  01,FEF
01ACE:  MOVLB  1
01AD0:  INCF   x01,F
01AD2:  BRA    1AA4
....................                }             
....................                // raw sensor data (16bit)  
....................                hold_regs[0] = make16(scratch[1], scratch[0]); 
01AD4:  MOVFF  F8,20
01AD8:  MOVFF  F7,1F
....................                 
....................                // raw sensor data (16bit)  
....................                sensData = hold_regs[0];  
01ADC:  MOVFF  20,F4
01AE0:  MOVFF  1F,F3
....................                  
....................                // check negative  
....................                if (bit_test(sensData, 15))  
01AE4:  MOVLB  0
01AE6:  BTFSS  xF4.7
01AE8:  BRA    1B14
....................                {  
....................                   sign = '-';  
01AEA:  MOVLW  2D
01AEC:  MOVLB  1
01AEE:  MOVWF  x00
....................                   sensData = ~sensData + 1;                 
01AF0:  MOVFF  F3,106
01AF4:  MOVLB  1
01AF6:  COMF   x06,F
01AF8:  MOVFF  F4,107
01AFC:  MOVLB  1
01AFE:  COMF   x07,F
01B00:  MOVLW  01
01B02:  ADDWF  x06,W
01B04:  MOVLB  0
01B06:  MOVWF  xF3
01B08:  MOVLW  00
01B0A:  MOVLB  1
01B0C:  ADDWFC x07,W
01B0E:  MOVLB  0
01B10:  MOVWF  xF4
....................                } else  
01B12:  BRA    1B1C
....................                      sign = '+';  
01B14:  MOVLW  2B
01B16:  MOVLB  1
01B18:  MOVWF  x00
01B1A:  MOVLB  0
....................      
....................                fract = 0;  
01B1C:  CLRF   xF6
01B1E:  CLRF   xF5
....................                tmp = sensData&0xF;        // obtain the fractional part nibble                 
01B20:  MOVF   xF3,W
01B22:  ANDLW  0F
01B24:  MOVWF  xED
....................                celsius = sensData >> 4 ;  // calculate the whole number part  
01B26:  RRCF   xF4,W
01B28:  MOVWF  03
01B2A:  RRCF   xF3,W
01B2C:  MOVWF  02
01B2E:  RRCF   03,F
01B30:  RRCF   02,F
01B32:  RRCF   03,F
01B34:  RRCF   02,F
01B36:  RRCF   03,F
01B38:  RRCF   02,F
01B3A:  MOVLW  0F
01B3C:  ANDWF  03,F
01B3E:  MOVFF  02,107
01B42:  MOVFF  03,108
01B46:  MOVLB  0
01B48:  CALL   0BC4
01B4C:  MOVFF  03,F2
01B50:  MOVFF  02,F1
01B54:  MOVFF  01,F0
01B58:  MOVFF  00,EF
....................                  
....................                if (tmp == 0xFF)  
01B5C:  INCFSZ xED,W
01B5E:  BRA    1B96
....................                    celsius = celsius + 1;    // Calculate the fractional part             
01B60:  BCF    FD8.1
01B62:  MOVFF  F2,109
01B66:  MOVFF  F1,108
01B6A:  MOVFF  F0,107
01B6E:  MOVFF  EF,106
01B72:  MOVLB  1
01B74:  CLRF   x0D
01B76:  CLRF   x0C
01B78:  CLRF   x0B
01B7A:  MOVLW  7F
01B7C:  MOVWF  x0A
01B7E:  MOVLB  0
01B80:  CALL   0CF0
01B84:  MOVFF  03,F2
01B88:  MOVFF  02,F1
01B8C:  MOVFF  01,F0
01B90:  MOVFF  00,EF
01B94:  BRA    1BB6
....................                else  
....................                   for (i=0; i<tmp; i++)     
01B96:  MOVLB  1
01B98:  CLRF   x01
01B9A:  MOVLB  0
01B9C:  MOVF   xED,W
01B9E:  MOVLB  1
01BA0:  SUBWF  x01,W
01BA2:  BC    1BB4
....................                      fract = fract + 0625;     
01BA4:  MOVLW  95
01BA6:  MOVLB  0
01BA8:  ADDWF  xF5,F
01BAA:  MOVLW  01
01BAC:  ADDWFC xF6,F
01BAE:  MOVLB  1
01BB0:  INCF   x01,F
01BB2:  BRA    1B9A
01BB4:  MOVLB  0
....................          
....................                // Testa se o valor da temperatura não é negativo 
....................                if (celsius > 1) 
01BB6:  MOVLB  1
01BB8:  CLRF   x09
01BBA:  CLRF   x08
01BBC:  CLRF   x07
01BBE:  MOVLW  7F
01BC0:  MOVWF  x06
01BC2:  MOVFF  F2,10D
01BC6:  MOVFF  F1,10C
01BCA:  MOVFF  F0,10B
01BCE:  MOVFF  EF,10A
01BD2:  MOVLB  0
01BD4:  CALL   0B4A
01BD8:  BNC   1C8A
....................                { 
....................                   float temperatura = celsius + (fract * 0.0001); 
01BDA:  MOVFF  F6,108
01BDE:  MOVFF  F5,107
01BE2:  CALL   0BC4
01BE6:  MOVFF  03,116
01BEA:  MOVFF  02,115
01BEE:  MOVFF  01,114
01BF2:  MOVFF  00,113
01BF6:  MOVLW  17
01BF8:  MOVLB  1
01BFA:  MOVWF  x1A
01BFC:  MOVLW  B7
01BFE:  MOVWF  x19
01C00:  MOVLW  51
01C02:  MOVWF  x18
01C04:  MOVLW  71
01C06:  MOVWF  x17
01C08:  MOVLB  0
01C0A:  CALL   0BFA
01C0E:  BCF    FD8.1
01C10:  MOVFF  F2,109
01C14:  MOVFF  F1,108
01C18:  MOVFF  F0,107
01C1C:  MOVFF  EF,106
01C20:  MOVFF  03,10D
01C24:  MOVFF  02,10C
01C28:  MOVFF  01,10B
01C2C:  MOVFF  00,10A
01C30:  CALL   0CF0
01C34:  MOVFF  03,105
01C38:  MOVFF  02,104
01C3C:  MOVFF  01,103
01C40:  MOVFF  00,102
....................                   fprintf(PC,"TEMP:%f;\r\n",temperatura); 
01C44:  MOVLW  F8
01C46:  MOVWF  FF6
01C48:  MOVLW  08
01C4A:  MOVWF  FF7
01C4C:  MOVLW  05
01C4E:  MOVLB  1
01C50:  MOVWF  x06
01C52:  MOVLB  0
01C54:  CALL   1196
01C58:  MOVLW  89
01C5A:  MOVWF  FE9
01C5C:  MOVFF  105,109
01C60:  MOVFF  104,108
01C64:  MOVFF  103,107
01C68:  MOVFF  102,106
01C6C:  MOVLW  02
01C6E:  MOVLB  1
01C70:  MOVWF  x0A
01C72:  MOVLB  0
01C74:  BRA    18A0
01C76:  MOVLW  FF
01C78:  MOVWF  FF6
01C7A:  MOVLW  08
01C7C:  MOVWF  FF7
01C7E:  MOVLW  03
01C80:  MOVLB  1
01C82:  MOVWF  x06
01C84:  MOVLB  0
01C86:  CALL   1196
....................                   //fprintf(PC,"%X\r\n", hold_regs[0]); 
....................                } 
....................             }  
01C8A:  INCF   x9D,F
01C8C:  BRA    1A86
....................          } 
....................       } 
01C8E:  GOTO   2528 (RETURN)
.................... } 
....................  
.................... #include <umodbus.c> 
.................... #include <modbus_local.c> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                     modbus.c                                     //// 
.................... ////                                                                                  //// 
.................... ////           MODBUS protocol driver for serial and TCP/IP communications.           //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... ////  How to Use:                                                                     //// 
.................... ////                                                                                  //// 
.................... ////  Include just this file, modbus.c, in your main program. Before including this   //// 
.................... ////  file define the constants below for your needs.                                 //// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////  MODBUS_PROTOCOL               MODBUS_PROTOCOL_SERIAL or MODBUS_PROTOCOL_TCPIP   //// 
.................... ////                                                                                  //// 
.................... //// SERIAL DEFINES:                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2,   //// 
.................... ////                                   MODBUS_INT_RDA3,MODBUS_INT_RDA4)               //// 
.................... ////  MODBUS_SERIAL_TYPE            MODBUS_RTU or MODBUS_ASCII                        //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... //// TCP/IP DEFINES:                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBYS_TYPE_CLIENT or MODBUS_TYPE_SERVER          //// 
.................... ////  MODBUS_SERVER_LISTEN_PORT     Port server/client listens/sends messages to      //// 
.................... ////                                   (default 502)                                  //// 
.................... ////  MODBUS_LISTEN_SOCKETS         Number of sockets server listens to (default 1)   //// 
.................... ////  MODBUS_BUFFER_SIZE            Size of receive and transmit buffers (default 64) //// 
.................... ////  MODBUS_SERVER_TIMEOUT         Time is seconds client will wait for response     //// 
.................... ////                                   from server before setting TIMEOUT exception   //// 
.................... ////                                   (default 5)                                    //// 
.................... ////  MODBUS_SERVER_ADDR_0          TCP/IP address client connects to MSB             //// 
.................... ////  MODBUS_SERVER_ADDR_1          TCP/IP address client connects to                 //// 
.................... ////  MODBUS_SERVER_ADDR_2          TCP/IP address client connects to                 //// 
.................... ////  MODBUS_SERVER_ADDR_3          TCP/IP address client connects to LSB             //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  May 8, 2009       Made PCD Compatible                                           //// 
.................... ////  August 21, 2009   Added Modbus ASCII protocol                                   //// 
.................... ////  May 20, 2010      Changed variables to unsigned for PCD and if #device ANSI is  //// 
.................... ////                    used for PCM or PCH. Fixed bug when multiple UARTS are used   //// 
.................... ////                    on PIC.                                                       //// 
.................... ////  July 20, 2011     Seperated modbus.c into 7 files, including this one. The code //// 
.................... ////                    was seperated into header and c files for the Physical and    //// 
.................... ////                    Application layers, and RTU code and ASCII code.              //// 
.................... ////  November 1, 2011  Added Modbus TCP/IP protocol.                                 //// 
.................... ////  Janurary 9, 2013  Added support for Even and Odd Parity for RTU and ASCII       //// 
.................... ////                    modes.                                                        //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #include <modbus_local.h> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                     modbus.h                                     //// 
.................... ////                                                                                  //// 
.................... ////           MODBUS protocol driver for serial and TCP/IP communications.           //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////  MODBUS_PROTOCOL               MODBUS_PROTOCOL_SERIAL or MODBUS_PROTOCOL_TCPIP   //// 
.................... ////                                                                                  //// 
.................... //// SERIAL DEFINES:                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2,   //// 
.................... ////                                   MODBUS_INT_RDA3,MODBUS_INT_RDA4)               //// 
.................... ////  MODBUS_SERIAL_TYPE            MODBUS_RTU or MODBUS_ASCII                        //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... //// TCP/IP DEFINES:                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBYS_TYPE_CLIENT or MODBUS_TYPE_SERVER          //// 
.................... ////  MODBUS_SERVER_LISTEN_PORT     Port server/client listens/sends messages to      //// 
.................... ////                                   (default 502)                                  //// 
.................... ////  MODBUS_LISTEN_SOCKETS         Number of sockets server listens to (default 1)   //// 
.................... ////  MODBUS_BUFFER_SIZE            Size of receive and transmit buffers (default 64) //// 
.................... ////  MODBUS_SERVER_TIMEOUT         Time is seconds client will wait for response     //// 
.................... ////                                   from server before setting TIMEOUT exception   //// 
.................... ////                                   (default 5)                                    //// 
.................... ////  MODBUS_SERVER_ADDR_0          TCP/IP address client connects to MSB             //// 
.................... ////  MODBUS_SERVER_ADDR_1          TCP/IP address client connects to                 //// 
.................... ////  MODBUS_SERVER_ADDR_2          TCP/IP address client connects to                 //// 
.................... ////  MODBUS_SERVER_ADDR_3          TCP/IP address client connects to LSB             //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  May 8, 2009       Made PCD Compatible                                           //// 
.................... ////  August 21, 2009   Added Modbus ASCII protocol                                   //// 
.................... ////  May 20, 2010      Changed variables to unsigned for PCD and if #device ANSI is  //// 
.................... ////                    used for PCM or PCH. Fixed bug when multiple UARTS are used   //// 
.................... ////                    on PIC.                                                       //// 
.................... ////  July 20, 2011     Seperated modbus.c into 7 files, including this one. The code //// 
.................... ////                    was seperated into header and c files for the Physical and    //// 
.................... ////                    Application layers, and RTU code and ASCII code.              //// 
.................... ////  November 1, 2011  Added Modbus TCP/IP protocol.                                 //// 
.................... ////  Janurary 9, 2013  Added support for Even and Odd Parity for RTU and ASCII       //// 
.................... ////                    modes.                                                        //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2010 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MODBUS_H 
.................... #define MODBUS_H 
....................  
.................... /*Some defines so we can use identifiers to set things up*/ 
.................... #define MODBUS_PROTOCOL_SERIAL 0 
.................... #define MODBUS_PROTOCOL_TCPIP  100 
.................... #define MODBUS_TYPE_MASTER 99999 
.................... #define MODBUS_TYPE_SLAVE  88888 
.................... #define MODBUS_TYPE_CLIENT 20 
.................... #define MODBUS_TYPE_SERVER 21 
.................... #define MODBUS_INT_RDA     77777 
.................... #define MODBUS_INT_RDA2    66666 
.................... #define MODBUS_INT_RDA3    44444 
.................... #define MODBUS_INT_RDA4    33333 
.................... #define MODBUS_INT_EXT     55555 
.................... #define MODBUS_RTU         1 
.................... #define MODBUS_ASCII       2 
.................... #define MODBUS_TIMER_NOISR 13 
.................... #define MODBUS_TIMER_ISR   12 
.................... #define MODBUS_TIMER_T1    14 
.................... #define MODBUS_TIMER_T2    15 
....................  
.................... #ifndef MODBUS_PROTOCOL 
....................  #define MODBUS_PROTOCOL MODBUS_PROTOCOL_SERIAL 
.................... #endif 
....................  
.................... #if (MODBUS_PROTOCOL == MODBUS_PROTOCOL_SERIAL) 
....................  #ifndef MODBUS_TYPE 
....................   #define MODBUS_TYPE MODBUS_TYPE_MASTER 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERIAL_TYPE 
....................   #define MODBUS_SERIAL_TYPE MODBUS_RTU 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERIAL_INT_SOURCE 
....................   #define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_RDA   // Select between external interrupt 
....................  #endif                                             // or asynchronous serial interrupt 
....................  
....................  #ifndef MODBUS_SERIAL_BAUD 
....................   #define MODBUS_SERIAL_BAUD 9600 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERIAL_RX_PIN 
....................   #define MODBUS_SERIAL_RX_PIN       PIN_C7   // Data receive pin 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERIAL_TX_PIN 
....................   #define MODBUS_SERIAL_TX_PIN       PIN_C6   // Data transmit pin 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERIAL_ENABLE_PIN 
....................   #define MODBUS_SERIAL_ENABLE_PIN   0   // Controls DE pin.  RX low, TX high. 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERIAL_RX_ENABLE 
....................   #define MODBUS_SERIAL_RX_ENABLE    0   // Controls RE pin.  Should keep low. 
....................  #endif 
....................  
....................  #ifndef MODBUS_PARITY 
....................   #define MODBUS_PARITY "EVEN" 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERIAL_TIMEOUT 
....................   #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................    #define MODBUS_SERIAL_TIMEOUT    1000000 
....................   #else 
....................    #define MODBUS_SERIAL_TIMEOUT      10000     //in us 
....................   #endif 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERIAL_RX_BUFFER_SIZE 
....................   #define MODBUS_SERIAL_RX_BUFFER_SIZE  64      //size of send/rcv buffer 
....................  #endif 
....................  
....................  #ifndef MODBUS_TIMER_UPDATE 
....................   #define MODBUS_TIMER_UPDATE MODBUS_TIMER_ISR 
....................  #endif 
....................  
....................  #ifndef MODBUS_TIMER_USED 
....................   #define MODBUS_TIMER_USED MODBUS_TIMER_T1 
....................  #endif 
....................  
.................... #else ///////////////////////// MODBUS TCP/IP PROTOCOL ///////////////////////// 
....................  #ifndef MODBUS_TYPE 
....................   #define MODBUS_TYPE   MODBUS_TYPE_CLIENT 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERVER_LISTEN_PORT 
....................   #define MODBUS_SERVER_LISTEN_PORT    502   //this is the default listen port for MODBUS TCP/IP protocol 
....................  #endif 
....................  
....................  #if (MODBUS_TYPE == MODBUS_TYPE_SERVER) 
....................   #ifndef MODBUS_LISTEN_SOCKETS 
....................    #define MODBUS_LISTEN_SOCKETS     1 
....................   #endif 
....................  #endif 
....................  
....................  #ifndef MODBUS_BUFFER_SIZE 
....................   #define MODBUS_BUFFER_SIZE   64 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERVER_TIMEOUT 
....................   #define MODBUS_SERVER_TIMEOUT  5  //time in seconds that client will wait for server response before timeout 
....................  #endif 
....................  
....................  #if (MODBUS_TYPE == MODBUS_TYPE_CLIENT) 
....................   #ifndef MODBUS_SERVER_ADDR_0 
....................    #define MODBUS_SERVER_ADDR_0  192 
....................    #define MODBUS_SERVER_ADDR_1  168 
....................    #define MODBUS_SERVER_ADDR_2  100 
....................    #define MODBUS_SERVER_ADDR_3  140 
....................   #endif 
....................  #endif 
....................  
....................  #ifndef debug_printf 
....................   #define debug_printf(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u) 
....................  #endif 
....................  
.................... #endif 
....................  
.................... #if (MODBUS_PROTOCOL == MODBUS_PROTOCOL_TCPIP) 
....................  #include <modbus_phy_layer_tcpip.h> 
.................... #else 
....................  #include <modbus_phy_layer_local.h> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                modbus_phy_layer.h                                //// 
.................... ////                                                                                  //// 
.................... ////      Physical layer of the MODBUS protocol driver for serial communications.     //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  July 20, 2011       Seperated Physical Layer functions definitions into this    //// 
.................... ////                      file from modbus.c                                          //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MODBUS_PHY_LAYER_H 
.................... #define MODBUS_PHY_LAYER_H 
....................  
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER) 
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\ 
.................... {\ 
....................    modbus_timeout_enabled = 0;\ 
....................    if(address)\ 
....................    {\ 
....................       while(!modbus_kbhit() && --modbus_serial_wait)\ 
....................          delay_us(1);\ 
....................       if(!modbus_serial_wait)\ 
....................          modbus_rx.error=TIMEOUT;\ 
....................    }\ 
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\ 
.................... } 
.................... #else 
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\ 
.................... {\ 
....................    if(address)\ 
....................    {\ 
....................       while(!modbus_kbhit() && --modbus_serial_wait)\ 
....................          delay_us(1);\ 
....................       if(!modbus_serial_wait)\ 
....................          modbus_rx.error=TIMEOUT;\ 
....................    }\ 
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\ 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT) 
....................    #if defined(__PCD__) 
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA) 
....................          #word TXSTA=getenv("SFR:U1STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2) 
....................          #word TXSTA=getenv("SFR:U2STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3) 
....................          #word TXSTA=getenv("SFR:U3STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4) 
....................          #word TXSTA=getenv("SFR:U4STA") 
....................          #bit TRMT=TXSTA.8 
....................       #endif 
....................    #else 
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA) 
....................          #if getenv("sfr_valid:TXSTA") 
....................             #byte TXSTA=getenv("sfr:TXSTA") 
....................          #elif getenv("sf_valid:TXSTA1") 
....................             #byte TXSTA=getenv("sfr:TXSTA1") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX1STA") 
....................          #endif 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2) 
....................          #if getenv("sfr_valid:TXSTA2") 
....................             #byte TXSTA=getenv("sfr:TXSTA2") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX2STA") 
....................          #endif 
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3) 
....................          #if getenv("sfr_valid:TXSTA3") 
....................             #byte TXSTA=getenv("sfr:TXSTA3") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX3STA") 
....................          #endif 
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4) 
....................          #if getenv("sfr_valid:TXSTA4") 
....................             #byte TXSTA=getenv("sfr:TXSTA4") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX4STA") 
....................          #endif 
....................       #endif 
....................       #bit TRMT=TXSTA.1 
....................    #endif 
.................... #endif 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT) 
.................... #define WAIT_FOR_HW_BUFFER()\ 
.................... {\ 
....................    while(!TRMT);\ 
.................... } 
.................... #endif 
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions. 
.................... The first exception is the only one that is not part of the protocol 
.................... specification.  The TIMEOUT exception is returned when no slave 
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2, 
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6, 
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See 
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see 
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    unsigned int8 address; 
....................    unsigned int8 len;                       //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    unsigned int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////  For Custom Commands                                                             //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_putc(unsigned int8 c)                                             //// 
.................... ////    - Sends a character onto the serial line                                      //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(unsigned int8 to, unsigned int8 func); 
....................  
.................... // Purpose:    Sends a message stop 
.................... // Inputs:     none 
.................... // Outputs:    None 
.................... void modbus_serial_send_stop(); 
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(unsigned int8 c); 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////  For Init                                                                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void); 
....................  
.................... #endif //MODBUS_PHY_LAYER_H 
....................  
.................... #endif 
....................  
.................... #if (MODBUS_PROTOCOL == MODBUS_PROTOCOL_TCPIP) 
....................  #include <modbus_app_layer_tcpip.h> 
.................... #else 
....................  #include <modbus_app_layer_local.h> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                modbus_app_layer.h                                //// 
.................... ////                                                                                  //// 
.................... ////    Application layer of the MODBUS protocol driver for serial communications.    //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  July 20, 2011       Seperated App Layer functions into this file from modbus.c  //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MODBUS_APP_LAYER_H 
.................... #define MODBUS_APP_LAYER_H 
....................  
.................... #include <modbus_phy_layer_local.h> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                modbus_phy_layer.h                                //// 
.................... ////                                                                                  //// 
.................... ////      Physical layer of the MODBUS protocol driver for serial communications.     //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  July 20, 2011       Seperated Physical Layer functions definitions into this    //// 
.................... ////                      file from modbus.c                                          //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MODBUS_PHY_LAYER_H 
.................... #define MODBUS_PHY_LAYER_H 
....................  
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER) 
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\ 
.................... {\ 
....................    modbus_timeout_enabled = 0;\ 
....................    if(address)\ 
....................    {\ 
....................       while(!modbus_kbhit() && --modbus_serial_wait)\ 
....................          delay_us(1);\ 
....................       if(!modbus_serial_wait)\ 
....................          modbus_rx.error=TIMEOUT;\ 
....................    }\ 
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\ 
.................... } 
.................... #else 
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\ 
.................... {\ 
....................    if(address)\ 
....................    {\ 
....................       while(!modbus_kbhit() && --modbus_serial_wait)\ 
....................          delay_us(1);\ 
....................       if(!modbus_serial_wait)\ 
....................          modbus_rx.error=TIMEOUT;\ 
....................    }\ 
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\ 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT) 
....................    #if defined(__PCD__) 
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA) 
....................          #word TXSTA=getenv("SFR:U1STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2) 
....................          #word TXSTA=getenv("SFR:U2STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3) 
....................          #word TXSTA=getenv("SFR:U3STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4) 
....................          #word TXSTA=getenv("SFR:U4STA") 
....................          #bit TRMT=TXSTA.8 
....................       #endif 
....................    #else 
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA) 
....................          #if getenv("sfr_valid:TXSTA") 
....................             #byte TXSTA=getenv("sfr:TXSTA") 
....................          #elif getenv("sf_valid:TXSTA1") 
....................             #byte TXSTA=getenv("sfr:TXSTA1") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX1STA") 
....................          #endif 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2) 
....................          #if getenv("sfr_valid:TXSTA2") 
....................             #byte TXSTA=getenv("sfr:TXSTA2") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX2STA") 
....................          #endif 
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3) 
....................          #if getenv("sfr_valid:TXSTA3") 
....................             #byte TXSTA=getenv("sfr:TXSTA3") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX3STA") 
....................          #endif 
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4) 
....................          #if getenv("sfr_valid:TXSTA4") 
....................             #byte TXSTA=getenv("sfr:TXSTA4") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX4STA") 
....................          #endif 
....................       #endif 
....................       #bit TRMT=TXSTA.1 
....................    #endif 
.................... #endif 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT) 
.................... #define WAIT_FOR_HW_BUFFER()\ 
.................... {\ 
....................    while(!TRMT);\ 
.................... } 
.................... #endif 
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions. 
.................... The first exception is the only one that is not part of the protocol 
.................... specification.  The TIMEOUT exception is returned when no slave 
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2, 
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6, 
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See 
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see 
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    unsigned int8 address; 
....................    unsigned int8 len;                       //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    unsigned int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////  For Custom Commands                                                             //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_putc(unsigned int8 c)                                             //// 
.................... ////    - Sends a character onto the serial line                                      //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(unsigned int8 to, unsigned int8 func); 
....................  
.................... // Purpose:    Sends a message stop 
.................... // Inputs:     none 
.................... // Outputs:    None 
.................... void modbus_serial_send_stop(); 
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(unsigned int8 c); 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////  For Init                                                                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void); 
....................  
.................... #endif //MODBUS_PHY_LAYER_H 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Shared API                                                                       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init(); 
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit(); 
....................  
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER) 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Master Api                                                                       //// 
.................... ////                                                                                  //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request.  These 
.................... functions take in one of these structs. 
.................... Please refer to the MODBUS protocol specification if you do not 
.................... understand the members of the structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request 
.................... { 
....................    unsigned int8 reference_type; 
....................    unsigned int16 file_number; 
....................    unsigned int16 record_number; 
....................    unsigned int16 record_length; 
.................... } modbus_read_sub_request; 
....................  
.................... typedef struct _modbus_write_sub_request 
.................... { 
....................    unsigned int8 reference_type; 
....................    unsigned int16 file_number; 
....................    unsigned int16 record_number; 
....................    unsigned int16 record_length; 
....................    unsigned int16 data[MODBUS_SERIAL_RX_BUFFER_SIZE-8]; 
.................... } modbus_write_sub_request; 
....................  
.................... /******************************************************************** 
.................... The following functions are defined in the MODBUS protocol.  Please 
.................... refer to http://www.modbus.org for the purpose of each of these. 
.................... All functions take the slaves address as their first parameter. 
.................... Each function returns the exception code received from the response. 
.................... The function will return 0 if there were no errors in transmission. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity); 
....................  
.................... /* 
.................... read_discrete_input 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_discrete_input(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity); 
.................... /* 
.................... read_holding_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_holding_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity); 
....................  
.................... /* 
.................... read_input_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_input_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity); 
....................  
.................... /* 
.................... write_single_coil 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Address to write into 
....................            int1       on                 true for on, false for off 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_coil(unsigned int8 address, unsigned int16 output_address, int1 on); 
....................  
.................... /* 
.................... write_single_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Address to write into 
....................            int16      reg_value          Value to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_register(unsigned int8 address, unsigned int16 reg_address, unsigned int16 reg_value); 
....................  
.................... /* 
.................... read_exception_status 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_exception_status(unsigned int8 address); 
....................  
.................... /* 
.................... diagnostics 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Subfunction to send 
....................            int16      data               Data to send, changes based on subfunction 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_diagnostics(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data); 
....................  
.................... /* 
.................... get_comm_event_couter 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_counter(unsigned int8 address); 
....................  
.................... /* 
.................... get_comm_event_log 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_log(unsigned int8 address); 
....................  
.................... /* 
.................... write_multiple_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int1*      values             A pointer to an array holding the values to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity, 
....................                            unsigned int8 *values); 
....................  
.................... /* 
.................... write_multiple_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int16*     values             A pointer to an array holding the data to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity, 
....................                            unsigned int16 *values); 
....................  
.................... /* 
.................... report_slave_id 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_report_slave_id(unsigned int8 address); 
....................  
.................... /* 
.................... read_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_file_record(unsigned int8 address, unsigned int8 byte_count, 
....................                             modbus_read_sub_request *request); 
....................  
.................... /* 
.................... write_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record/data information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_file_record(unsigned int8 address, unsigned int8 byte_count, 
....................                             modbus_write_sub_request *request); 
....................  
.................... /* 
.................... mask_write_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reference_address  Address to mask 
....................            int16      AND_mask           A mask to AND with the data at reference_address 
....................            int16      OR_mask            A mask to OR with the data at reference_address 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_mask_write_register(unsigned int8 address, unsigned int16 reference_address, 
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask); 
....................  
.................... /* 
.................... read_write_multiple_registers 
.................... Input:     int8       address                Slave Address 
....................            int16      read_start             Address to start reading 
....................            int16      read_quantity          Amount of registers to read 
....................            int16      write_start            Address to start writing 
....................            int16      write_quantity         Amount of registers to write 
....................            int16*     write_registers_value  Pointer to an aray us to write 
.................... Output:    exception                         0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_write_multiple_registers(unsigned int8 address, unsigned int16 read_start, 
....................                                     unsigned int16 read_quantity, unsigned int16 write_start, 
....................                                     unsigned int16 write_quantity, 
....................                                     unsigned int16 *write_registers_value); 
....................  
.................... /* 
.................... read_FIFO_queue 
.................... Input:     int8       address           Slave Address 
....................            int16      FIFO_address      FIFO address 
.................... Output:    exception                    0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_FIFO_queue(unsigned int8 address, unsigned int16 FIFO_address); 
....................  
.................... #else 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Slave API                                                                        //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_coils_rsp(address,byte_count,*coil_data)                       //// 
.................... ////    - Wrapper to respond to 0x01(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_discrete_input_rsp(address,byte_count,*input_data)             //// 
.................... ////    - Wrapper to respond to 0x02(read discret input) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_holding_registers_rsp(address,byte_count,*reg_data)            //// 
.................... ////    - Wrapper to respond to 0x03(read holding regs) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_input_registers_rsp(address,byte_count,*input_data)            //// 
.................... ////    - Wrapper to respond to 0x04(read input regs) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_coil_rsp(address,output_address,output_value)          //// 
.................... ////    - Wrapper to respond to 0x05(write single coil) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_register_rsp(address,reg_address,reg_value)            //// 
.................... ////    - Wrapper to respond to 0x06(write single reg) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_exception_status_rsp(address, data)                            //// 
.................... ////    - Wrapper to respond to 0x07(read void status) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_diagnostics_rsp(address,sub_func,data)                              //// 
.................... ////    - Wrapper to respond to 0x08(diagnostics) in the MODBUS specification.        //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_counter_rsp(address,status,event_count)              //// 
.................... ////    - Wrapper to respond to 0x0B(get comm event count) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_log_rsp(address,status,event_count,message_count,    //// 
.................... ////                                   *events, events_len)                           //// 
.................... ////    - Wrapper to respond to 0x0C(get comm event log) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_coils_rsp(address,start_address,quantity)            //// 
.................... ////    - Wrapper to respond to 0x0F(write multiple coils) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_registers_rsp(address,start_address,quantity)        //// 
.................... ////    - Wrapper to respond to 0x10(write multiple regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_report_slave_id_rsp(address,slave_id,run_status,*data,data_len)     //// 
.................... ////    - Wrapper to respond to 0x11(report slave id) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_file_record_rsp(address,byte_count,*request)                   //// 
.................... ////    - Wrapper to respond to 0x14(read file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_file_record_rsp(address,byte_count,*request)                  //// 
.................... ////    - Wrapper to respond to 0x15(write file record) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_mask_write_register_rsp(address,reference_address,AND_mask,OR_mask) //// 
.................... ////    - Wrapper to respond to 0x16(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_write_multiple_registers_rsp(address,*data,data_len)           //// 
.................... ////    - Wrapper to respond to 0x17(read write mult regs) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_FIFO_queue_rsp(address,FIFO_len,*data)                         //// 
.................... ////    - Wrapper to respond to 0x18(read FIFO queue) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_exception_rsp(int8 address, int16 func, exception error)            //// 
.................... ////    - Wrapper to send an exception response.  See exception list below.           //// 
.................... ////                                                                                  //// 
.................... //// Exception List:                                                                  //// 
.................... ////  ILLEGAL_FUNCTION, ILLEGAL_DATA_ADDRESS, ILLEGAL_DATA_VALUE,                     //// 
.................... ////  SLAVE_DEVICE_FAILURE, ACKNOWLEDGE, SLAVE_DEVICE_BUSY, MEMORY_PARITY_ERROR,      //// 
.................... ////  GATEWAY_PATH_UNAVAILABLE, GATEWAY_TARGET_NO_RESPONSE                            //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    unsigned int8 record_length; 
....................    unsigned int8 reference_type; 
....................    unsigned int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    unsigned int8 reference_type; 
....................    unsigned int16 file_number; 
....................    unsigned int16 record_number; 
....................    unsigned int16 record_length; 
....................    unsigned int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(unsigned int8 address, unsigned int8 byte_count, unsigned int8* coil_data); 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     unsigned int8 *input_data); 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                         unsigned int16 *reg_data); 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                         unsigned int16 *input_data); 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(unsigned int8 address, unsigned int16 output_address, 
....................                                     unsigned int16 output_value); 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(unsigned int8 address, unsigned int16 reg_address, 
....................                                         unsigned int16 reg_value); 
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(unsigned int8 address, unsigned int8 data); 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data); 
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(unsigned int8 address, unsigned int16 status, 
....................                                         unsigned int16 event_count); 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(unsigned int8 address, unsigned int16 status, 
....................                                     unsigned int16 event_count, unsigned int16 message_count, 
....................                                     unsigned int8 *events, unsigned int8 events_len); 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(unsigned int8 address, unsigned int16 start_address, 
....................                                         unsigned int16 quantity); 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(unsigned int8 address, unsigned int16 start_address, 
....................                                             unsigned int16 quantity); 
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(unsigned int8 address, unsigned int8 slave_id, unsigned int1 run_status, 
....................                               unsigned int8 *data, unsigned int8 data_len); 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     modbus_read_sub_request_rsp *request); 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     modbus_write_sub_request_rsp *request); 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(unsigned int8 address, unsigned int16 reference_address, 
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask); 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(unsigned int8 address, unsigned int8 data_len, 
....................                                                 unsigned int16 *data); 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(unsigned int8 address, unsigned int16 FIFO_len, unsigned int16 *data); 
....................  
.................... void modbus_exception_rsp(unsigned int8 address, unsigned int16 func, exception error); 
.................... #endif //MODBUS_TYPE 
....................  
.................... #endif //MODBUS_APP_LAYER_H 
....................  
.................... #endif 
....................  
.................... #endif //MODBUS_H 
....................  
....................  
.................... #if (MODBUS_PROTOCOL == MODBUS_PROTOCOL_SERIAL) 
....................  #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................   #include <modbus_phy_layer_rtu_local.c> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                              modbus_phy_layer_rtu.c                              //// 
.................... ////                                                                                  //// 
.................... ////      Physical layer of the MODBUS protocol driver for serial communications.     //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MODBUS_PHY_LAYER_RTU_C 
.................... #define MODBUS_PHY_LAYER_RTU_C 
....................  
.................... #include <modbus_phy_layer_local.h> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                modbus_phy_layer.h                                //// 
.................... ////                                                                                  //// 
.................... ////      Physical layer of the MODBUS protocol driver for serial communications.     //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  July 20, 2011       Seperated Physical Layer functions definitions into this    //// 
.................... ////                      file from modbus.c                                          //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MODBUS_PHY_LAYER_H 
.................... #define MODBUS_PHY_LAYER_H 
....................  
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER) 
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\ 
.................... {\ 
....................    modbus_timeout_enabled = 0;\ 
....................    if(address)\ 
....................    {\ 
....................       while(!modbus_kbhit() && --modbus_serial_wait)\ 
....................          delay_us(1);\ 
....................       if(!modbus_serial_wait)\ 
....................          modbus_rx.error=TIMEOUT;\ 
....................    }\ 
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\ 
.................... } 
.................... #else 
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\ 
.................... {\ 
....................    if(address)\ 
....................    {\ 
....................       while(!modbus_kbhit() && --modbus_serial_wait)\ 
....................          delay_us(1);\ 
....................       if(!modbus_serial_wait)\ 
....................          modbus_rx.error=TIMEOUT;\ 
....................    }\ 
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\ 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT) 
....................    #if defined(__PCD__) 
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA) 
....................          #word TXSTA=getenv("SFR:U1STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2) 
....................          #word TXSTA=getenv("SFR:U2STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3) 
....................          #word TXSTA=getenv("SFR:U3STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4) 
....................          #word TXSTA=getenv("SFR:U4STA") 
....................          #bit TRMT=TXSTA.8 
....................       #endif 
....................    #else 
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA) 
....................          #if getenv("sfr_valid:TXSTA") 
....................             #byte TXSTA=getenv("sfr:TXSTA") 
....................          #elif getenv("sf_valid:TXSTA1") 
....................             #byte TXSTA=getenv("sfr:TXSTA1") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX1STA") 
....................          #endif 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2) 
....................          #if getenv("sfr_valid:TXSTA2") 
....................             #byte TXSTA=getenv("sfr:TXSTA2") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX2STA") 
....................          #endif 
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3) 
....................          #if getenv("sfr_valid:TXSTA3") 
....................             #byte TXSTA=getenv("sfr:TXSTA3") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX3STA") 
....................          #endif 
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4) 
....................          #if getenv("sfr_valid:TXSTA4") 
....................             #byte TXSTA=getenv("sfr:TXSTA4") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX4STA") 
....................          #endif 
....................       #endif 
....................       #bit TRMT=TXSTA.1 
....................    #endif 
.................... #endif 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT) 
.................... #define WAIT_FOR_HW_BUFFER()\ 
.................... {\ 
....................    while(!TRMT);\ 
.................... } 
.................... #endif 
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions. 
.................... The first exception is the only one that is not part of the protocol 
.................... specification.  The TIMEOUT exception is returned when no slave 
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2, 
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6, 
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See 
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see 
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    unsigned int8 address; 
....................    unsigned int8 len;                       //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    unsigned int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////  For Custom Commands                                                             //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_putc(unsigned int8 c)                                             //// 
.................... ////    - Sends a character onto the serial line                                      //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(unsigned int8 to, unsigned int8 func); 
....................  
.................... // Purpose:    Sends a message stop 
.................... // Inputs:     none 
.................... // Outputs:    None 
.................... void modbus_serial_send_stop(); 
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(unsigned int8 c); 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////  For Init                                                                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void); 
....................  
.................... #endif //MODBUS_PHY_LAYER_H 
....................  
....................  
.................... #if (MODBUS_TIMER_USED == MODBUS_TIMER_T1) 
....................   #if (MODBUS_TIMER_UPDATE == MODBUS_TIMER_ISR) 
....................     #USE TIMER(TIMER=1,TICK=1ms,BITS=16, ISR) 
*
00970:  MOVFF  122,00
00974:  MOVFF  123,01
00978:  CLRF   02
0097A:  BCF    FD8.0
0097C:  RLCF   00,F
0097E:  RLCF   01,F
00980:  RLCF   02,F
00982:  MOVFF  01,E3
00986:  MOVFF  02,E4
0098A:  MOVFF  00,FCF
0098E:  CLRF   FCE
00990:  RETURN 0
*
00A98:  MOVFF  E3,01
00A9C:  MOVF   FCE,W
00A9E:  MOVFF  FCF,03
00AA2:  BCF    F9D.0
00AA4:  MOVWF  02
00AA6:  MOVF   xE3,W
00AA8:  SUBWF  01,W
00AAA:  BZ    0AB4
00AAC:  MOVF   FCE,W
00AAE:  MOVFF  FCF,03
00AB2:  BRA    0AB6
00AB4:  MOVF   02,W
00AB6:  MOVFF  03,00
00ABA:  MOVFF  E3,01
00ABE:  MOVFF  E4,02
00AC2:  RRCF   02,F
00AC4:  RRCF   01,F
00AC6:  RRCF   00,F
00AC8:  BSF    F9D.0
00ACA:  GOTO   0B0E (RETURN)
....................   #else 
....................     #USE TIMER(TIMER=1,TICK=.1ms,BITS=16, NOISR) 
....................   #endif 
.................... #elif (MODBUS_TIMER_USED == MODBUS_TIMER_T2) 
....................   #if (MODBUS_TIMER_UPDATE == MODBUS_TIMER_ISR) 
....................     #USE TIMER(TIMER=2,TICK=.1ms,BITS=16, ISR) 
....................   #else 
....................     #USE TIMER(TIMER=2,TICK=.1ms,BITS=16, NOISR) 
....................   #endif 
.................... #endif 
....................  
.................... #define MODBUS_GETDATA_TIMEOUT 40 
....................  
.................... #if( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA ) 
....................   #if MODBUS_PARITY == "EVEN" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART1, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, errors) 
....................   #elif MODBUS_PARITY == "ODD" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART1, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, errors) 
....................   #else 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART1, bits=8, stop=2, parity=N, stream=MODBUS_SERIAL, errors) 
....................   #endif 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2 ) 
....................   #if MODBUS_PARITY == "EVEN" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART2, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, errors) 
....................   #elif MODBUS_PARITY == "ODD" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART2, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, errors) 
....................   #else 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART2, bits=8, stop=2, parity=N, stream=MODBUS_SERIAL, errors) 
....................   #endif 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA2);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3 ) 
....................   #if MODBUS_PARITY == "EVEN" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART3, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, errors) 
....................   #elif MODBUS_PARITY == "ODD" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART3, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, errors) 
....................   #else 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART3, bits=8, stop=2, parity=N, stream=MODBUS_SERIAL, errors) 
....................   #endif 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA3);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4 ) 
....................   #if MODBUS_PARITY == "EVEN" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART4, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, errors) 
....................   #elif MODBUS_PARITY == "ODD" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART4, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, errors) 
....................   #else 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART4, bits=8, stop=2, parity=N, stream=MODBUS_SERIAL, errors) 
....................   #endif 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA4);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_EXT ) 
....................   #if MODBUS_PARITY == "EVEN" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, xmit=MODBUS_SERIAL_TX_PIN, rcv=MODBUS_SERIAL_RX_PIN, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, disable_ints) 
*
00910:  BSF    F93.0
00912:  BTFSC  F81.0
00914:  BRA    0912
00916:  MOVLW  08
00918:  MOVWF  00
0091A:  MOVLB  1
0091C:  CLRF   x21
0091E:  MOVFF  FF2,122
00922:  BCF    FF2.7
00924:  BSF    00.7
00926:  BRA    094A
00928:  BCF    00.7
0092A:  BRA    094A
0092C:  BCF    FD8.0
0092E:  BTFSC  F81.0
00930:  BSF    FD8.0
00932:  RRCF   x21,F
00934:  BSF    00.6
00936:  BRA    094A
00938:  BCF    00.6
0093A:  DECFSZ 00,F
0093C:  BRA    092C
0093E:  BSF    00.5
00940:  BRA    094A
00942:  BCF    00.5
00944:  MOVFF  121,01
00948:  BRA    0966
0094A:  MOVLW  84
0094C:  BTFSC  00.7
0094E:  MOVLW  24
00950:  MOVWF  01
00952:  DECFSZ 01,F
00954:  BRA    0952
00956:  BRA    0958
00958:  BTFSC  00.7
0095A:  BRA    0928
0095C:  BTFSC  00.6
0095E:  BRA    0938
00960:  BTFSC  00.5
00962:  BRA    0942
00964:  BRA    092C
00966:  BTFSC  x22.7
00968:  BSF    FF2.7
0096A:  MOVLB  0
0096C:  GOTO   09EA (RETURN)
*
01C92:  MOVFF  FF2,03
01C96:  BCF    FF2.7
01C98:  CLRF   xFE
01C9A:  BCF    F93.3
01C9C:  BCF    F8A.3
01C9E:  MOVLW  08
01CA0:  MOVWF  01
01CA2:  BRA    1CA4
01CA4:  NOP   
01CA6:  BSF    01.7
01CA8:  BRA    1CD8
01CAA:  BCF    01.7
01CAC:  MOVF   xFD,W
01CAE:  XORWF  xFE,F
01CB0:  RRCF   xFD,F
01CB2:  BTFSC  FD8.0
01CB4:  BSF    F8A.3
01CB6:  BTFSS  FD8.0
01CB8:  BCF    F8A.3
01CBA:  BSF    01.6
01CBC:  BRA    1CD8
01CBE:  BCF    01.6
01CC0:  DECFSZ 01,F
01CC2:  BRA    1CAC
01CC4:  BRA    1CC6
01CC6:  NOP   
01CC8:  BTFSC  xFE.0
01CCA:  BSF    F8A.3
01CCC:  BTFSS  xFE.0
01CCE:  BCF    F8A.3
01CD0:  BSF    01.5
01CD2:  BRA    1CD8
01CD4:  BCF    01.5
01CD6:  BSF    F8A.3
01CD8:  MOVLW  84
01CDA:  MOVWF  FE9
01CDC:  DECFSZ FE9,F
01CDE:  BRA    1CDC
01CE0:  NOP   
01CE2:  BTFSC  01.7
01CE4:  BRA    1CAA
01CE6:  BTFSC  01.6
01CE8:  BRA    1CBE
01CEA:  BTFSC  01.5
01CEC:  BRA    1CD4
01CEE:  BTFSC  03.7
01CF0:  BSF    FF2.7
01CF2:  GOTO   1CFC (RETURN)
....................   #elif MODBUS_PARITY == "ODD" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, xmit=MODBUS_SERIAL_TX_PIN, rcv=MODBUS_SERIAL_RX_PIN, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, disable_ints) 
....................   #else 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, xmit=MODBUS_SERIAL_TX_PIN, rcv=MODBUS_SERIAL_RX_PIN, bits=8, stop=2, parity=N, stream=MODBUS_SERIAL, disable_ints) 
....................   #endif 
....................    #if defined(__PCD__) 
....................    #define RCV_OFF() {disable_interrupts(INT_EXT0);} 
....................    #else 
....................    #define RCV_OFF() {disable_interrupts(INT_EXT);} 
....................    #endif 
.................... #else 
....................    #error Please define a correct interrupt source 
.................... #endif 
....................  
.................... /* status of between byte timeout */ 
.................... int1 modbus_timeout_enabled = false; 
....................  
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER) 
.................... unsigned int32 modbus_serial_wait=MODBUS_SERIAL_TIMEOUT; 
.................... #endif 
....................  
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
....................  
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... union 
.................... { 
....................    unsigned int8 b[2]; 
....................    unsigned int16 d; 
.................... } modbus_serial_crc; 
....................  
....................  
.................... /* Table of CRC values for highorder byte */ 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for loworder byte */ 
.................... const unsigned char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) 
.................... { 
....................    #if (MODBUS_SERIAL_INT_SOURCE!=MODBUS_INT_EXT) 
....................       while(kbhit(MODBUS_SERIAL)) {fgetc(MODBUS_SERIAL);}  //Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
....................       #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA) 
....................          clear_interrupt(INT_RDA); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2) 
....................          clear_interrupt(INT_RDA2); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3) 
....................          clear_interrupt(INT_RDA3); 
....................       #else 
....................          clear_interrupt(INT_RDA4); 
....................       #endif 
....................  
....................       #if (MODBUS_SERIAL_RX_ENABLE!=0) 
....................          output_low(MODBUS_SERIAL_RX_ENABLE); 
....................       #endif 
....................  
....................       #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA) 
....................         enable_interrupts(INT_RDA); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2) 
....................         enable_interrupts(INT_RDA2); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3) 
....................         enable_interrupts(INT_RDA3); 
....................       #else 
....................         enable_interrupts(INT_RDA4); 
....................       #endif 
....................    #else 
....................       #if defined(__PCD__) 
....................          clear_interrupt(INT_EXT0); 
....................       #else 
....................          clear_interrupt(INT_EXT); 
*
00A5A:  BCF    FF2.1
....................       #endif 
....................  
....................       ext_int_edge(H_TO_L); 
00A5C:  BCF    FF1.6
....................  
....................       #if (MODBUS_SERIAL_RX_ENABLE!=0) 
....................          output_low(MODBUS_SERIAL_RX_ENABLE); 
00A5E:  BCF    F93.5
00A60:  BCF    F8A.5
....................       #endif 
....................  
....................       #if defined(__PCD__) 
....................          enable_interrupts(INT_EXT0); 
....................       #else 
....................          enable_interrupts(INT_EXT); 
00A62:  BSF    FF2.4
....................       #endif 
....................    #endif 
00A64:  RETURN 0
.................... } 
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... // Not used for ASCII mode 
.................... void modbus_enable_timeout(int1 enable) 
.................... { 
....................    modbus_timeout_enabled = enable; 
*
00992:  BCF    3F.4
00994:  MOVLB  1
00996:  BTFSC  x21.0
00998:  BSF    3F.4
....................    set_ticks(0); 
0099A:  CLRF   x23
0099C:  CLRF   x22
0099E:  MOVLB  0
009A0:  RCALL  0970
009A2:  RETURN 0
.................... } 
....................  
.................... // Purpose:    Handles a timeout when waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... // Not used for ASCII mode 
.................... void modbus_timeout_now(void) 
.................... { 
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
*
00ACE:  MOVF   xE5,W
00AD0:  SUBLW  02
00AD2:  BNZ   0AE8
00AD4:  MOVF   xE6,F
00AD6:  BNZ   0AE8
00AD8:  MOVF   xE7,F
00ADA:  BNZ   0AE8
00ADC:  BTFSC  3F.3
00ADE:  BRA    0AE8
....................    { 
....................       modbus_rx.len-=2; 
00AE0:  MOVLW  02
00AE2:  SUBWF  xA0,F
....................       modbus_serial_new=TRUE; 
00AE4:  BSF    3F.3
....................    } else { 
00AE6:  BRA    0AEA
....................       modbus_serial_new=FALSE; 
00AE8:  BCF    3F.3
....................    } 
....................  
....................    modbus_serial_crc.d=0xFFFF; 
00AEA:  SETF   xE7
00AEC:  SETF   xE6
....................    modbus_serial_state=MODBUS_GETADDY; 
00AEE:  CLRF   xE5
00AF0:  CLRF   16
00AF2:  BTFSC  FF2.7
00AF4:  BSF    16.7
00AF6:  BCF    FF2.7
....................    modbus_enable_timeout(FALSE); 
00AF8:  MOVLB  1
00AFA:  CLRF   x21
00AFC:  MOVLB  0
00AFE:  RCALL  0992
00B00:  BTFSC  16.7
00B02:  BSF    FF2.7
00B04:  GOTO   0B22 (RETURN)
.................... } 
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... // Not used for ASCII mode 
.................... void modbus_check_timeout(void) 
.................... { 
....................    #if (MODBUS_TIMER_UPDATE == MODBUS_TIMER_NOISR) 
....................    //get_ticks() must be called more often than the timer overflow 
....................    //rate, and the get_ticks() below will not always be called 
....................    //due to short circuit evaluation 
....................    get_ticks(); 
....................    #endif 
....................    //modbus_timeout_enabled must be checked before get_ticks() 
....................    //so that if an interrupt happens it cannot be enabled after 
....................    //an old timer value is used in comparison 
....................    if(modbus_timeout_enabled && (get_ticks() > MODBUS_GETDATA_TIMEOUT)) 
00B08:  BTFSS  3F.4
00B0A:  BRA    0B22
00B0C:  BRA    0A98
00B0E:  MOVFF  01,ED
00B12:  MOVFF  00,EC
00B16:  MOVF   xED,F
00B18:  BNZ   0B20
00B1A:  MOVF   xEC,W
00B1C:  SUBLW  28
00B1E:  BC    0B22
....................    { 
....................      modbus_timeout_now(); 
00B20:  BRA    0ACE
....................    } 
00B22:  GOTO   0B28 (RETURN)
.................... } 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_calc_crc(char data) 
.................... { 
....................    unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................    uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
009A4:  MOVF   xE7,W
009A6:  MOVLB  1
009A8:  XORWF  x21,W
009AA:  MOVWF  x22
....................    modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
009AC:  CLRF   03
009AE:  MOVF   x22,W
009B0:  MOVFF  FF2,123
009B4:  BCF    FF2.7
009B6:  MOVLB  0
009B8:  RCALL  06A2
009BA:  MOVLB  1
009BC:  BTFSC  x23.7
009BE:  BSF    FF2.7
009C0:  MOVWF  01
009C2:  MOVLB  0
009C4:  MOVF   xE6,W
009C6:  XORWF  01,W
009C8:  MOVWF  xE7
....................    modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
009CA:  CLRF   03
009CC:  MOVLB  1
009CE:  MOVF   x22,W
009D0:  MOVFF  FF2,123
009D4:  BCF    FF2.7
009D6:  MOVLB  0
009D8:  RCALL  07C4
009DA:  MOVLB  1
009DC:  BTFSC  x23.7
009DE:  BSF    FF2.7
009E0:  MOVFF  FE8,E6
009E4:  MOVLB  0
009E6:  RETURN 0
.................... } 
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(unsigned int8 c) 
.................... { 
....................    fputc(c, MODBUS_SERIAL); 
*
01CF6:  MOVFF  FC,FD
01CFA:  BRA    1C92
01CFC:  CLRF   16
01CFE:  BTFSC  FF2.7
01D00:  BSF    16.7
01D02:  BCF    FF2.7
....................    modbus_calc_crc(c); 
01D04:  MOVFF  FC,121
01D08:  CALL   09A4
01D0C:  BTFSC  16.7
01D0E:  BSF    FF2.7
....................    delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact 
01D10:  MOVLW  8A
01D12:  MOVWF  00
01D14:  DECFSZ 00,F
01D16:  BRA    1D14
01D18:  NOP   
01D1A:  RETURN 0
.................... } 
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(unsigned int8 to, unsigned int8 func) 
.................... { 
....................    modbus_serial_crc.d=0xFFFF; 
01D1C:  SETF   xE7
01D1E:  SETF   xE6
....................    modbus_serial_new=FALSE; 
01D20:  BCF    3F.3
....................  
....................    RCV_OFF(); 
01D22:  BCF    FF2.4
....................  
.................... #if (MODBUS_SERIAL_ENABLE_PIN!=0) 
....................    output_high(MODBUS_SERIAL_ENABLE_PIN); 
01D24:  BCF    F93.4
01D26:  BSF    F8A.4
.................... #endif 
....................  
....................    delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay 
01D28:  MOVLW  02
01D2A:  MOVWF  xFC
01D2C:  MOVLW  B5
01D2E:  MOVLB  1
01D30:  MOVWF  x12
01D32:  MOVLB  0
01D34:  CALL   13F4
01D38:  DECFSZ xFC,F
01D3A:  BRA    1D2C
....................  
....................    modbus_serial_putc(to); 
01D3C:  MOVFF  FA,FC
01D40:  RCALL  1CF6
....................    modbus_serial_putc(func); 
01D42:  MOVFF  FB,FC
01D46:  RCALL  1CF6
01D48:  RETURN 0
.................... } 
....................  
.................... // Purpose:    Ends a message over the RS485 Bus 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_send_stop() 
.................... { 
....................    unsigned int8 crc_low, crc_high; 
....................  
....................    crc_high=modbus_serial_crc.b[1]; 
01D4A:  MOVFF  E7,FB
....................    crc_low=modbus_serial_crc.b[0]; 
01D4E:  MOVFF  E6,FA
....................  
....................    modbus_serial_putc(crc_high); 
01D52:  MOVFF  FB,FC
01D56:  RCALL  1CF6
....................    modbus_serial_putc(crc_low); 
01D58:  MOVFF  FA,FC
01D5C:  RCALL  1CF6
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE!=MODBUS_INT_EXT) 
....................    WAIT_FOR_HW_BUFFER(); 
.................... #endif 
....................  
....................    delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay 
01D5E:  MOVLW  02
01D60:  MOVWF  xFC
01D62:  MOVLW  B5
01D64:  MOVLB  1
01D66:  MOVWF  x12
01D68:  MOVLB  0
01D6A:  CALL   13F4
01D6E:  DECFSZ xFC,F
01D70:  BRA    1D62
....................  
....................    RCV_ON(); 
01D72:  CALL   0A5A
....................  
.................... #if (MODBUS_SERIAL_ENABLE_PIN!=0) 
....................    output_low(MODBUS_SERIAL_ENABLE_PIN); 
01D76:  BCF    F93.4
01D78:  BCF    F8A.4
.................... #endif 
....................  
....................    modbus_serial_crc.d=0xFFFF; 
01D7A:  SETF   xE7
01D7C:  SETF   xE6
01D7E:  RETURN 0
.................... } 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Interrupts                                                                       //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA) 
.................... #int_rda 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2) 
.................... #int_rda2 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3) 
.................... #int_rda3 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA4) 
.................... #int_rda4 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_EXT) 
.................... #if defined(__PCD__) 
.................... #int_ext1 
.................... #else 
.................... #int_ext 
.................... #endif 
.................... #else 
.................... #error Please define a correct interrupt source 
.................... #endif 
.................... void incomming_modbus_serial() { 
....................    char c; 
....................  
....................    c=fgetc(MODBUS_SERIAL); 
*
009E8:  BRA    0910
009EA:  MOVFF  01,120
....................  
....................    if (!modbus_serial_new) 
009EE:  BTFSC  3F.3
009F0:  BRA    0A46
....................    { 
....................       if(modbus_serial_state == MODBUS_GETADDY) 
009F2:  MOVF   xE5,F
009F4:  BNZ   0A06
....................       { 
....................          modbus_serial_crc.d = 0xFFFF; 
009F6:  SETF   xE7
009F8:  SETF   xE6
....................          modbus_rx.address = c; 
009FA:  MOVFF  120,9F
....................          modbus_serial_state++; 
009FE:  INCF   xE5,F
....................          modbus_rx.len = 0; 
00A00:  CLRF   xA0
....................          modbus_rx.error=0; 
00A02:  CLRF   xA2
....................       } 
00A04:  BRA    0A36
....................       else if(modbus_serial_state == MODBUS_GETFUNC) 
00A06:  DECFSZ xE5,W
00A08:  BRA    0A12
....................       { 
....................          modbus_rx.func = c; 
00A0A:  MOVFF  120,A1
....................          modbus_serial_state++; 
00A0E:  INCF   xE5,F
....................       } 
00A10:  BRA    0A36
....................       else if(modbus_serial_state == MODBUS_GETDATA) 
00A12:  MOVF   xE5,W
00A14:  SUBLW  02
00A16:  BNZ   0A36
....................       { 
....................          if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) 
00A18:  MOVF   xA0,W
00A1A:  SUBLW  3F
00A1C:  BC    0A22
....................        { 
....................          modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
00A1E:  MOVLW  3F
00A20:  MOVWF  xA0
....................        } 
....................          modbus_rx.data[modbus_rx.len]=c; 
00A22:  CLRF   03
00A24:  MOVF   xA0,W
00A26:  ADDLW  A3
00A28:  MOVWF  FE9
00A2A:  MOVLW  00
00A2C:  ADDWFC 03,W
00A2E:  MOVWF  FEA
00A30:  MOVFF  120,FEF
....................          modbus_rx.len++; 
00A34:  INCF   xA0,F
....................      } 
....................      modbus_enable_timeout(TRUE); 
00A36:  MOVLW  01
00A38:  MOVLB  1
00A3A:  MOVWF  x21
00A3C:  MOVLB  0
00A3E:  RCALL  0992
....................      modbus_calc_crc(c); 
00A40:  MOVFF  120,121
00A44:  RCALL  09A4
....................    } 
....................  
....................    #if (MODBUS_TYPE == MODBUS_TYPE_MASTER) 
....................       modbus_serial_wait=MODBUS_SERIAL_TIMEOUT; 
....................    #endif 
.................... } 
.................... #endif //MODBUS_PHY_LAYER_RTU_C 
....................  
....................  #elif (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................   #include <modbus_phy_layer_ascii.c> 
....................  #endif 
.................... #else 
....................  #include <modbus_phy_layer_tcpip.c> 
.................... #endif 
....................  
.................... #if (MODBUS_PROTOCOL == MODBUS_PROTOCOL_TCPIP) 
....................  #include <modbus_app_layer_tcpip.c> 
.................... #else 
....................  #include <modbus_app_layer.c> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                modbus_app_layer.c                                //// 
.................... ////                                                                                  //// 
.................... ////    Application layer of the MODBUS protocol driver for serial communications.    //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MODBUS_APP_LAYER_C 
.................... #define MODBUS_APP_LAYER_C 
....................  
.................... #include <modbus_app_layer.h> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                modbus_app_layer.h                                //// 
.................... ////                                                                                  //// 
.................... ////    Application layer of the MODBUS protocol driver for serial communications.    //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  July 20, 2011       Seperated App Layer functions into this file from modbus.c  //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
00A46:  BCF    FF2.1
00A48:  GOTO   0660
.................... #ifndef MODBUS_APP_LAYER_H 
.................... #define MODBUS_APP_LAYER_H 
....................  
.................... #include <modbus_phy_layer.h> 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Shared API                                                                       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init(); 
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit(); 
....................  
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER) 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Master Api                                                                       //// 
.................... ////                                                                                  //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request.  These 
.................... functions take in one of these structs. 
.................... Please refer to the MODBUS protocol specification if you do not 
.................... understand the members of the structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request 
.................... { 
....................    unsigned int8 reference_type; 
....................    unsigned int16 file_number; 
....................    unsigned int16 record_number; 
....................    unsigned int16 record_length; 
.................... } modbus_read_sub_request; 
....................  
.................... typedef struct _modbus_write_sub_request 
.................... { 
....................    unsigned int8 reference_type; 
....................    unsigned int16 file_number; 
....................    unsigned int16 record_number; 
....................    unsigned int16 record_length; 
....................    unsigned int16 data[MODBUS_SERIAL_RX_BUFFER_SIZE-8]; 
.................... } modbus_write_sub_request; 
....................  
.................... /******************************************************************** 
.................... The following functions are defined in the MODBUS protocol.  Please 
.................... refer to http://www.modbus.org for the purpose of each of these. 
.................... All functions take the slaves address as their first parameter. 
.................... Each function returns the exception code received from the response. 
.................... The function will return 0 if there were no errors in transmission. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity); 
....................  
.................... /* 
.................... read_discrete_input 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_discrete_input(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity); 
.................... /* 
.................... read_holding_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_holding_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity); 
....................  
.................... /* 
.................... read_input_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_input_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity); 
....................  
.................... /* 
.................... write_single_coil 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Address to write into 
....................            int1       on                 true for on, false for off 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_coil(unsigned int8 address, unsigned int16 output_address, int1 on); 
....................  
.................... /* 
.................... write_single_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Address to write into 
....................            int16      reg_value          Value to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_register(unsigned int8 address, unsigned int16 reg_address, unsigned int16 reg_value); 
....................  
.................... /* 
.................... read_exception_status 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_exception_status(unsigned int8 address); 
....................  
.................... /* 
.................... diagnostics 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Subfunction to send 
....................            int16      data               Data to send, changes based on subfunction 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_diagnostics(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data); 
....................  
.................... /* 
.................... get_comm_event_couter 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_counter(unsigned int8 address); 
....................  
.................... /* 
.................... get_comm_event_log 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_log(unsigned int8 address); 
....................  
.................... /* 
.................... write_multiple_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int1*      values             A pointer to an array holding the values to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity, 
....................                            unsigned int8 *values); 
....................  
.................... /* 
.................... write_multiple_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int16*     values             A pointer to an array holding the data to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity, 
....................                            unsigned int16 *values); 
....................  
.................... /* 
.................... report_slave_id 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_report_slave_id(unsigned int8 address); 
....................  
.................... /* 
.................... read_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_file_record(unsigned int8 address, unsigned int8 byte_count, 
....................                             modbus_read_sub_request *request); 
....................  
.................... /* 
.................... write_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record/data information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_file_record(unsigned int8 address, unsigned int8 byte_count, 
....................                             modbus_write_sub_request *request); 
....................  
.................... /* 
.................... mask_write_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reference_address  Address to mask 
....................            int16      AND_mask           A mask to AND with the data at reference_address 
....................            int16      OR_mask            A mask to OR with the data at reference_address 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_mask_write_register(unsigned int8 address, unsigned int16 reference_address, 
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask); 
....................  
.................... /* 
.................... read_write_multiple_registers 
.................... Input:     int8       address                Slave Address 
....................            int16      read_start             Address to start reading 
....................            int16      read_quantity          Amount of registers to read 
....................            int16      write_start            Address to start writing 
....................            int16      write_quantity         Amount of registers to write 
....................            int16*     write_registers_value  Pointer to an aray us to write 
.................... Output:    exception                         0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_write_multiple_registers(unsigned int8 address, unsigned int16 read_start, 
....................                                     unsigned int16 read_quantity, unsigned int16 write_start, 
....................                                     unsigned int16 write_quantity, 
....................                                     unsigned int16 *write_registers_value); 
....................  
.................... /* 
.................... read_FIFO_queue 
.................... Input:     int8       address           Slave Address 
....................            int16      FIFO_address      FIFO address 
.................... Output:    exception                    0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_FIFO_queue(unsigned int8 address, unsigned int16 FIFO_address); 
....................  
.................... #else 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Slave API                                                                        //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_coils_rsp(address,byte_count,*coil_data)                       //// 
.................... ////    - Wrapper to respond to 0x01(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_discrete_input_rsp(address,byte_count,*input_data)             //// 
.................... ////    - Wrapper to respond to 0x02(read discret input) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_holding_registers_rsp(address,byte_count,*reg_data)            //// 
.................... ////    - Wrapper to respond to 0x03(read holding regs) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_input_registers_rsp(address,byte_count,*input_data)            //// 
.................... ////    - Wrapper to respond to 0x04(read input regs) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_coil_rsp(address,output_address,output_value)          //// 
.................... ////    - Wrapper to respond to 0x05(write single coil) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_register_rsp(address,reg_address,reg_value)            //// 
.................... ////    - Wrapper to respond to 0x06(write single reg) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_exception_status_rsp(address, data)                            //// 
.................... ////    - Wrapper to respond to 0x07(read void status) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_diagnostics_rsp(address,sub_func,data)                              //// 
.................... ////    - Wrapper to respond to 0x08(diagnostics) in the MODBUS specification.        //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_counter_rsp(address,status,event_count)              //// 
.................... ////    - Wrapper to respond to 0x0B(get comm event count) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_log_rsp(address,status,event_count,message_count,    //// 
.................... ////                                   *events, events_len)                           //// 
.................... ////    - Wrapper to respond to 0x0C(get comm event log) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_coils_rsp(address,start_address,quantity)            //// 
.................... ////    - Wrapper to respond to 0x0F(write multiple coils) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_registers_rsp(address,start_address,quantity)        //// 
.................... ////    - Wrapper to respond to 0x10(write multiple regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_report_slave_id_rsp(address,slave_id,run_status,*data,data_len)     //// 
.................... ////    - Wrapper to respond to 0x11(report slave id) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_file_record_rsp(address,byte_count,*request)                   //// 
.................... ////    - Wrapper to respond to 0x14(read file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_file_record_rsp(address,byte_count,*request)                  //// 
.................... ////    - Wrapper to respond to 0x15(write file record) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_mask_write_register_rsp(address,reference_address,AND_mask,OR_mask) //// 
.................... ////    - Wrapper to respond to 0x16(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_write_multiple_registers_rsp(address,*data,data_len)           //// 
.................... ////    - Wrapper to respond to 0x17(read write mult regs) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_FIFO_queue_rsp(address,FIFO_len,*data)                         //// 
.................... ////    - Wrapper to respond to 0x18(read FIFO queue) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_exception_rsp(int8 address, int16 func, exception error)            //// 
.................... ////    - Wrapper to send an exception response.  See exception list below.           //// 
.................... ////                                                                                  //// 
.................... //// Exception List:                                                                  //// 
.................... ////  ILLEGAL_FUNCTION, ILLEGAL_DATA_ADDRESS, ILLEGAL_DATA_VALUE,                     //// 
.................... ////  SLAVE_DEVICE_FAILURE, ACKNOWLEDGE, SLAVE_DEVICE_BUSY, MEMORY_PARITY_ERROR,      //// 
.................... ////  GATEWAY_PATH_UNAVAILABLE, GATEWAY_TARGET_NO_RESPONSE                            //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    unsigned int8 record_length; 
....................    unsigned int8 reference_type; 
....................    unsigned int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    unsigned int8 reference_type; 
....................    unsigned int16 file_number; 
....................    unsigned int16 record_number; 
....................    unsigned int16 record_length; 
....................    unsigned int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(unsigned int8 address, unsigned int8 byte_count, unsigned int8* coil_data); 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     unsigned int8 *input_data); 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                         unsigned int16 *reg_data); 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                         unsigned int16 *input_data); 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(unsigned int8 address, unsigned int16 output_address, 
....................                                     unsigned int16 output_value); 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(unsigned int8 address, unsigned int16 reg_address, 
....................                                         unsigned int16 reg_value); 
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(unsigned int8 address, unsigned int8 data); 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data); 
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(unsigned int8 address, unsigned int16 status, 
....................                                         unsigned int16 event_count); 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(unsigned int8 address, unsigned int16 status, 
....................                                     unsigned int16 event_count, unsigned int16 message_count, 
....................                                     unsigned int8 *events, unsigned int8 events_len); 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(unsigned int8 address, unsigned int16 start_address, 
....................                                         unsigned int16 quantity); 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(unsigned int8 address, unsigned int16 start_address, 
....................                                             unsigned int16 quantity); 
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(unsigned int8 address, unsigned int8 slave_id, unsigned int1 run_status, 
....................                               unsigned int8 *data, unsigned int8 data_len); 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     modbus_read_sub_request_rsp *request); 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     modbus_write_sub_request_rsp *request); 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(unsigned int8 address, unsigned int16 reference_address, 
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask); 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(unsigned int8 address, unsigned int8 data_len, 
....................                                                 unsigned int16 *data); 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(unsigned int8 address, unsigned int16 FIFO_len, unsigned int16 *data); 
....................  
.................... void modbus_exception_rsp(unsigned int8 address, unsigned int16 func, exception error); 
.................... #endif //MODBUS_TYPE 
....................  
.................... #endif //MODBUS_APP_LAYER_H 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Shared Api                                                                       //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() 
.................... { 
....................    output_low(MODBUS_SERIAL_ENABLE_PIN); 
*
00A66:  BCF    F93.4
00A68:  BCF    F8A.4
....................  
....................    RCV_ON(); 
00A6A:  RCALL  0A5A
....................  
....................    #if defined(__PCD__) 
....................       enable_interrupts(INTR_GLOBAL); 
....................    #else 
....................       enable_interrupts(GLOBAL); 
00A6C:  MOVLW  C0
00A6E:  IORWF  FF2,F
....................    #endif 
00A70:  GOTO   24DE (RETURN)
.................... } 
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    #if(MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................    modbus_check_timeout(); 
*
00B26:  BRA    0B08
....................    #endif 
....................  
....................    if(!modbus_serial_new) 
00B28:  BTFSC  3F.3
00B2A:  BRA    0B34
....................      return FALSE; 
00B2C:  MOVLW  00
00B2E:  MOVWF  01
00B30:  BRA    0B46
00B32:  BRA    0B40
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
00B34:  BTFSS  xA1.7
00B36:  BRA    0B40
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
00B38:  MOVFF  A3,A2
....................       modbus_rx.len = 1; 
00B3C:  MOVLW  01
00B3E:  MOVWF  xA0
....................    } 
....................    modbus_serial_new=FALSE; 
00B40:  BCF    3F.3
....................    return TRUE; 
00B42:  MOVLW  01
00B44:  MOVWF  01
00B46:  GOTO   24F6 (RETURN)
.................... } 
....................  
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER) 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Master API                                                                       //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /******************************************************************** 
.................... The following functions are defined in the MODBUS protocol.  Please 
.................... refer to http://www.modbus.org for the purpose of each of these. 
.................... All functions take the slaves address as their first parameter. 
.................... Each function returns the exception code received from the response. 
.................... The function will return 0 if there were no errors in transmission. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_discrete_input 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_discrete_input(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_holding_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_holding_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_input_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_input_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_single_coil 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Address to write into 
....................            int1       on                 true for on, false for off 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_coil(unsigned int8 address, unsigned int16 output_address, int1 on) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    if(on) 
....................        modbus_serial_putc(0xFF); 
....................    else 
....................        modbus_serial_putc(0x00); 
....................  
....................    modbus_serial_putc(0x00); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_single_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Address to write into 
....................            int16      reg_value          Value to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_register(unsigned int8 address, unsigned int16 reg_address, unsigned int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
....................    modbus_serial_putc(make8(reg_address,0)); 
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
....................    modbus_serial_putc(make8(reg_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_exception_status 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_exception_status(unsigned int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... diagnostics 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Subfunction to send 
....................            int16      data               Data to send, changes based on subfunction 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_diagnostics(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... get_comm_event_couter 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_counter(unsigned int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... get_comm_event_log 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_log(unsigned int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int1*      values             A pointer to an array holding the values to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity, 
....................                            unsigned int8 *values) 
.................... { 
....................    unsigned int8 i,count; 
....................  
....................    count = (unsigned int8)((quantity/8)); 
....................  
....................    if(quantity%8) 
....................       count++; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_putc(count); 
....................  
....................    for(i=0; i < count; ++i) 
....................       modbus_serial_putc(values[i]); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int16*     values             A pointer to an array holding the data to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity, 
....................                            unsigned int16 *values) 
.................... { 
....................    unsigned int8 i,count; 
....................  
....................    count = quantity*2; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_putc(count); 
....................  
....................    for(i=0; i < quantity; ++i) 
....................    { 
....................       modbus_serial_putc(make8(values[i],1)); 
....................       modbus_serial_putc(make8(values[i],0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... report_slave_id 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_report_slave_id(unsigned int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_file_record(unsigned int8 address, unsigned int8 byte_count, 
....................                             modbus_read_sub_request *request) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < (byte_count/7); i+=7) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record/data information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_file_record(unsigned int8 address, unsigned int8 byte_count, 
....................                             modbus_write_sub_request *request) 
.................... { 
....................    unsigned int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length) && 
....................             (j < MODBUS_SERIAL_RX_BUFFER_SIZE-8); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... mask_write_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reference_address  Address to mask 
....................            int16      AND_mask           A mask to AND with the data at reference_address 
....................            int16      OR_mask            A mask to OR with the data at reference_address 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_mask_write_register(unsigned int8 address, unsigned int16 reference_address, 
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers 
.................... Input:     int8       address                Slave Address 
....................            int16      read_start             Address to start reading 
....................            int16      read_quantity          Amount of registers to read 
....................            int16      write_start            Address to start writing 
....................            int16      write_quantity         Amount of registers to write 
....................            int16*     write_registers_value  Pointer to an aray us to write 
.................... Output:    exception                         0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_write_multiple_registers(unsigned int8 address, unsigned int16 read_start, 
....................                                     unsigned int16 read_quantity, unsigned int16 write_start, 
....................                                     unsigned int16 write_quantity, 
....................                                     unsigned int16 *write_registers_value) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(read_start,1)); 
....................    modbus_serial_putc(make8(read_start,0)); 
....................  
....................    modbus_serial_putc(make8(read_quantity,1)); 
....................    modbus_serial_putc(make8(read_quantity,0)); 
....................  
....................    modbus_serial_putc(make8(write_start, 1)); 
....................    modbus_serial_putc(make8(write_start, 0)); 
....................  
....................    modbus_serial_putc(make8(write_quantity, 1)); 
....................    modbus_serial_putc(make8(write_quantity, 0)); 
....................  
....................    modbus_serial_putc((unsigned int8)(2*write_quantity)); 
....................  
....................    for(i=0; i < write_quantity ; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(write_registers_value[i], 1)); 
....................       modbus_serial_putc(make8(write_registers_value[i+1], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue 
.................... Input:     int8       address           Slave Address 
....................            int16      FIFO_address      FIFO address 
.................... Output:    exception                    0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_FIFO_queue(unsigned int8 address, unsigned int16 FIFO_address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(FIFO_address, 1)); 
....................    modbus_serial_putc(make8(FIFO_address, 0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... #else 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Slave API                                                                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(unsigned int8 address, unsigned int8 byte_count, unsigned int8* coil_data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     unsigned int8 *input_data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
*
01D9C:  MOVFF  F1,FA
01DA0:  MOVLW  02
01DA2:  MOVWF  xFB
01DA4:  RCALL  1D1C
....................  
....................    modbus_serial_putc(byte_count); 
01DA6:  MOVFF  F2,FC
01DAA:  RCALL  1CF6
....................  
....................    for(i=0; i < byte_count; ++i) 
01DAC:  CLRF   xF5
01DAE:  MOVF   xF2,W
01DB0:  SUBWF  xF5,W
01DB2:  BC    1DD4
....................    { 
....................       modbus_serial_putc(*input_data); 
01DB4:  MOVFF  F4,03
01DB8:  MOVFF  F3,FE9
01DBC:  MOVFF  F4,FEA
01DC0:  MOVFF  FEF,F6
01DC4:  MOVFF  F6,FC
01DC8:  RCALL  1CF6
....................       input_data++; 
01DCA:  INCF   xF3,F
01DCC:  BTFSC  FD8.2
01DCE:  INCF   xF4,F
01DD0:  INCF   xF5,F
01DD2:  BRA    1DAE
....................    } 
....................  
....................    modbus_serial_send_stop(); 
01DD4:  RCALL  1D4A
01DD6:  RETURN 0
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                         unsigned int16 *reg_data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
01DD8:  MOVFF  F4,FA
01DDC:  MOVLW  03
01DDE:  MOVWF  xFB
01DE0:  RCALL  1D1C
....................  
....................    modbus_serial_putc(byte_count); 
01DE2:  MOVFF  F5,FC
01DE6:  RCALL  1CF6
....................  
....................    for(i=0; i < byte_count; i+=2) 
01DE8:  CLRF   xF8
01DEA:  MOVF   xF5,W
01DEC:  SUBWF  xF8,W
01DEE:  BC    1E3E
....................    { 
....................       modbus_serial_putc(make8(*reg_data,1)); 
01DF0:  MOVFF  F7,03
01DF4:  MOVFF  F6,FE9
01DF8:  MOVFF  F7,FEA
01DFC:  MOVFF  FEC,FA
01E00:  MOVF   FED,F
01E02:  MOVFF  FEF,F9
01E06:  MOVFF  FA,FB
01E0A:  MOVFF  FA,FC
01E0E:  RCALL  1CF6
....................       modbus_serial_putc(make8(*reg_data,0)); 
01E10:  MOVFF  F7,03
01E14:  MOVFF  F6,FE9
01E18:  MOVFF  F7,FEA
01E1C:  MOVFF  FEC,FA
01E20:  MOVF   FED,F
01E22:  MOVFF  FEF,F9
01E26:  MOVFF  F9,FB
01E2A:  MOVFF  F9,FC
01E2E:  RCALL  1CF6
....................       reg_data++; 
01E30:  MOVLW  02
01E32:  ADDWF  xF6,F
01E34:  BTFSC  FD8.0
01E36:  INCF   xF7,F
01E38:  MOVLW  02
01E3A:  ADDWF  xF8,F
01E3C:  BRA    1DEA
....................    } 
....................  
....................    modbus_serial_send_stop(); 
01E3E:  RCALL  1D4A
01E40:  GOTO   2142 (RETURN)
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                         unsigned int16 *input_data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
01E44:  MOVFF  F4,FA
01E48:  MOVLW  04
01E4A:  MOVWF  xFB
01E4C:  RCALL  1D1C
....................  
....................    modbus_serial_putc(byte_count); 
01E4E:  MOVFF  F5,FC
01E52:  RCALL  1CF6
....................  
....................    for(i=0; i < byte_count; i+=2) 
01E54:  CLRF   xF8
01E56:  MOVF   xF5,W
01E58:  SUBWF  xF8,W
01E5A:  BC    1EAA
....................    { 
....................       modbus_serial_putc(make8(*input_data,1)); 
01E5C:  MOVFF  F7,03
01E60:  MOVFF  F6,FE9
01E64:  MOVFF  F7,FEA
01E68:  MOVFF  FEC,FA
01E6C:  MOVF   FED,F
01E6E:  MOVFF  FEF,F9
01E72:  MOVFF  FA,FB
01E76:  MOVFF  FA,FC
01E7A:  RCALL  1CF6
....................       modbus_serial_putc(make8(*input_data,0)); 
01E7C:  MOVFF  F7,03
01E80:  MOVFF  F6,FE9
01E84:  MOVFF  F7,FEA
01E88:  MOVFF  FEC,FA
01E8C:  MOVF   FED,F
01E8E:  MOVFF  FEF,F9
01E92:  MOVFF  F9,FB
01E96:  MOVFF  F9,FC
01E9A:  RCALL  1CF6
....................       input_data++; 
01E9C:  MOVLW  02
01E9E:  ADDWF  xF6,F
01EA0:  BTFSC  FD8.0
01EA2:  INCF   xF7,F
01EA4:  MOVLW  02
01EA6:  ADDWF  xF8,F
01EA8:  BRA    1E56
....................    } 
....................  
....................    modbus_serial_send_stop(); 
01EAA:  RCALL  1D4A
01EAC:  GOTO   2142 (RETURN)
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(unsigned int8 address, unsigned int16 output_address, 
....................                                     unsigned int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
01EB0:  MOVFF  F3,FA
01EB4:  MOVLW  05
01EB6:  MOVWF  xFB
01EB8:  RCALL  1D1C
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
01EBA:  MOVFF  F5,F8
01EBE:  MOVFF  F5,FC
01EC2:  RCALL  1CF6
....................    modbus_serial_putc(make8(output_address,0)); 
01EC4:  MOVFF  F4,F8
01EC8:  MOVFF  F4,FC
01ECC:  RCALL  1CF6
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
01ECE:  MOVFF  F7,F8
01ED2:  MOVFF  F7,FC
01ED6:  RCALL  1CF6
....................    modbus_serial_putc(make8(output_value,0)); 
01ED8:  MOVFF  F6,F8
01EDC:  MOVFF  F6,FC
01EE0:  RCALL  1CF6
....................  
....................    modbus_serial_send_stop(); 
01EE2:  RCALL  1D4A
01EE4:  GOTO   21DA (RETURN)
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(unsigned int8 address, unsigned int16 reg_address, 
....................                                         unsigned int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
01EE8:  MOVFF  F5,FA
01EEC:  MOVLW  06
01EEE:  MOVWF  xFB
01EF0:  RCALL  1D1C
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
01EF2:  MOVFF  F7,FA
01EF6:  MOVFF  F7,FC
01EFA:  RCALL  1CF6
....................    modbus_serial_putc(make8(reg_address,0)); 
01EFC:  MOVFF  F6,FA
01F00:  MOVFF  F6,FC
01F04:  RCALL  1CF6
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
01F06:  MOVFF  F9,FA
01F0A:  MOVFF  F9,FC
01F0E:  RCALL  1CF6
....................    modbus_serial_putc(make8(reg_value,0)); 
01F10:  MOVFF  F8,FA
01F14:  MOVFF  F8,FC
01F18:  RCALL  1CF6
....................  
....................    modbus_serial_send_stop(); 
01F1A:  RCALL  1D4A
01F1C:  GOTO   223E (RETURN)
.................... } 
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(unsigned int8 address, unsigned int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(unsigned int8 address, unsigned int16 status, 
....................                                         unsigned int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(unsigned int8 address, unsigned int16 status, 
....................                                     unsigned int16 event_count, unsigned int16 message_count, 
....................                                     unsigned int8 *events, unsigned int8 events_len) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(unsigned int8 address, unsigned int16 start_address, 
....................                                         unsigned int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
*
01F86:  MOVFF  F5,FA
01F8A:  MOVLW  0F
01F8C:  MOVWF  xFB
01F8E:  RCALL  1D1C
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
01F90:  MOVFF  F7,FA
01F94:  MOVFF  F7,FC
01F98:  RCALL  1CF6
....................    modbus_serial_putc(make8(start_address,0)); 
01F9A:  MOVFF  F6,FA
01F9E:  MOVFF  F6,FC
01FA2:  RCALL  1CF6
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
01FA4:  MOVFF  F9,FA
01FA8:  MOVFF  F9,FC
01FAC:  RCALL  1CF6
....................    modbus_serial_putc(make8(quantity,0)); 
01FAE:  MOVFF  F8,FA
01FB2:  MOVFF  F8,FC
01FB6:  RCALL  1CF6
....................  
....................    modbus_serial_send_stop(); 
01FB8:  RCALL  1D4A
01FBA:  GOTO   2302 (RETURN)
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(unsigned int8 address, unsigned int16 start_address, 
....................                                             unsigned int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
01FBE:  MOVFF  F5,FA
01FC2:  MOVLW  10
01FC4:  MOVWF  xFB
01FC6:  RCALL  1D1C
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
01FC8:  MOVFF  F7,FA
01FCC:  MOVFF  F7,FC
01FD0:  RCALL  1CF6
....................    modbus_serial_putc(make8(start_address,0)); 
01FD2:  MOVFF  F6,FA
01FD6:  MOVFF  F6,FC
01FDA:  RCALL  1CF6
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
01FDC:  MOVFF  F9,FA
01FE0:  MOVFF  F9,FC
01FE4:  RCALL  1CF6
....................    modbus_serial_putc(make8(quantity,0)); 
01FE6:  MOVFF  F8,FA
01FEA:  MOVFF  F8,FC
01FEE:  RCALL  1CF6
....................  
....................    modbus_serial_send_stop(); 
01FF0:  RCALL  1D4A
01FF2:  GOTO   23C4 (RETURN)
.................... } 
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(unsigned int8 address, unsigned int8 slave_id, unsigned int1 run_status, 
....................                               unsigned int8 *data, unsigned int8 data_len) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    unsigned int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    unsigned int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(unsigned int8 address, unsigned int16 reference_address, 
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(unsigned int8 address, unsigned int8 data_len, 
....................                                                 unsigned int16 *data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(unsigned int8 address, unsigned int16 FIFO_len, unsigned int16 *data) 
.................... { 
....................    unsigned int8 i; 
....................    unsigned int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       func               function to respond to 
....................            exception   error              exception response to send 
.................... Output:    void 
.................... */ 
.................... void modbus_exception_rsp(unsigned int8 address, unsigned int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
*
01D80:  MOVF   xF2,W
01D82:  IORLW  80
01D84:  MOVWF  xF5
01D86:  MOVFF  F3,F6
01D8A:  MOVFF  F1,FA
01D8E:  MOVWF  xFB
01D90:  RCALL  1D1C
....................    modbus_serial_putc(error); 
01D92:  MOVFF  F4,FC
01D96:  RCALL  1CF6
....................    modbus_serial_send_stop(); 
01D98:  RCALL  1D4A
01D9A:  RETURN 0
.................... } 
....................  
.................... #endif 
.................... #endif //MODBUS_APP_LAYER_C 
....................  
.................... #endif 
....................  
....................  
....................  
.................... int8 swap_bits(int8 c) 
.................... { 
....................    return ((c&1)?128:0)|((c&2)?64:0)|((c&4)?32:0)|((c&8)?16:0)|((c&16)?8:0) 
....................           |((c&32)?4:0)|((c&64)?2:0)|((c&128)?1:0); 
*
01F20:  BTFSS  xF1.0
01F22:  BRA    1F28
01F24:  MOVLW  80
01F26:  BRA    1F2A
01F28:  MOVLW  00
01F2A:  MOVWF  xF2
01F2C:  BTFSS  xF1.1
01F2E:  BRA    1F34
01F30:  MOVLW  40
01F32:  BRA    1F36
01F34:  MOVLW  00
01F36:  IORWF  xF2,F
01F38:  BTFSS  xF1.2
01F3A:  BRA    1F40
01F3C:  MOVLW  20
01F3E:  BRA    1F42
01F40:  MOVLW  00
01F42:  IORWF  xF2,F
01F44:  BTFSS  xF1.3
01F46:  BRA    1F4C
01F48:  MOVLW  10
01F4A:  BRA    1F4E
01F4C:  MOVLW  00
01F4E:  IORWF  xF2,F
01F50:  BTFSS  xF1.4
01F52:  BRA    1F58
01F54:  MOVLW  08
01F56:  BRA    1F5A
01F58:  MOVLW  00
01F5A:  IORWF  xF2,F
01F5C:  BTFSS  xF1.5
01F5E:  BRA    1F64
01F60:  MOVLW  04
01F62:  BRA    1F66
01F64:  MOVLW  00
01F66:  IORWF  xF2,F
01F68:  BTFSS  xF1.6
01F6A:  BRA    1F70
01F6C:  MOVLW  02
01F6E:  BRA    1F72
01F70:  MOVLW  00
01F72:  IORWF  xF2,F
01F74:  BTFSS  xF1.7
01F76:  BRA    1F7C
01F78:  MOVLW  01
01F7A:  BRA    1F7E
01F7C:  MOVLW  00
01F7E:  IORWF  xF2,W
01F80:  MOVWF  01
01F82:  GOTO   226E (RETURN)
.................... } 
....................  
.................... void receiveFromModbus(){ 
....................    //delay_us(50); 
....................  
....................       //check address against our address, 0 is broadcast 
....................       if((modbus_rx.address == MODBUS_ADDRESS) || modbus_rx.address == 0) 
*
01FF6:  DECFSZ x9F,W
01FF8:  BRA    1FFC
01FFA:  BRA    2002
01FFC:  MOVF   x9F,F
01FFE:  BTFSS  FD8.2
02000:  BRA    23DA
....................       { 
....................          switch(modbus_rx.func) 
02002:  MOVF   xA1,W
02004:  XORLW  01
02006:  BZ    202E
02008:  XORLW  03
0200A:  BZ    202E
0200C:  XORLW  01
0200E:  BZ    20C6
02010:  XORLW  07
02012:  BZ    20C6
02014:  XORLW  01
02016:  BTFSC  FD8.2
02018:  BRA    214A
0201A:  XORLW  03
0201C:  BTFSC  FD8.2
0201E:  BRA    21E2
02020:  XORLW  09
02022:  BTFSC  FD8.2
02024:  BRA    2240
02026:  XORLW  1F
02028:  BTFSC  FD8.2
0202A:  BRA    230A
0202C:  BRA    23CC
....................          { 
....................             case FUNC_READ_COILS:    //read coils 
....................             case FUNC_READ_DISCRETE_INPUT:    //read inputs 
....................                if(modbus_rx.data[0] || modbus_rx.data[2] || 
....................                   modbus_rx.data[1] >= 8 || modbus_rx.data[3]+modbus_rx.data[1] > 8){ 
0202E:  MOVF   xA3,F
02030:  BNZ   2044
02032:  MOVF   xA5,F
02034:  BNZ   2044
02036:  MOVF   xA4,W
02038:  SUBLW  07
0203A:  BNC   2044
0203C:  MOVF   xA4,W
0203E:  ADDWF  xA6,W
02040:  SUBLW  08
02042:  BC    2056
....................                   modbus_exception_rsp(MODBUS_ADDRESS,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
02044:  MOVLW  01
02046:  MOVWF  xF1
02048:  CLRF   xF3
0204A:  MOVFF  A1,F2
0204E:  MOVLW  02
02050:  MOVWF  xF4
02052:  RCALL  1D80
....................                   } 
02054:  BRA    20C4
....................                else 
....................                { 
....................                   int8 data; 
....................  
....................                   if(modbus_rx.func == FUNC_READ_COILS) 
02056:  DECFSZ xA1,W
02058:  BRA    206E
....................                      data = coils>>(modbus_rx.data[1]);      //move to the starting coil 
0205A:  MOVFF  1D,EC
0205E:  MOVF   xA4,W
02060:  MOVWF  01
02062:  BZ    206C
02064:  BCF    FD8.0
02066:  RRCF   xEC,F
02068:  DECFSZ 01,F
0206A:  BRA    2064
0206C:  BRA    2080
....................                   else 
....................                      data = inputs>>(modbus_rx.data[1]);      //move to the starting input 
0206E:  MOVFF  1E,EC
02072:  MOVF   xA4,W
02074:  MOVWF  01
02076:  BZ    2080
02078:  BCF    FD8.0
0207A:  RRCF   xEC,F
0207C:  DECFSZ 01,F
0207E:  BRA    2078
....................  
....................                   data = data & (0xFF>>(8-modbus_rx.data[3]));  //0 out values after quantity 
02080:  MOVLW  08
02082:  BSF    FD8.0
02084:  SUBFWB xA6,W
02086:  MOVWF  01
02088:  MOVLW  FF
0208A:  MOVWF  00
0208C:  MOVF   01,F
0208E:  BZ    2098
02090:  BCF    FD8.0
02092:  RRCF   00,F
02094:  DECFSZ 01,F
02096:  BRA    2090
02098:  MOVF   00,W
0209A:  ANDWF  xEC,F
....................  
....................                   if(modbus_rx.func == FUNC_READ_COILS) 
0209C:  DECFSZ xA1,W
0209E:  BRA    20B0
....................                      modbus_read_discrete_input_rsp(MODBUS_ADDRESS, 0x01, &data); 
020A0:  MOVLW  01
020A2:  MOVWF  xF1
020A4:  MOVWF  xF2
020A6:  CLRF   xF4
020A8:  MOVLW  EC
020AA:  MOVWF  xF3
020AC:  RCALL  1D9C
020AE:  BRA    20BE
....................                   else 
....................                      modbus_read_discrete_input_rsp(MODBUS_ADDRESS, 0x01, &data); 
020B0:  MOVLW  01
020B2:  MOVWF  xF1
020B4:  MOVWF  xF2
020B6:  CLRF   xF4
020B8:  MOVLW  EC
020BA:  MOVWF  xF3
020BC:  RCALL  1D9C
....................  
....................                   event_count++; 
020BE:  INCF   37,F
020C0:  BTFSC  FD8.2
020C2:  INCF   38,F
....................                } 
....................                break; 
020C4:  BRA    23DA
....................             case FUNC_READ_HOLDING_REGISTERS: 
....................             case FUNC_READ_INPUT_REGISTERS: 
....................                if(modbus_rx.data[0] || modbus_rx.data[2] || 
....................                   modbus_rx.data[1] >= 8 || modbus_rx.data[3]+modbus_rx.data[1] > 8) 
020C6:  MOVF   xA3,F
020C8:  BNZ   20DC
020CA:  MOVF   xA5,F
020CC:  BNZ   20DC
020CE:  MOVF   xA4,W
020D0:  SUBLW  07
020D2:  BNC   20DC
020D4:  MOVF   xA4,W
020D6:  ADDWF  xA6,W
020D8:  SUBLW  08
020DA:  BC    20EE
....................                   modbus_exception_rsp(MODBUS_ADDRESS,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
020DC:  MOVLW  01
020DE:  MOVWF  xF1
020E0:  CLRF   xF3
020E2:  MOVFF  A1,F2
020E6:  MOVLW  02
020E8:  MOVWF  xF4
020EA:  RCALL  1D80
020EC:  BRA    2148
....................                else 
....................                { 
....................                   if(modbus_rx.func == FUNC_READ_HOLDING_REGISTERS) 
020EE:  MOVF   xA1,W
020F0:  SUBLW  03
020F2:  BNZ   211C
....................                      modbus_read_holding_registers_rsp(MODBUS_ADDRESS,(modbus_rx.data[3]*2),hold_regs+modbus_rx.data[1]); 
020F4:  BCF    FD8.0
020F6:  RLCF   xA6,W
020F8:  MOVWF  xF1
020FA:  BCF    FD8.0
020FC:  RLCF   xA4,W
020FE:  ADDLW  1F
02100:  MOVWF  xF2
02102:  CLRF   xF3
02104:  BTFSC  FD8.0
02106:  INCF   xF3,F
02108:  MOVLW  01
0210A:  MOVWF  xF4
0210C:  MOVFF  F1,F5
02110:  MOVFF  F3,F7
02114:  MOVFF  F2,F6
02118:  BRA    1DD8
0211A:  BRA    2142
....................                   else 
....................                      modbus_read_input_registers_rsp(MODBUS_ADDRESS,(modbus_rx.data[3]*2),input_regs+modbus_rx.data[1]); 
0211C:  BCF    FD8.0
0211E:  RLCF   xA6,W
02120:  MOVWF  xF1
02122:  BCF    FD8.0
02124:  RLCF   xA4,W
02126:  ADDLW  27
02128:  MOVWF  xF2
0212A:  CLRF   xF3
0212C:  BTFSC  FD8.0
0212E:  INCF   xF3,F
02130:  MOVLW  01
02132:  MOVWF  xF4
02134:  MOVFF  F1,F5
02138:  MOVFF  F3,F7
0213C:  MOVFF  F2,F6
02140:  BRA    1E44
....................  
....................                   event_count++; 
02142:  INCF   37,F
02144:  BTFSC  FD8.2
02146:  INCF   38,F
....................                } 
....................                break; 
02148:  BRA    23DA
....................             case FUNC_WRITE_SINGLE_COIL:      //write coil 
....................                if(modbus_rx.data[0] || modbus_rx.data[3] || modbus_rx.data[1] > 8) 
0214A:  MOVF   xA3,F
0214C:  BNZ   2158
0214E:  MOVF   xA6,F
02150:  BNZ   2158
02152:  MOVF   xA4,W
02154:  SUBLW  08
02156:  BC    216A
....................                   modbus_exception_rsp(MODBUS_ADDRESS,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
02158:  MOVLW  01
0215A:  MOVWF  xF1
0215C:  CLRF   xF3
0215E:  MOVFF  A1,F2
02162:  MOVLW  02
02164:  MOVWF  xF4
02166:  RCALL  1D80
02168:  BRA    21E0
....................                else if(modbus_rx.data[2] != 0xFF && modbus_rx.data[2] != 0x00) 
0216A:  INCFSZ xA5,W
0216C:  BRA    2170
0216E:  BRA    2186
02170:  MOVF   xA5,F
02172:  BZ    2186
....................                   modbus_exception_rsp(MODBUS_ADDRESS,modbus_rx.func,ILLEGAL_DATA_VALUE); 
02174:  MOVLW  01
02176:  MOVWF  xF1
02178:  CLRF   xF3
0217A:  MOVFF  A1,F2
0217E:  MOVLW  03
02180:  MOVWF  xF4
02182:  RCALL  1D80
02184:  BRA    21E0
....................                else 
....................                { 
....................                   if(modbus_rx.data[2] == 0xFF) 
02186:  INCFSZ xA5,W
02188:  BRA    21A2
....................                      bit_set(coils,modbus_rx.data[1]); 
0218A:  MOVLW  01
0218C:  MOVWF  00
0218E:  MOVF   xA4,W
02190:  MOVWF  01
02192:  BZ    219C
02194:  BCF    FD8.0
02196:  RLCF   00,F
02198:  DECFSZ 01,F
0219A:  BRA    2194
0219C:  MOVF   00,W
0219E:  IORWF  1D,F
021A0:  BRA    21BA
....................                   else 
....................                      bit_clear(coils,modbus_rx.data[1]); 
021A2:  MOVLW  01
021A4:  MOVWF  00
021A6:  MOVF   xA4,W
021A8:  MOVWF  01
021AA:  BZ    21B4
021AC:  BCF    FD8.0
021AE:  RLCF   00,F
021B0:  DECFSZ 01,F
021B2:  BRA    21AC
021B4:  MOVF   00,W
021B6:  XORLW  FF
021B8:  ANDWF  1D,F
....................  
....................                   modbus_write_single_coil_rsp(MODBUS_ADDRESS,modbus_rx.data[1],((int16)(modbus_rx.data[2]))<<8); 
021BA:  CLRF   xF2
021BC:  MOVFF  A5,F1
021C0:  MOVFF  A5,F2
021C4:  CLRF   xF1
021C6:  MOVLW  01
021C8:  MOVWF  xF3
021CA:  CLRF   xF5
021CC:  MOVFF  A4,F4
021D0:  MOVFF  A5,F7
021D4:  MOVFF  F1,F6
021D8:  BRA    1EB0
....................  
....................                   event_count++; 
021DA:  INCF   37,F
021DC:  BTFSC  FD8.2
021DE:  INCF   38,F
....................                } 
....................                break; 
021E0:  BRA    23DA
....................             case FUNC_WRITE_SINGLE_REGISTER: 
....................                if(modbus_rx.data[0] || modbus_rx.data[1] >= 8) 
021E2:  MOVF   xA3,F
021E4:  BNZ   21EC
021E6:  MOVF   xA4,W
021E8:  SUBLW  07
021EA:  BC    21FE
....................                   modbus_exception_rsp(MODBUS_ADDRESS,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
021EC:  MOVLW  01
021EE:  MOVWF  xF1
021F0:  CLRF   xF3
021F2:  MOVFF  A1,F2
021F6:  MOVLW  02
021F8:  MOVWF  xF4
021FA:  RCALL  1D80
021FC:  BRA    223E
....................                else 
....................                { 
....................                   hold_regs[modbus_rx.data[1]] = make16(modbus_rx.data[2],modbus_rx.data[3]); 
021FE:  BCF    FD8.0
02200:  RLCF   xA4,W
02202:  CLRF   03
02204:  ADDLW  1F
02206:  MOVWF  FE9
02208:  MOVLW  00
0220A:  ADDWFC 03,W
0220C:  MOVWF  FEA
0220E:  MOVFF  A5,FEC
02212:  MOVF   FED,F
02214:  MOVFF  A6,FEF
....................  
....................                   modbus_write_single_register_rsp(MODBUS_ADDRESS, 
....................                                make16(modbus_rx.data[0],modbus_rx.data[1]), 
....................                                make16(modbus_rx.data[2],modbus_rx.data[3])); 
02218:  MOVFF  A3,F2
0221C:  MOVFF  A4,F1
02220:  MOVFF  A5,F4
02224:  MOVFF  A6,F3
02228:  MOVLW  01
0222A:  MOVWF  xF5
0222C:  MOVFF  A3,F7
02230:  MOVFF  A4,F6
02234:  MOVFF  A5,F9
02238:  MOVFF  A6,F8
0223C:  BRA    1EE8
....................                } 
....................                break; 
0223E:  BRA    23DA
....................             case FUNC_WRITE_MULTIPLE_COILS: 
....................                if(modbus_rx.data[0] || modbus_rx.data[2] || 
....................                   modbus_rx.data[1] >= 8 || modbus_rx.data[3]+modbus_rx.data[1] > 8) 
02240:  MOVF   xA3,F
02242:  BNZ   2256
02244:  MOVF   xA5,F
02246:  BNZ   2256
02248:  MOVF   xA4,W
0224A:  SUBLW  07
0224C:  BNC   2256
0224E:  MOVF   xA4,W
02250:  ADDWF  xA6,W
02252:  SUBLW  08
02254:  BC    2268
....................                   modbus_exception_rsp(MODBUS_ADDRESS,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
02256:  MOVLW  01
02258:  MOVWF  xF1
0225A:  CLRF   xF3
0225C:  MOVFF  A1,F2
02260:  MOVLW  02
02262:  MOVWF  xF4
02264:  RCALL  1D80
02266:  BRA    2308
....................                else 
....................                { 
....................                   int i,j; 
....................  
....................                   modbus_rx.data[5] = swap_bits(modbus_rx.data[5]); 
02268:  MOVFF  A8,F1
0226C:  BRA    1F20
0226E:  MOVFF  01,A8
....................  
....................                   for(i=modbus_rx.data[1],j=0; i < modbus_rx.data[1]+modbus_rx.data[3]; ++i,++j) 
02272:  MOVFF  A4,ED
02276:  CLRF   xEE
02278:  MOVF   xA6,W
0227A:  ADDWF  xA4,W
0227C:  SUBWF  xED,W
0227E:  BC    22DC
....................                   { 
....................                      if(bit_test(modbus_rx.data[5],j)) 
02280:  MOVFF  A8,00
02284:  MOVF   xEE,W
02286:  MOVWF  01
02288:  BZ    2292
0228A:  BCF    FD8.0
0228C:  RRCF   00,F
0228E:  DECFSZ 01,F
02290:  BRA    228A
02292:  BTFSS  00.0
02294:  BRA    22B6
....................                         bit_set(coils,7-i); 
02296:  MOVLW  07
02298:  BSF    FD8.0
0229A:  SUBFWB xED,W
0229C:  MOVWF  xF1
0229E:  MOVLW  01
022A0:  MOVWF  00
022A2:  MOVF   xF1,W
022A4:  MOVWF  01
022A6:  BZ    22B0
022A8:  BCF    FD8.0
022AA:  RLCF   00,F
022AC:  DECFSZ 01,F
022AE:  BRA    22A8
022B0:  MOVF   00,W
022B2:  IORWF  1D,F
022B4:  BRA    22D6
....................                      else 
....................                         bit_clear(coils,7-i); 
022B6:  MOVLW  07
022B8:  BSF    FD8.0
022BA:  SUBFWB xED,W
022BC:  MOVWF  xF1
022BE:  MOVLW  01
022C0:  MOVWF  00
022C2:  MOVF   xF1,W
022C4:  MOVWF  01
022C6:  BZ    22D0
022C8:  BCF    FD8.0
022CA:  RLCF   00,F
022CC:  DECFSZ 01,F
022CE:  BRA    22C8
022D0:  MOVF   00,W
022D2:  XORLW  FF
022D4:  ANDWF  1D,F
022D6:  INCF   xED,F
022D8:  INCF   xEE,F
022DA:  BRA    2278
....................                   } 
....................  
....................                   modbus_write_multiple_coils_rsp(MODBUS_ADDRESS, 
....................                                  make16(modbus_rx.data[0],modbus_rx.data[1]), 
....................                                  make16(modbus_rx.data[2],modbus_rx.data[3])); 
022DC:  MOVFF  A3,F2
022E0:  MOVFF  A4,F1
022E4:  MOVFF  A5,F4
022E8:  MOVFF  A6,F3
022EC:  MOVLW  01
022EE:  MOVWF  xF5
022F0:  MOVFF  A3,F7
022F4:  MOVFF  A4,F6
022F8:  MOVFF  A5,F9
022FC:  MOVFF  A6,F8
02300:  BRA    1F86
....................  
....................                   event_count++; 
02302:  INCF   37,F
02304:  BTFSC  FD8.2
02306:  INCF   38,F
....................                } 
....................                break; 
02308:  BRA    23DA
....................             case FUNC_WRITE_MULTIPLE_REGISTERS: 
....................                if(modbus_rx.data[0] || modbus_rx.data[2] || 
....................                   modbus_rx.data[1] >= 8 || modbus_rx.data[3]+modbus_rx.data[1] > 8) 
0230A:  MOVF   xA3,F
0230C:  BNZ   2320
0230E:  MOVF   xA5,F
02310:  BNZ   2320
02312:  MOVF   xA4,W
02314:  SUBLW  07
02316:  BNC   2320
02318:  MOVF   xA4,W
0231A:  ADDWF  xA6,W
0231C:  SUBLW  08
0231E:  BC    2332
....................                   modbus_exception_rsp(MODBUS_ADDRESS,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
02320:  MOVLW  01
02322:  MOVWF  xF1
02324:  CLRF   xF3
02326:  MOVFF  A1,F2
0232A:  MOVLW  02
0232C:  MOVWF  xF4
0232E:  RCALL  1D80
02330:  BRA    23CA
....................                else 
....................                { 
....................                   int i,j; 
....................  
....................                   for(i=0,j=5; i < modbus_rx.data[4]/2; ++i,j+=2) 
02332:  CLRF   xEF
02334:  MOVLW  05
02336:  MOVWF  xF0
02338:  BCF    FD8.0
0233A:  RRCF   xA7,W
0233C:  SUBWF  xEF,W
0233E:  BC    239E
....................                      hold_regs[i] = make16(modbus_rx.data[j],modbus_rx.data[j+1]); 
02340:  BCF    FD8.0
02342:  RLCF   xEF,W
02344:  CLRF   03
02346:  ADDLW  1F
02348:  MOVWF  01
0234A:  MOVLW  00
0234C:  ADDWFC 03,F
0234E:  MOVFF  01,F1
02352:  MOVFF  03,F2
02356:  CLRF   03
02358:  MOVF   xF0,W
0235A:  ADDLW  A3
0235C:  MOVWF  FE9
0235E:  MOVLW  00
02360:  ADDWFC 03,W
02362:  MOVWF  FEA
02364:  MOVFF  FEF,F3
02368:  MOVLW  01
0236A:  ADDWF  xF0,W
0236C:  CLRF   03
0236E:  ADDLW  A3
02370:  MOVWF  FE9
02372:  MOVLW  00
02374:  ADDWFC 03,W
02376:  MOVWF  FEA
02378:  MOVFF  FEF,F4
0237C:  MOVFF  F3,F6
02380:  MOVFF  F4,F5
02384:  MOVFF  F2,FEA
02388:  MOVFF  01,FE9
0238C:  MOVFF  F3,FEC
02390:  MOVF   FED,F
02392:  MOVFF  F4,FEF
02396:  INCF   xEF,F
02398:  MOVLW  02
0239A:  ADDWF  xF0,F
0239C:  BRA    2338
....................  
....................                   modbus_write_multiple_registers_rsp(MODBUS_ADDRESS, 
....................                                  make16(modbus_rx.data[0],modbus_rx.data[1]), 
....................                                  make16(modbus_rx.data[2],modbus_rx.data[3])); 
0239E:  MOVFF  A3,F2
023A2:  MOVFF  A4,F1
023A6:  MOVFF  A5,F4
023AA:  MOVFF  A6,F3
023AE:  MOVLW  01
023B0:  MOVWF  xF5
023B2:  MOVFF  A3,F7
023B6:  MOVFF  A4,F6
023BA:  MOVFF  A5,F9
023BE:  MOVFF  A6,F8
023C2:  BRA    1FBE
....................  
....................                   event_count++; 
023C4:  INCF   37,F
023C6:  BTFSC  FD8.2
023C8:  INCF   38,F
....................                } 
....................                break; 
023CA:  BRA    23DA
....................             default:    //We don't support the function, so return exception 
....................                modbus_exception_rsp(MODBUS_ADDRESS,modbus_rx.func,ILLEGAL_FUNCTION); 
023CC:  MOVLW  01
023CE:  MOVWF  xF1
023D0:  CLRF   xF3
023D2:  MOVFF  A1,F2
023D6:  MOVWF  xF4
023D8:  RCALL  1D80
....................          } 
....................       } 
023DA:  GOTO   2570 (RETURN)
.................... } 
....................  
....................  
.................... #define DEBUG_MSG(msg) fprintf(PC, msg) 
.................... #define DEBUG_DATA(msg,data) fprintf(PC, msg, data) 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define LOADER_END   0x5FF 
.................... #include <bootloader.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                       BOOTLOADER.H                                //// 
.................... ////                                                                   //// 
.................... ////  This include file must be included by any application loaded     //// 
.................... ////  by the example bootloader (ex_bootloader.c).                     //// 
.................... ////                                                                   //// 
.................... ////  The directives in this file relocate the reset and interrupt     //// 
.................... ////  vectors as well as reserving space for the bootloader.           //// 
.................... ////                                                                   //// 
.................... ////  LOADER_END may need to be adjusted for a specific chip and       //// 
.................... ////  bootloader.  LOADER_END must be 1 minus a multiple of            //// 
.................... ////  FLASH_ERASE_SIZE.                                                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2013 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #ifndef __BOOTLOADER_H__ 
.................... #define __BOOTLOADER_H__ 
....................  
.................... #ifndef LOADER_END 
....................  #if defined(__PCM__) 
....................   #define LOADER_END 0x2FF 
....................  #elif defined(__PCH__) 
....................   #define FLASH_SIZE getenv("FLASH_ERASE_SIZE") 
....................   #if ((0x500 % FLASH_SIZE) == 0)         //IF 0x500 is even flash boundary 
....................    #define LOADER_END   0x4FF 
....................   #else                                  //ELSE, goto next even boundary 
....................    #define LOADER_END   ((0x500+FLASH_SIZE-(0x500 % FLASH_SIZE))-1) 
....................   #endif 
....................  #else 
....................   #error Bootloader only works with PCM or PCH compiler 
....................  #endif 
.................... #endif 
....................  
.................... #define LOADER_SIZE   LOADER_END 
....................  
.................... #ifndef BOOTLOADER_AT_START 
....................  #define BOOTLOADER_AT_START 
.................... #endif 
....................  
.................... #ifndef _bootloader 
....................  #if defined(__PCM__) 
....................   #build(reset=LOADER_END+1, interrupt=LOADER_END+5) 
....................  #elif defined(__PCH__) 
....................   #build(reset=LOADER_END+1, interrupt=LOADER_END+9) 
....................  #endif 
....................  
....................  #org 0, LOADER_END {} 
.................... #else 
....................  #ifdef __PCM__ 
....................   #if getenv("PROGRAM_MEMORY") <= 0x800 
....................    #org LOADER_END+3, (getenv("PROGRAM_MEMORY") - 1) {} 
....................   #else 
....................    #org LOADER_END+3, 0x7FF {} 
....................    #if getenv("PROGRAM_MEMORY") <= 0x1000 
....................     #org 0x800, (getenv("PROGRAM_MEMORY") - 1) {} 
....................    #else 
....................     #org 0x800, 0xFFF{} 
....................     #if getenv("PROGRAM_MEMORY") <= 0x1800 
....................      #org 0x1000, (getenv("PROGRAM_MEMORY") - 1) {} 
....................     #else 
....................      #org 0x1000, 0x17FF {} 
....................      #if getenv("PROGRAM_MEMORY") <= 0x2000 
....................       #org 0x1800, (getenv("PROGRAM_MEMORY") - 1) {} 
....................      #else 
....................       #org 0x1800, 0x1FFF {} 
....................       #if getenv("PROGRAM_MEMORY") <= 0x2800 
....................        #org 0x2000, (getenv("PROGRAM_MEMORY") - 1) {} 
....................       #else 
....................        #org 0x2000, 0x27FF {} 
....................        #if getenv("PROGRAM_MEMORY") <= 0x3000 
....................         #org 0x2800, (getenv("PROGRAM_MEMORY") - 1) {} 
....................        #else 
....................         #org 0x2800, 0x2FFF {} 
....................         #if getenv("PROGRAM_MEMORY") <= 0x3800 
....................          #org 0x3000, (getenv("PROGRAM_MEMORY") - 1) {} 
....................         #else 
....................          #org 0x3000, 0x37FF {} 
....................          #org 0x3800, 0x3FFF {} 
....................         #endif 
....................        #endif 
....................       #endif 
....................      #endif 
....................     #endif 
....................    #endif 
....................   #endif 
....................  #else 
....................   #if getenv("PROGRAM_MEMORY") <= 0x10000 
....................    #org LOADER_END+5, (getenv("PROGRAM_MEMORY") - 1) {} 
....................   #else 
....................    #org LOADER_END+5, 0xFFFE {} 
....................    #org 0x10000, (getenv("PROGRAM_MEMORY") - 1) {} 
....................   #endif 
....................  #endif 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... int le_ad(int num) 
.................... { 
....................    set_adc_channel(num); 
....................    return read_adc(); 
.................... } 
....................  
.................... void le_batidas(){ 
....................    disable_interrupts(GLOBAL); 
*
013B6:  BCF    FF2.6
013B8:  BCF    FF2.7
013BA:  BTFSC  FF2.7
013BC:  BRA    13B8
....................    set_adc_channel(1); 
013BE:  MOVLW  04
013C0:  MOVWF  01
013C2:  MOVF   FC2,W
013C4:  ANDLW  83
013C6:  IORWF  01,W
013C8:  MOVWF  FC2
013CA:  MOVLW  00
013CC:  MOVWF  01
013CE:  MOVF   FC1,W
013D0:  ANDLW  F8
013D2:  IORWF  01,W
013D4:  MOVWF  FC1
....................    delay_us(10); 
013D6:  MOVLW  0C
013D8:  MOVWF  00
013DA:  DECFSZ 00,F
013DC:  BRA    13DA
013DE:  BRA    13E0
013E0:  NOP   
....................     
....................    ler_batidas(); 
013E2:  BRA    12FC
....................     
....................    enable_interrupts(GLOBAL); 
013E4:  MOVLW  C0
013E6:  IORWF  FF2,F
....................     
....................    hold_regs[2] = BPM; 
013E8:  MOVFF  3C,24
013EC:  MOVFF  3B,23
013F0:  GOTO   2524 (RETURN)
.................... } 
....................  
.................... void main() 
*
023DE:  CLRF   FF8
023E0:  BCF    FD0.7
023E2:  BSF    07.7
023E4:  MOVLW  72
023E6:  MOVWF  FD3
023E8:  CLRF   F9B
023EA:  CLRF   F64
023EC:  BSF    FA7.3
023EE:  MOVLW  A0
023F0:  MOVWF  FAF
023F2:  MOVLW  01
023F4:  MOVWF  F7D
023F6:  MOVLW  A6
023F8:  MOVWF  FAC
023FA:  MOVLW  90
023FC:  MOVWF  FAB
023FE:  MOVLW  05
02400:  MOVWF  1D
02402:  MOVLW  09
02404:  MOVWF  1E
02406:  CLRF   38
02408:  CLRF   37
0240A:  MOVLW  01
0240C:  MOVWF  39
0240E:  MOVWF  3A
02410:  MOVLW  58
02412:  MOVWF  3E
02414:  BCF    3F.0
02416:  BCF    3F.1
02418:  CLRF   41
0241A:  CLRF   40
0241C:  MOVLW  0F
0241E:  MOVWF  43
02420:  MOVLW  A0
02422:  MOVWF  42
02424:  CLRF   45
02426:  MOVLW  64
02428:  MOVWF  44
0242A:  CLRF   48
0242C:  CLRF   49
0242E:  CLRF   4A
02430:  CLRF   4B
02432:  CLRF   54
02434:  BCF    3F.2
02436:  BCF    3F.3
02438:  CLRF   xE4
0243A:  CLRF   xE3
0243C:  MOVLW  35
0243E:  MOVWF  FCD
02440:  CLRF   FAA
02442:  CLRF   FCF
02444:  CLRF   FCE
02446:  BCF    F9E.0
02448:  BSF    F9D.0
0244A:  BCF    F93.3
0244C:  BSF    F8A.3
0244E:  BCF    3F.4
02450:  CLRF   xE5
02452:  MOVLB  F
02454:  MOVF   x5C,W
02456:  ANDLW  80
02458:  MOVWF  x5C
0245A:  MOVLW  00
0245C:  MOVWF  x5D
0245E:  BCF    FC1.3
02460:  BCF    FC1.4
02462:  BCF    FC1.5
02464:  CLRF   x5E
02466:  CLRF   x5F
02468:  BRA    2474
0246A:  DATA 02,00
0246C:  DATA 17,00
0246E:  DATA 00,18
02470:  DATA 40,1F
02472:  DATA 00,00
02474:  MOVLW  00
02476:  MOVWF  FF8
02478:  MOVLW  24
0247A:  MOVWF  FF7
0247C:  MOVLW  6A
0247E:  MOVWF  FF6
02480:  TBLRD*+
02482:  MOVF   FF5,W
02484:  MOVWF  00
02486:  XORLW  00
02488:  BZ    24B0
0248A:  TBLRD*+
0248C:  MOVF   FF5,W
0248E:  MOVWF  01
02490:  BTFSC  FE8.7
02492:  BRA    249E
02494:  ANDLW  0F
02496:  MOVWF  FEA
02498:  TBLRD*+
0249A:  MOVFF  FF5,FE9
0249E:  BTFSC  01.6
024A0:  TBLRD*+
024A2:  BTFSS  01.6
024A4:  TBLRD*+
024A6:  MOVFF  FF5,FEE
024AA:  DCFSNZ 00,F
024AC:  BRA    2480
024AE:  BRA    24A2
024B0:  CLRF   FF8
.................... { 
....................    //setup_adc_ports(NO_ANALOGS); 
....................    set_tris_a(0b00000011); 
024B2:  MOVLW  03
024B4:  MOVWF  F92
....................    setup_comparator(NC_NC_NC_NC);               //Desabilita Comparadores 
024B6:  MOVLW  04
024B8:  MOVWF  x5E
024BA:  MOVWF  x5F
....................     
....................    setup_adc_ports(sAN1,VSS_VDD); 
024BC:  MOVF   x5C,W
024BE:  ANDLW  80
024C0:  MOVWF  x5C
024C2:  MOVLW  02
024C4:  MOVWF  x5D
024C6:  BCF    FC1.3
024C8:  BCF    FC1.4
024CA:  BCF    FC1.5
....................    setup_adc(ADC_CLOCK_INTERNAL); 
024CC:  MOVF   FC0,W
024CE:  ANDLW  C0
024D0:  IORLW  07
024D2:  MOVWF  FC0
024D4:  BSF    FC0.7
024D6:  BSF    FC2.0
....................    modbus_init(); 
024D8:  MOVLB  0
024DA:  GOTO   0A66
....................  
....................    float time = 0; 
024DE:  CLRF   xEB
024E0:  CLRF   xEA
024E2:  CLRF   xE9
024E4:  CLRF   xE8
....................  
....................    fprintf(PC,"INICIALIZADO"); 
024E6:  MOVLW  4C
024E8:  MOVWF  FF6
024EA:  MOVLW  0A
024EC:  MOVWF  FF7
024EE:  GOTO   0A74
....................        
....................    while(TRUE) 
....................    { 
....................       while(!modbus_kbhit()) { 
024F2:  GOTO   0B26
024F6:  MOVF   01,F
024F8:  BNZ   256E
....................          if (time > 70){             
024FA:  MOVLB  1
024FC:  CLRF   x09
024FE:  CLRF   x08
02500:  MOVLW  0C
02502:  MOVWF  x07
02504:  MOVLW  85
02506:  MOVWF  x06
02508:  MOVFF  EB,10D
0250C:  MOVFF  EA,10C
02510:  MOVFF  E9,10B
02514:  MOVFF  E8,10A
02518:  MOVLB  0
0251A:  CALL   0B4A
0251E:  BNC   2532
....................             le_batidas(); 
02520:  GOTO   13B6
....................             le_DS18B20(); 
02524:  GOTO   1A42
....................             time = 0; 
02528:  CLRF   xEB
0252A:  CLRF   xEA
0252C:  CLRF   xE9
0252E:  CLRF   xE8
....................          }else{ 
02530:  BRA    256C
....................             time += 0.001; 
02532:  BCF    FD8.1
02534:  MOVFF  EB,109
02538:  MOVFF  EA,108
0253C:  MOVFF  E9,107
02540:  MOVFF  E8,106
02544:  MOVLW  6F
02546:  MOVLB  1
02548:  MOVWF  x0D
0254A:  MOVLW  12
0254C:  MOVWF  x0C
0254E:  MOVLW  03
02550:  MOVWF  x0B
02552:  MOVLW  75
02554:  MOVWF  x0A
02556:  MOVLB  0
02558:  CALL   0CF0
0255C:  MOVFF  03,EB
02560:  MOVFF  02,EA
02564:  MOVFF  01,E9
02568:  MOVFF  00,E8
....................          } 
0256C:  BRA    24F2
....................       } 
....................       receiveFromModbus(); 
0256E:  BRA    1FF6
02570:  BRA    24F2
....................    } 
.................... } 
02572:  SLEEP 

Configuration Fuses:
   Word  1: C815   VREGSLEEP INTRC_HP SOSC_DIG NOXINST INTRC_IO NOPLLEN FCMEN IESO
   Word  2: 7C78   PUT NOBROWNOUT BORV18 ZPBORM NOWDT WDT1048576
   Word  3: 0900   CANB MSSPMSK7 NOMCLR
   Word  4: 0091   STVREN BBSIZ2K NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
